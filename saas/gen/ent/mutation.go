// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"saas/gen/ent/media"
	"saas/gen/ent/mediable"
	"saas/gen/ent/post"
	"saas/gen/ent/predicate"
	"sync"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeMedia    = "Media"
	TypeMediable = "Mediable"
	TypePost     = "Post"
)

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                Op
	typ               string
	id                *string
	app_id            *string
	disk              *string
	directory         *string
	name              *string
	original_name     *string
	extension         *string
	mime_type         *string
	aggregate_type    *string
	size              *uint
	addsize           *int
	description       *string
	is_variant        *bool
	variant_name      *string
	original_media_id *string
	checksum          *string
	workspace_id      *string
	alt               *string
	uid               *string
	status            *bool
	clearedFields     map[string]struct{}
	mediables         map[string]struct{}
	removedmediables  map[string]struct{}
	clearedmediables  bool
	done              bool
	oldValue          func(context.Context) (*Media, error)
	predicates        []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id string) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Media entities.
func (m *MediaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *MediaMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *MediaMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *MediaMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[media.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *MediaMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[media.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *MediaMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, media.FieldAppID)
}

// SetDisk sets the "disk" field.
func (m *MediaMutation) SetDisk(s string) {
	m.disk = &s
}

// Disk returns the value of the "disk" field in the mutation.
func (m *MediaMutation) Disk() (r string, exists bool) {
	v := m.disk
	if v == nil {
		return
	}
	return *v, true
}

// OldDisk returns the old "disk" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDisk(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisk: %w", err)
	}
	return oldValue.Disk, nil
}

// ClearDisk clears the value of the "disk" field.
func (m *MediaMutation) ClearDisk() {
	m.disk = nil
	m.clearedFields[media.FieldDisk] = struct{}{}
}

// DiskCleared returns if the "disk" field was cleared in this mutation.
func (m *MediaMutation) DiskCleared() bool {
	_, ok := m.clearedFields[media.FieldDisk]
	return ok
}

// ResetDisk resets all changes to the "disk" field.
func (m *MediaMutation) ResetDisk() {
	m.disk = nil
	delete(m.clearedFields, media.FieldDisk)
}

// SetDirectory sets the "directory" field.
func (m *MediaMutation) SetDirectory(s string) {
	m.directory = &s
}

// Directory returns the value of the "directory" field in the mutation.
func (m *MediaMutation) Directory() (r string, exists bool) {
	v := m.directory
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectory returns the old "directory" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDirectory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectory: %w", err)
	}
	return oldValue.Directory, nil
}

// ClearDirectory clears the value of the "directory" field.
func (m *MediaMutation) ClearDirectory() {
	m.directory = nil
	m.clearedFields[media.FieldDirectory] = struct{}{}
}

// DirectoryCleared returns if the "directory" field was cleared in this mutation.
func (m *MediaMutation) DirectoryCleared() bool {
	_, ok := m.clearedFields[media.FieldDirectory]
	return ok
}

// ResetDirectory resets all changes to the "directory" field.
func (m *MediaMutation) ResetDirectory() {
	m.directory = nil
	delete(m.clearedFields, media.FieldDirectory)
}

// SetName sets the "name" field.
func (m *MediaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MediaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MediaMutation) ClearName() {
	m.name = nil
	m.clearedFields[media.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MediaMutation) NameCleared() bool {
	_, ok := m.clearedFields[media.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MediaMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, media.FieldName)
}

// SetOriginalName sets the "original_name" field.
func (m *MediaMutation) SetOriginalName(s string) {
	m.original_name = &s
}

// OriginalName returns the value of the "original_name" field in the mutation.
func (m *MediaMutation) OriginalName() (r string, exists bool) {
	v := m.original_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalName returns the old "original_name" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldOriginalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalName: %w", err)
	}
	return oldValue.OriginalName, nil
}

// ClearOriginalName clears the value of the "original_name" field.
func (m *MediaMutation) ClearOriginalName() {
	m.original_name = nil
	m.clearedFields[media.FieldOriginalName] = struct{}{}
}

// OriginalNameCleared returns if the "original_name" field was cleared in this mutation.
func (m *MediaMutation) OriginalNameCleared() bool {
	_, ok := m.clearedFields[media.FieldOriginalName]
	return ok
}

// ResetOriginalName resets all changes to the "original_name" field.
func (m *MediaMutation) ResetOriginalName() {
	m.original_name = nil
	delete(m.clearedFields, media.FieldOriginalName)
}

// SetExtension sets the "extension" field.
func (m *MediaMutation) SetExtension(s string) {
	m.extension = &s
}

// Extension returns the value of the "extension" field in the mutation.
func (m *MediaMutation) Extension() (r string, exists bool) {
	v := m.extension
	if v == nil {
		return
	}
	return *v, true
}

// OldExtension returns the old "extension" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtension: %w", err)
	}
	return oldValue.Extension, nil
}

// ClearExtension clears the value of the "extension" field.
func (m *MediaMutation) ClearExtension() {
	m.extension = nil
	m.clearedFields[media.FieldExtension] = struct{}{}
}

// ExtensionCleared returns if the "extension" field was cleared in this mutation.
func (m *MediaMutation) ExtensionCleared() bool {
	_, ok := m.clearedFields[media.FieldExtension]
	return ok
}

// ResetExtension resets all changes to the "extension" field.
func (m *MediaMutation) ResetExtension() {
	m.extension = nil
	delete(m.clearedFields, media.FieldExtension)
}

// SetMimeType sets the "mime_type" field.
func (m *MediaMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *MediaMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *MediaMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[media.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *MediaMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[media.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *MediaMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, media.FieldMimeType)
}

// SetAggregateType sets the "aggregate_type" field.
func (m *MediaMutation) SetAggregateType(s string) {
	m.aggregate_type = &s
}

// AggregateType returns the value of the "aggregate_type" field in the mutation.
func (m *MediaMutation) AggregateType() (r string, exists bool) {
	v := m.aggregate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregateType returns the old "aggregate_type" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldAggregateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregateType: %w", err)
	}
	return oldValue.AggregateType, nil
}

// ClearAggregateType clears the value of the "aggregate_type" field.
func (m *MediaMutation) ClearAggregateType() {
	m.aggregate_type = nil
	m.clearedFields[media.FieldAggregateType] = struct{}{}
}

// AggregateTypeCleared returns if the "aggregate_type" field was cleared in this mutation.
func (m *MediaMutation) AggregateTypeCleared() bool {
	_, ok := m.clearedFields[media.FieldAggregateType]
	return ok
}

// ResetAggregateType resets all changes to the "aggregate_type" field.
func (m *MediaMutation) ResetAggregateType() {
	m.aggregate_type = nil
	delete(m.clearedFields, media.FieldAggregateType)
}

// SetSize sets the "size" field.
func (m *MediaMutation) SetSize(u uint) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *MediaMutation) Size() (r uint, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldSize(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *MediaMutation) AddSize(u int) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *MediaMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *MediaMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[media.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *MediaMutation) SizeCleared() bool {
	_, ok := m.clearedFields[media.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *MediaMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, media.FieldSize)
}

// SetDescription sets the "description" field.
func (m *MediaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MediaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MediaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[media.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MediaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[media.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MediaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, media.FieldDescription)
}

// SetIsVariant sets the "is_variant" field.
func (m *MediaMutation) SetIsVariant(b bool) {
	m.is_variant = &b
}

// IsVariant returns the value of the "is_variant" field in the mutation.
func (m *MediaMutation) IsVariant() (r bool, exists bool) {
	v := m.is_variant
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVariant returns the old "is_variant" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldIsVariant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVariant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVariant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVariant: %w", err)
	}
	return oldValue.IsVariant, nil
}

// ClearIsVariant clears the value of the "is_variant" field.
func (m *MediaMutation) ClearIsVariant() {
	m.is_variant = nil
	m.clearedFields[media.FieldIsVariant] = struct{}{}
}

// IsVariantCleared returns if the "is_variant" field was cleared in this mutation.
func (m *MediaMutation) IsVariantCleared() bool {
	_, ok := m.clearedFields[media.FieldIsVariant]
	return ok
}

// ResetIsVariant resets all changes to the "is_variant" field.
func (m *MediaMutation) ResetIsVariant() {
	m.is_variant = nil
	delete(m.clearedFields, media.FieldIsVariant)
}

// SetVariantName sets the "variant_name" field.
func (m *MediaMutation) SetVariantName(s string) {
	m.variant_name = &s
}

// VariantName returns the value of the "variant_name" field in the mutation.
func (m *MediaMutation) VariantName() (r string, exists bool) {
	v := m.variant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVariantName returns the old "variant_name" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldVariantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariantName: %w", err)
	}
	return oldValue.VariantName, nil
}

// ClearVariantName clears the value of the "variant_name" field.
func (m *MediaMutation) ClearVariantName() {
	m.variant_name = nil
	m.clearedFields[media.FieldVariantName] = struct{}{}
}

// VariantNameCleared returns if the "variant_name" field was cleared in this mutation.
func (m *MediaMutation) VariantNameCleared() bool {
	_, ok := m.clearedFields[media.FieldVariantName]
	return ok
}

// ResetVariantName resets all changes to the "variant_name" field.
func (m *MediaMutation) ResetVariantName() {
	m.variant_name = nil
	delete(m.clearedFields, media.FieldVariantName)
}

// SetOriginalMediaID sets the "original_media_id" field.
func (m *MediaMutation) SetOriginalMediaID(s string) {
	m.original_media_id = &s
}

// OriginalMediaID returns the value of the "original_media_id" field in the mutation.
func (m *MediaMutation) OriginalMediaID() (r string, exists bool) {
	v := m.original_media_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalMediaID returns the old "original_media_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldOriginalMediaID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalMediaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalMediaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalMediaID: %w", err)
	}
	return oldValue.OriginalMediaID, nil
}

// ClearOriginalMediaID clears the value of the "original_media_id" field.
func (m *MediaMutation) ClearOriginalMediaID() {
	m.original_media_id = nil
	m.clearedFields[media.FieldOriginalMediaID] = struct{}{}
}

// OriginalMediaIDCleared returns if the "original_media_id" field was cleared in this mutation.
func (m *MediaMutation) OriginalMediaIDCleared() bool {
	_, ok := m.clearedFields[media.FieldOriginalMediaID]
	return ok
}

// ResetOriginalMediaID resets all changes to the "original_media_id" field.
func (m *MediaMutation) ResetOriginalMediaID() {
	m.original_media_id = nil
	delete(m.clearedFields, media.FieldOriginalMediaID)
}

// SetChecksum sets the "checksum" field.
func (m *MediaMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *MediaMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ClearChecksum clears the value of the "checksum" field.
func (m *MediaMutation) ClearChecksum() {
	m.checksum = nil
	m.clearedFields[media.FieldChecksum] = struct{}{}
}

// ChecksumCleared returns if the "checksum" field was cleared in this mutation.
func (m *MediaMutation) ChecksumCleared() bool {
	_, ok := m.clearedFields[media.FieldChecksum]
	return ok
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *MediaMutation) ResetChecksum() {
	m.checksum = nil
	delete(m.clearedFields, media.FieldChecksum)
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *MediaMutation) SetWorkspaceID(s string) {
	m.workspace_id = &s
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *MediaMutation) WorkspaceID() (r string, exists bool) {
	v := m.workspace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldWorkspaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *MediaMutation) ResetWorkspaceID() {
	m.workspace_id = nil
}

// SetAlt sets the "alt" field.
func (m *MediaMutation) SetAlt(s string) {
	m.alt = &s
}

// Alt returns the value of the "alt" field in the mutation.
func (m *MediaMutation) Alt() (r string, exists bool) {
	v := m.alt
	if v == nil {
		return
	}
	return *v, true
}

// OldAlt returns the old "alt" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldAlt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlt: %w", err)
	}
	return oldValue.Alt, nil
}

// ClearAlt clears the value of the "alt" field.
func (m *MediaMutation) ClearAlt() {
	m.alt = nil
	m.clearedFields[media.FieldAlt] = struct{}{}
}

// AltCleared returns if the "alt" field was cleared in this mutation.
func (m *MediaMutation) AltCleared() bool {
	_, ok := m.clearedFields[media.FieldAlt]
	return ok
}

// ResetAlt resets all changes to the "alt" field.
func (m *MediaMutation) ResetAlt() {
	m.alt = nil
	delete(m.clearedFields, media.FieldAlt)
}

// SetUID sets the "uid" field.
func (m *MediaMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *MediaMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ClearUID clears the value of the "uid" field.
func (m *MediaMutation) ClearUID() {
	m.uid = nil
	m.clearedFields[media.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *MediaMutation) UIDCleared() bool {
	_, ok := m.clearedFields[media.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *MediaMutation) ResetUID() {
	m.uid = nil
	delete(m.clearedFields, media.FieldUID)
}

// SetStatus sets the "status" field.
func (m *MediaMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *MediaMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MediaMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[media.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MediaMutation) StatusCleared() bool {
	_, ok := m.clearedFields[media.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MediaMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, media.FieldStatus)
}

// AddMediableIDs adds the "mediables" edge to the Mediable entity by ids.
func (m *MediaMutation) AddMediableIDs(ids ...string) {
	if m.mediables == nil {
		m.mediables = make(map[string]struct{})
	}
	for i := range ids {
		m.mediables[ids[i]] = struct{}{}
	}
}

// ClearMediables clears the "mediables" edge to the Mediable entity.
func (m *MediaMutation) ClearMediables() {
	m.clearedmediables = true
}

// MediablesCleared reports if the "mediables" edge to the Mediable entity was cleared.
func (m *MediaMutation) MediablesCleared() bool {
	return m.clearedmediables
}

// RemoveMediableIDs removes the "mediables" edge to the Mediable entity by IDs.
func (m *MediaMutation) RemoveMediableIDs(ids ...string) {
	if m.removedmediables == nil {
		m.removedmediables = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.mediables, ids[i])
		m.removedmediables[ids[i]] = struct{}{}
	}
}

// RemovedMediables returns the removed IDs of the "mediables" edge to the Mediable entity.
func (m *MediaMutation) RemovedMediablesIDs() (ids []string) {
	for id := range m.removedmediables {
		ids = append(ids, id)
	}
	return
}

// MediablesIDs returns the "mediables" edge IDs in the mutation.
func (m *MediaMutation) MediablesIDs() (ids []string) {
	for id := range m.mediables {
		ids = append(ids, id)
	}
	return
}

// ResetMediables resets all changes to the "mediables" edge.
func (m *MediaMutation) ResetMediables() {
	m.mediables = nil
	m.clearedmediables = false
	m.removedmediables = nil
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 18)
	if m.app_id != nil {
		fields = append(fields, media.FieldAppID)
	}
	if m.disk != nil {
		fields = append(fields, media.FieldDisk)
	}
	if m.directory != nil {
		fields = append(fields, media.FieldDirectory)
	}
	if m.name != nil {
		fields = append(fields, media.FieldName)
	}
	if m.original_name != nil {
		fields = append(fields, media.FieldOriginalName)
	}
	if m.extension != nil {
		fields = append(fields, media.FieldExtension)
	}
	if m.mime_type != nil {
		fields = append(fields, media.FieldMimeType)
	}
	if m.aggregate_type != nil {
		fields = append(fields, media.FieldAggregateType)
	}
	if m.size != nil {
		fields = append(fields, media.FieldSize)
	}
	if m.description != nil {
		fields = append(fields, media.FieldDescription)
	}
	if m.is_variant != nil {
		fields = append(fields, media.FieldIsVariant)
	}
	if m.variant_name != nil {
		fields = append(fields, media.FieldVariantName)
	}
	if m.original_media_id != nil {
		fields = append(fields, media.FieldOriginalMediaID)
	}
	if m.checksum != nil {
		fields = append(fields, media.FieldChecksum)
	}
	if m.workspace_id != nil {
		fields = append(fields, media.FieldWorkspaceID)
	}
	if m.alt != nil {
		fields = append(fields, media.FieldAlt)
	}
	if m.uid != nil {
		fields = append(fields, media.FieldUID)
	}
	if m.status != nil {
		fields = append(fields, media.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldAppID:
		return m.AppID()
	case media.FieldDisk:
		return m.Disk()
	case media.FieldDirectory:
		return m.Directory()
	case media.FieldName:
		return m.Name()
	case media.FieldOriginalName:
		return m.OriginalName()
	case media.FieldExtension:
		return m.Extension()
	case media.FieldMimeType:
		return m.MimeType()
	case media.FieldAggregateType:
		return m.AggregateType()
	case media.FieldSize:
		return m.Size()
	case media.FieldDescription:
		return m.Description()
	case media.FieldIsVariant:
		return m.IsVariant()
	case media.FieldVariantName:
		return m.VariantName()
	case media.FieldOriginalMediaID:
		return m.OriginalMediaID()
	case media.FieldChecksum:
		return m.Checksum()
	case media.FieldWorkspaceID:
		return m.WorkspaceID()
	case media.FieldAlt:
		return m.Alt()
	case media.FieldUID:
		return m.UID()
	case media.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldAppID:
		return m.OldAppID(ctx)
	case media.FieldDisk:
		return m.OldDisk(ctx)
	case media.FieldDirectory:
		return m.OldDirectory(ctx)
	case media.FieldName:
		return m.OldName(ctx)
	case media.FieldOriginalName:
		return m.OldOriginalName(ctx)
	case media.FieldExtension:
		return m.OldExtension(ctx)
	case media.FieldMimeType:
		return m.OldMimeType(ctx)
	case media.FieldAggregateType:
		return m.OldAggregateType(ctx)
	case media.FieldSize:
		return m.OldSize(ctx)
	case media.FieldDescription:
		return m.OldDescription(ctx)
	case media.FieldIsVariant:
		return m.OldIsVariant(ctx)
	case media.FieldVariantName:
		return m.OldVariantName(ctx)
	case media.FieldOriginalMediaID:
		return m.OldOriginalMediaID(ctx)
	case media.FieldChecksum:
		return m.OldChecksum(ctx)
	case media.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case media.FieldAlt:
		return m.OldAlt(ctx)
	case media.FieldUID:
		return m.OldUID(ctx)
	case media.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case media.FieldDisk:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisk(v)
		return nil
	case media.FieldDirectory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectory(v)
		return nil
	case media.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case media.FieldOriginalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalName(v)
		return nil
	case media.FieldExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtension(v)
		return nil
	case media.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case media.FieldAggregateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregateType(v)
		return nil
	case media.FieldSize:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case media.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case media.FieldIsVariant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVariant(v)
		return nil
	case media.FieldVariantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariantName(v)
		return nil
	case media.FieldOriginalMediaID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalMediaID(v)
		return nil
	case media.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case media.FieldWorkspaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case media.FieldAlt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlt(v)
		return nil
	case media.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case media.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, media.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case media.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case media.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(media.FieldAppID) {
		fields = append(fields, media.FieldAppID)
	}
	if m.FieldCleared(media.FieldDisk) {
		fields = append(fields, media.FieldDisk)
	}
	if m.FieldCleared(media.FieldDirectory) {
		fields = append(fields, media.FieldDirectory)
	}
	if m.FieldCleared(media.FieldName) {
		fields = append(fields, media.FieldName)
	}
	if m.FieldCleared(media.FieldOriginalName) {
		fields = append(fields, media.FieldOriginalName)
	}
	if m.FieldCleared(media.FieldExtension) {
		fields = append(fields, media.FieldExtension)
	}
	if m.FieldCleared(media.FieldMimeType) {
		fields = append(fields, media.FieldMimeType)
	}
	if m.FieldCleared(media.FieldAggregateType) {
		fields = append(fields, media.FieldAggregateType)
	}
	if m.FieldCleared(media.FieldSize) {
		fields = append(fields, media.FieldSize)
	}
	if m.FieldCleared(media.FieldDescription) {
		fields = append(fields, media.FieldDescription)
	}
	if m.FieldCleared(media.FieldIsVariant) {
		fields = append(fields, media.FieldIsVariant)
	}
	if m.FieldCleared(media.FieldVariantName) {
		fields = append(fields, media.FieldVariantName)
	}
	if m.FieldCleared(media.FieldOriginalMediaID) {
		fields = append(fields, media.FieldOriginalMediaID)
	}
	if m.FieldCleared(media.FieldChecksum) {
		fields = append(fields, media.FieldChecksum)
	}
	if m.FieldCleared(media.FieldAlt) {
		fields = append(fields, media.FieldAlt)
	}
	if m.FieldCleared(media.FieldUID) {
		fields = append(fields, media.FieldUID)
	}
	if m.FieldCleared(media.FieldStatus) {
		fields = append(fields, media.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	switch name {
	case media.FieldAppID:
		m.ClearAppID()
		return nil
	case media.FieldDisk:
		m.ClearDisk()
		return nil
	case media.FieldDirectory:
		m.ClearDirectory()
		return nil
	case media.FieldName:
		m.ClearName()
		return nil
	case media.FieldOriginalName:
		m.ClearOriginalName()
		return nil
	case media.FieldExtension:
		m.ClearExtension()
		return nil
	case media.FieldMimeType:
		m.ClearMimeType()
		return nil
	case media.FieldAggregateType:
		m.ClearAggregateType()
		return nil
	case media.FieldSize:
		m.ClearSize()
		return nil
	case media.FieldDescription:
		m.ClearDescription()
		return nil
	case media.FieldIsVariant:
		m.ClearIsVariant()
		return nil
	case media.FieldVariantName:
		m.ClearVariantName()
		return nil
	case media.FieldOriginalMediaID:
		m.ClearOriginalMediaID()
		return nil
	case media.FieldChecksum:
		m.ClearChecksum()
		return nil
	case media.FieldAlt:
		m.ClearAlt()
		return nil
	case media.FieldUID:
		m.ClearUID()
		return nil
	case media.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldAppID:
		m.ResetAppID()
		return nil
	case media.FieldDisk:
		m.ResetDisk()
		return nil
	case media.FieldDirectory:
		m.ResetDirectory()
		return nil
	case media.FieldName:
		m.ResetName()
		return nil
	case media.FieldOriginalName:
		m.ResetOriginalName()
		return nil
	case media.FieldExtension:
		m.ResetExtension()
		return nil
	case media.FieldMimeType:
		m.ResetMimeType()
		return nil
	case media.FieldAggregateType:
		m.ResetAggregateType()
		return nil
	case media.FieldSize:
		m.ResetSize()
		return nil
	case media.FieldDescription:
		m.ResetDescription()
		return nil
	case media.FieldIsVariant:
		m.ResetIsVariant()
		return nil
	case media.FieldVariantName:
		m.ResetVariantName()
		return nil
	case media.FieldOriginalMediaID:
		m.ResetOriginalMediaID()
		return nil
	case media.FieldChecksum:
		m.ResetChecksum()
		return nil
	case media.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case media.FieldAlt:
		m.ResetAlt()
		return nil
	case media.FieldUID:
		m.ResetUID()
		return nil
	case media.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.mediables != nil {
		edges = append(edges, media.EdgeMediables)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeMediables:
		ids := make([]ent.Value, 0, len(m.mediables))
		for id := range m.mediables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedmediables != nil {
		edges = append(edges, media.EdgeMediables)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case media.EdgeMediables:
		ids := make([]ent.Value, 0, len(m.removedmediables))
		for id := range m.removedmediables {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmediables {
		edges = append(edges, media.EdgeMediables)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	switch name {
	case media.EdgeMediables:
		return m.clearedmediables
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	switch name {
	case media.EdgeMediables:
		m.ResetMediables()
		return nil
	}
	return fmt.Errorf("unknown Media edge %s", name)
}

// MediableMutation represents an operation that mutates the Mediable nodes in the graph.
type MediableMutation struct {
	config
	op            Op
	typ           string
	id            *string
	app_id        *string
	mediable_id   *string
	mediable_type *string
	tag           *string
	_order        *int
	add_order     *int
	clearedFields map[string]struct{}
	media         *string
	clearedmedia  bool
	done          bool
	oldValue      func(context.Context) (*Mediable, error)
	predicates    []predicate.Mediable
}

var _ ent.Mutation = (*MediableMutation)(nil)

// mediableOption allows management of the mutation configuration using functional options.
type mediableOption func(*MediableMutation)

// newMediableMutation creates new mutation for the Mediable entity.
func newMediableMutation(c config, op Op, opts ...mediableOption) *MediableMutation {
	m := &MediableMutation{
		config:        c,
		op:            op,
		typ:           TypeMediable,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediableID sets the ID field of the mutation.
func withMediableID(id string) mediableOption {
	return func(m *MediableMutation) {
		var (
			err   error
			once  sync.Once
			value *Mediable
		)
		m.oldValue = func(ctx context.Context) (*Mediable, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mediable.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMediable sets the old Mediable of the mutation.
func withMediable(node *Mediable) mediableOption {
	return func(m *MediableMutation) {
		m.oldValue = func(context.Context) (*Mediable, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediableMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediableMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mediable entities.
func (m *MediableMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediableMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediableMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mediable.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetAppID sets the "app_id" field.
func (m *MediableMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *MediableMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Mediable entity.
// If the Mediable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediableMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *MediableMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[mediable.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *MediableMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[mediable.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *MediableMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, mediable.FieldAppID)
}

// SetMediaID sets the "media_id" field.
func (m *MediableMutation) SetMediaID(s string) {
	m.media = &s
}

// MediaID returns the value of the "media_id" field in the mutation.
func (m *MediableMutation) MediaID() (r string, exists bool) {
	v := m.media
	if v == nil {
		return
	}
	return *v, true
}

// OldMediaID returns the old "media_id" field's value of the Mediable entity.
// If the Mediable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediableMutation) OldMediaID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediaID: %w", err)
	}
	return oldValue.MediaID, nil
}

// ClearMediaID clears the value of the "media_id" field.
func (m *MediableMutation) ClearMediaID() {
	m.media = nil
	m.clearedFields[mediable.FieldMediaID] = struct{}{}
}

// MediaIDCleared returns if the "media_id" field was cleared in this mutation.
func (m *MediableMutation) MediaIDCleared() bool {
	_, ok := m.clearedFields[mediable.FieldMediaID]
	return ok
}

// ResetMediaID resets all changes to the "media_id" field.
func (m *MediableMutation) ResetMediaID() {
	m.media = nil
	delete(m.clearedFields, mediable.FieldMediaID)
}

// SetMediableID sets the "mediable_id" field.
func (m *MediableMutation) SetMediableID(s string) {
	m.mediable_id = &s
}

// MediableID returns the value of the "mediable_id" field in the mutation.
func (m *MediableMutation) MediableID() (r string, exists bool) {
	v := m.mediable_id
	if v == nil {
		return
	}
	return *v, true
}

// OldMediableID returns the old "mediable_id" field's value of the Mediable entity.
// If the Mediable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediableMutation) OldMediableID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediableID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediableID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediableID: %w", err)
	}
	return oldValue.MediableID, nil
}

// ClearMediableID clears the value of the "mediable_id" field.
func (m *MediableMutation) ClearMediableID() {
	m.mediable_id = nil
	m.clearedFields[mediable.FieldMediableID] = struct{}{}
}

// MediableIDCleared returns if the "mediable_id" field was cleared in this mutation.
func (m *MediableMutation) MediableIDCleared() bool {
	_, ok := m.clearedFields[mediable.FieldMediableID]
	return ok
}

// ResetMediableID resets all changes to the "mediable_id" field.
func (m *MediableMutation) ResetMediableID() {
	m.mediable_id = nil
	delete(m.clearedFields, mediable.FieldMediableID)
}

// SetMediableType sets the "mediable_type" field.
func (m *MediableMutation) SetMediableType(s string) {
	m.mediable_type = &s
}

// MediableType returns the value of the "mediable_type" field in the mutation.
func (m *MediableMutation) MediableType() (r string, exists bool) {
	v := m.mediable_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMediableType returns the old "mediable_type" field's value of the Mediable entity.
// If the Mediable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediableMutation) OldMediableType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMediableType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMediableType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMediableType: %w", err)
	}
	return oldValue.MediableType, nil
}

// ClearMediableType clears the value of the "mediable_type" field.
func (m *MediableMutation) ClearMediableType() {
	m.mediable_type = nil
	m.clearedFields[mediable.FieldMediableType] = struct{}{}
}

// MediableTypeCleared returns if the "mediable_type" field was cleared in this mutation.
func (m *MediableMutation) MediableTypeCleared() bool {
	_, ok := m.clearedFields[mediable.FieldMediableType]
	return ok
}

// ResetMediableType resets all changes to the "mediable_type" field.
func (m *MediableMutation) ResetMediableType() {
	m.mediable_type = nil
	delete(m.clearedFields, mediable.FieldMediableType)
}

// SetTag sets the "tag" field.
func (m *MediableMutation) SetTag(s string) {
	m.tag = &s
}

// Tag returns the value of the "tag" field in the mutation.
func (m *MediableMutation) Tag() (r string, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTag returns the old "tag" field's value of the Mediable entity.
// If the Mediable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediableMutation) OldTag(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTag is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTag requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTag: %w", err)
	}
	return oldValue.Tag, nil
}

// ClearTag clears the value of the "tag" field.
func (m *MediableMutation) ClearTag() {
	m.tag = nil
	m.clearedFields[mediable.FieldTag] = struct{}{}
}

// TagCleared returns if the "tag" field was cleared in this mutation.
func (m *MediableMutation) TagCleared() bool {
	_, ok := m.clearedFields[mediable.FieldTag]
	return ok
}

// ResetTag resets all changes to the "tag" field.
func (m *MediableMutation) ResetTag() {
	m.tag = nil
	delete(m.clearedFields, mediable.FieldTag)
}

// SetOrder sets the "order" field.
func (m *MediableMutation) SetOrder(i int) {
	m._order = &i
	m.add_order = nil
}

// Order returns the value of the "order" field in the mutation.
func (m *MediableMutation) Order() (r int, exists bool) {
	v := m._order
	if v == nil {
		return
	}
	return *v, true
}

// OldOrder returns the old "order" field's value of the Mediable entity.
// If the Mediable object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediableMutation) OldOrder(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOrder is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOrder requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrder: %w", err)
	}
	return oldValue.Order, nil
}

// AddOrder adds i to the "order" field.
func (m *MediableMutation) AddOrder(i int) {
	if m.add_order != nil {
		*m.add_order += i
	} else {
		m.add_order = &i
	}
}

// AddedOrder returns the value that was added to the "order" field in this mutation.
func (m *MediableMutation) AddedOrder() (r int, exists bool) {
	v := m.add_order
	if v == nil {
		return
	}
	return *v, true
}

// ClearOrder clears the value of the "order" field.
func (m *MediableMutation) ClearOrder() {
	m._order = nil
	m.add_order = nil
	m.clearedFields[mediable.FieldOrder] = struct{}{}
}

// OrderCleared returns if the "order" field was cleared in this mutation.
func (m *MediableMutation) OrderCleared() bool {
	_, ok := m.clearedFields[mediable.FieldOrder]
	return ok
}

// ResetOrder resets all changes to the "order" field.
func (m *MediableMutation) ResetOrder() {
	m._order = nil
	m.add_order = nil
	delete(m.clearedFields, mediable.FieldOrder)
}

// ClearMedia clears the "media" edge to the Media entity.
func (m *MediableMutation) ClearMedia() {
	m.clearedmedia = true
	m.clearedFields[mediable.FieldMediaID] = struct{}{}
}

// MediaCleared reports if the "media" edge to the Media entity was cleared.
func (m *MediableMutation) MediaCleared() bool {
	return m.MediaIDCleared() || m.clearedmedia
}

// MediaIDs returns the "media" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MediaID instead. It exists only for internal usage by the builders.
func (m *MediableMutation) MediaIDs() (ids []string) {
	if id := m.media; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMedia resets all changes to the "media" edge.
func (m *MediableMutation) ResetMedia() {
	m.media = nil
	m.clearedmedia = false
}

// Where appends a list predicates to the MediableMutation builder.
func (m *MediableMutation) Where(ps ...predicate.Mediable) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediableMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediableMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mediable, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediableMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediableMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mediable).
func (m *MediableMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediableMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.app_id != nil {
		fields = append(fields, mediable.FieldAppID)
	}
	if m.media != nil {
		fields = append(fields, mediable.FieldMediaID)
	}
	if m.mediable_id != nil {
		fields = append(fields, mediable.FieldMediableID)
	}
	if m.mediable_type != nil {
		fields = append(fields, mediable.FieldMediableType)
	}
	if m.tag != nil {
		fields = append(fields, mediable.FieldTag)
	}
	if m._order != nil {
		fields = append(fields, mediable.FieldOrder)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediableMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mediable.FieldAppID:
		return m.AppID()
	case mediable.FieldMediaID:
		return m.MediaID()
	case mediable.FieldMediableID:
		return m.MediableID()
	case mediable.FieldMediableType:
		return m.MediableType()
	case mediable.FieldTag:
		return m.Tag()
	case mediable.FieldOrder:
		return m.Order()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediableMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mediable.FieldAppID:
		return m.OldAppID(ctx)
	case mediable.FieldMediaID:
		return m.OldMediaID(ctx)
	case mediable.FieldMediableID:
		return m.OldMediableID(ctx)
	case mediable.FieldMediableType:
		return m.OldMediableType(ctx)
	case mediable.FieldTag:
		return m.OldTag(ctx)
	case mediable.FieldOrder:
		return m.OldOrder(ctx)
	}
	return nil, fmt.Errorf("unknown Mediable field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediableMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mediable.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case mediable.FieldMediaID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediaID(v)
		return nil
	case mediable.FieldMediableID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediableID(v)
		return nil
	case mediable.FieldMediableType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMediableType(v)
		return nil
	case mediable.FieldTag:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTag(v)
		return nil
	case mediable.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Mediable field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediableMutation) AddedFields() []string {
	var fields []string
	if m.add_order != nil {
		fields = append(fields, mediable.FieldOrder)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediableMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mediable.FieldOrder:
		return m.AddedOrder()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediableMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mediable.FieldOrder:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOrder(v)
		return nil
	}
	return fmt.Errorf("unknown Mediable numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediableMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mediable.FieldAppID) {
		fields = append(fields, mediable.FieldAppID)
	}
	if m.FieldCleared(mediable.FieldMediaID) {
		fields = append(fields, mediable.FieldMediaID)
	}
	if m.FieldCleared(mediable.FieldMediableID) {
		fields = append(fields, mediable.FieldMediableID)
	}
	if m.FieldCleared(mediable.FieldMediableType) {
		fields = append(fields, mediable.FieldMediableType)
	}
	if m.FieldCleared(mediable.FieldTag) {
		fields = append(fields, mediable.FieldTag)
	}
	if m.FieldCleared(mediable.FieldOrder) {
		fields = append(fields, mediable.FieldOrder)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediableMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediableMutation) ClearField(name string) error {
	switch name {
	case mediable.FieldAppID:
		m.ClearAppID()
		return nil
	case mediable.FieldMediaID:
		m.ClearMediaID()
		return nil
	case mediable.FieldMediableID:
		m.ClearMediableID()
		return nil
	case mediable.FieldMediableType:
		m.ClearMediableType()
		return nil
	case mediable.FieldTag:
		m.ClearTag()
		return nil
	case mediable.FieldOrder:
		m.ClearOrder()
		return nil
	}
	return fmt.Errorf("unknown Mediable nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediableMutation) ResetField(name string) error {
	switch name {
	case mediable.FieldAppID:
		m.ResetAppID()
		return nil
	case mediable.FieldMediaID:
		m.ResetMediaID()
		return nil
	case mediable.FieldMediableID:
		m.ResetMediableID()
		return nil
	case mediable.FieldMediableType:
		m.ResetMediableType()
		return nil
	case mediable.FieldTag:
		m.ResetTag()
		return nil
	case mediable.FieldOrder:
		m.ResetOrder()
		return nil
	}
	return fmt.Errorf("unknown Mediable field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediableMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.media != nil {
		edges = append(edges, mediable.EdgeMedia)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediableMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mediable.EdgeMedia:
		if id := m.media; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediableMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediableMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediableMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedmedia {
		edges = append(edges, mediable.EdgeMedia)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediableMutation) EdgeCleared(name string) bool {
	switch name {
	case mediable.EdgeMedia:
		return m.clearedmedia
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediableMutation) ClearEdge(name string) error {
	switch name {
	case mediable.EdgeMedia:
		m.ClearMedia()
		return nil
	}
	return fmt.Errorf("unknown Mediable unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediableMutation) ResetEdge(name string) error {
	switch name {
	case mediable.EdgeMedia:
		m.ResetMedia()
		return nil
	}
	return fmt.Errorf("unknown Mediable edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	featured_medias         map[string]struct{}
	selectedfeatured_medias map[string]struct{}
	removedfeatured_medias  map[string]struct{}
	clearedfeatured_medias  bool
	icon_medias             map[string]struct{}
	selectedicon_medias     map[string]struct{}
	removedicon_medias      map[string]struct{}
	clearedicon_medias      bool
	config
	op            Op
	typ           string
	id            *string
	name          *string
	slug          *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Post, error)
	predicates    []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id string) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetName sets the "name" field.
func (m *PostMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PostMutation) ClearName() {
	m.name = nil
	m.clearedFields[post.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PostMutation) NameCleared() bool {
	_, ok := m.clearedFields[post.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PostMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, post.FieldName)
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[post.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostMutation) SlugCleared() bool {
	_, ok := m.clearedFields[post.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, post.FieldSlug)
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.name != nil {
		fields = append(fields, post.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldName:
		return m.Name()
	case post.FieldSlug:
		return m.Slug()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldName:
		return m.OldName(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldName) {
		fields = append(fields, post.FieldName)
	}
	if m.FieldCleared(post.FieldSlug) {
		fields = append(fields, post.FieldSlug)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldName:
		m.ClearName()
		return nil
	case post.FieldSlug:
		m.ClearSlug()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldName:
		m.ResetName()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Post edge %s", name)
}
