// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"lace/jsonslice"
	"lace/jsontype"
	"saas/gen/ent/adminuser"
	"saas/gen/ent/app"
	"saas/gen/ent/appperm"
	"saas/gen/ent/approle"
	"saas/gen/ent/approleperm"
	"saas/gen/ent/appuser"
	"saas/gen/ent/kache"
	"saas/gen/ent/keyvalue"
	"saas/gen/ent/mailconn"
	"saas/gen/ent/media"
	"saas/gen/ent/oauthconnection"
	"saas/gen/ent/plan"
	"saas/gen/ent/post"
	"saas/gen/ent/postcategory"
	"saas/gen/ent/poststatus"
	"saas/gen/ent/posttag"
	"saas/gen/ent/posttype"
	"saas/gen/ent/posttypeform"
	"saas/gen/ent/predicate"
	"saas/gen/ent/session"
	"saas/gen/ent/temp"
	"saas/gen/ent/templ"
	"saas/gen/ent/todo"
	"saas/gen/ent/user"
	"saas/gen/ent/workspace"
	"saas/gen/ent/workspaceinvite"
	"saas/gen/ent/workspaceuser"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAdminUser       = "AdminUser"
	TypeApp             = "App"
	TypeAppPerm         = "AppPerm"
	TypeAppRole         = "AppRole"
	TypeAppRolePerm     = "AppRolePerm"
	TypeAppUser         = "AppUser"
	TypeKache           = "Kache"
	TypeKeyvalue        = "Keyvalue"
	TypeMailConn        = "MailConn"
	TypeMedia           = "Media"
	TypeOauthConnection = "OauthConnection"
	TypePlan            = "Plan"
	TypePost            = "Post"
	TypePostCategory    = "PostCategory"
	TypePostStatus      = "PostStatus"
	TypePostTag         = "PostTag"
	TypePostType        = "PostType"
	TypePostTypeForm    = "PostTypeForm"
	TypeSession         = "Session"
	TypeTemp            = "Temp"
	TypeTempl           = "Templ"
	TypeTodo            = "Todo"
	TypeUser            = "User"
	TypeWorkspace       = "Workspace"
	TypeWorkspaceInvite = "WorkspaceInvite"
	TypeWorkspaceUser   = "WorkspaceUser"
)

// AdminUserMutation represents an operation that mutates the AdminUser nodes in the graph.
type AdminUserMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	email              *string
	phone              *string
	first_name         *string
	last_name          *string
	company            *string
	locale             *string
	role_id            *string
	status             *bool
	password           *string
	secret             *string
	api_key            *string
	welcome_email_sent *bool
	clearedFields      map[string]struct{}
	apps               map[string]struct{}
	removedapps        map[string]struct{}
	clearedapps        bool
	app_users          map[string]struct{}
	removedapp_users   map[string]struct{}
	clearedapp_users   bool
	done               bool
	oldValue           func(context.Context) (*AdminUser, error)
	predicates         []predicate.AdminUser
}

var _ ent.Mutation = (*AdminUserMutation)(nil)

// adminuserOption allows management of the mutation configuration using functional options.
type adminuserOption func(*AdminUserMutation)

// newAdminUserMutation creates new mutation for the AdminUser entity.
func newAdminUserMutation(c config, op Op, opts ...adminuserOption) *AdminUserMutation {
	m := &AdminUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAdminUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAdminUserID sets the ID field of the mutation.
func withAdminUserID(id string) adminuserOption {
	return func(m *AdminUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AdminUser
		)
		m.oldValue = func(ctx context.Context) (*AdminUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AdminUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAdminUser sets the old AdminUser of the mutation.
func withAdminUser(node *AdminUser) adminuserOption {
	return func(m *AdminUserMutation) {
		m.oldValue = func(context.Context) (*AdminUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AdminUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AdminUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AdminUser entities.
func (m *AdminUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AdminUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AdminUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AdminUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AdminUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AdminUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AdminUserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[adminuser.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AdminUserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AdminUserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, adminuser.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AdminUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AdminUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AdminUserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[adminuser.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AdminUserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AdminUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, adminuser.FieldUpdatedAt)
}

// SetEmail sets the "email" field.
func (m *AdminUserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AdminUserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AdminUserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *AdminUserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *AdminUserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *AdminUserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[adminuser.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *AdminUserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *AdminUserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, adminuser.FieldPhone)
}

// SetFirstName sets the "first_name" field.
func (m *AdminUserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AdminUserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *AdminUserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[adminuser.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *AdminUserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AdminUserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, adminuser.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *AdminUserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AdminUserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *AdminUserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[adminuser.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *AdminUserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AdminUserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, adminuser.FieldLastName)
}

// SetCompany sets the "company" field.
func (m *AdminUserMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *AdminUserMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *AdminUserMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[adminuser.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *AdminUserMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *AdminUserMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, adminuser.FieldCompany)
}

// SetLocale sets the "locale" field.
func (m *AdminUserMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *AdminUserMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ClearLocale clears the value of the "locale" field.
func (m *AdminUserMutation) ClearLocale() {
	m.locale = nil
	m.clearedFields[adminuser.FieldLocale] = struct{}{}
}

// LocaleCleared returns if the "locale" field was cleared in this mutation.
func (m *AdminUserMutation) LocaleCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldLocale]
	return ok
}

// ResetLocale resets all changes to the "locale" field.
func (m *AdminUserMutation) ResetLocale() {
	m.locale = nil
	delete(m.clearedFields, adminuser.FieldLocale)
}

// SetRoleID sets the "role_id" field.
func (m *AdminUserMutation) SetRoleID(s string) {
	m.role_id = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *AdminUserMutation) RoleID() (r string, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *AdminUserMutation) ClearRoleID() {
	m.role_id = nil
	m.clearedFields[adminuser.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *AdminUserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *AdminUserMutation) ResetRoleID() {
	m.role_id = nil
	delete(m.clearedFields, adminuser.FieldRoleID)
}

// SetStatus sets the "status" field.
func (m *AdminUserMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *AdminUserMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *AdminUserMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[adminuser.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *AdminUserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *AdminUserMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, adminuser.FieldStatus)
}

// SetPassword sets the "password" field.
func (m *AdminUserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *AdminUserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *AdminUserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[adminuser.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *AdminUserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *AdminUserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, adminuser.FieldPassword)
}

// SetSecret sets the "secret" field.
func (m *AdminUserMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *AdminUserMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ClearSecret clears the value of the "secret" field.
func (m *AdminUserMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[adminuser.FieldSecret] = struct{}{}
}

// SecretCleared returns if the "secret" field was cleared in this mutation.
func (m *AdminUserMutation) SecretCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldSecret]
	return ok
}

// ResetSecret resets all changes to the "secret" field.
func (m *AdminUserMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, adminuser.FieldSecret)
}

// SetAPIKey sets the "api_key" field.
func (m *AdminUserMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *AdminUserMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ClearAPIKey clears the value of the "api_key" field.
func (m *AdminUserMutation) ClearAPIKey() {
	m.api_key = nil
	m.clearedFields[adminuser.FieldAPIKey] = struct{}{}
}

// APIKeyCleared returns if the "api_key" field was cleared in this mutation.
func (m *AdminUserMutation) APIKeyCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldAPIKey]
	return ok
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *AdminUserMutation) ResetAPIKey() {
	m.api_key = nil
	delete(m.clearedFields, adminuser.FieldAPIKey)
}

// SetWelcomeEmailSent sets the "welcome_email_sent" field.
func (m *AdminUserMutation) SetWelcomeEmailSent(b bool) {
	m.welcome_email_sent = &b
}

// WelcomeEmailSent returns the value of the "welcome_email_sent" field in the mutation.
func (m *AdminUserMutation) WelcomeEmailSent() (r bool, exists bool) {
	v := m.welcome_email_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldWelcomeEmailSent returns the old "welcome_email_sent" field's value of the AdminUser entity.
// If the AdminUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AdminUserMutation) OldWelcomeEmailSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWelcomeEmailSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWelcomeEmailSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWelcomeEmailSent: %w", err)
	}
	return oldValue.WelcomeEmailSent, nil
}

// ClearWelcomeEmailSent clears the value of the "welcome_email_sent" field.
func (m *AdminUserMutation) ClearWelcomeEmailSent() {
	m.welcome_email_sent = nil
	m.clearedFields[adminuser.FieldWelcomeEmailSent] = struct{}{}
}

// WelcomeEmailSentCleared returns if the "welcome_email_sent" field was cleared in this mutation.
func (m *AdminUserMutation) WelcomeEmailSentCleared() bool {
	_, ok := m.clearedFields[adminuser.FieldWelcomeEmailSent]
	return ok
}

// ResetWelcomeEmailSent resets all changes to the "welcome_email_sent" field.
func (m *AdminUserMutation) ResetWelcomeEmailSent() {
	m.welcome_email_sent = nil
	delete(m.clearedFields, adminuser.FieldWelcomeEmailSent)
}

// AddAppIDs adds the "apps" edge to the App entity by ids.
func (m *AdminUserMutation) AddAppIDs(ids ...string) {
	if m.apps == nil {
		m.apps = make(map[string]struct{})
	}
	for i := range ids {
		m.apps[ids[i]] = struct{}{}
	}
}

// ClearApps clears the "apps" edge to the App entity.
func (m *AdminUserMutation) ClearApps() {
	m.clearedapps = true
}

// AppsCleared reports if the "apps" edge to the App entity was cleared.
func (m *AdminUserMutation) AppsCleared() bool {
	return m.clearedapps
}

// RemoveAppIDs removes the "apps" edge to the App entity by IDs.
func (m *AdminUserMutation) RemoveAppIDs(ids ...string) {
	if m.removedapps == nil {
		m.removedapps = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.apps, ids[i])
		m.removedapps[ids[i]] = struct{}{}
	}
}

// RemovedApps returns the removed IDs of the "apps" edge to the App entity.
func (m *AdminUserMutation) RemovedAppsIDs() (ids []string) {
	for id := range m.removedapps {
		ids = append(ids, id)
	}
	return
}

// AppsIDs returns the "apps" edge IDs in the mutation.
func (m *AdminUserMutation) AppsIDs() (ids []string) {
	for id := range m.apps {
		ids = append(ids, id)
	}
	return
}

// ResetApps resets all changes to the "apps" edge.
func (m *AdminUserMutation) ResetApps() {
	m.apps = nil
	m.clearedapps = false
	m.removedapps = nil
}

// AddAppUserIDs adds the "app_users" edge to the AppUser entity by ids.
func (m *AdminUserMutation) AddAppUserIDs(ids ...string) {
	if m.app_users == nil {
		m.app_users = make(map[string]struct{})
	}
	for i := range ids {
		m.app_users[ids[i]] = struct{}{}
	}
}

// ClearAppUsers clears the "app_users" edge to the AppUser entity.
func (m *AdminUserMutation) ClearAppUsers() {
	m.clearedapp_users = true
}

// AppUsersCleared reports if the "app_users" edge to the AppUser entity was cleared.
func (m *AdminUserMutation) AppUsersCleared() bool {
	return m.clearedapp_users
}

// RemoveAppUserIDs removes the "app_users" edge to the AppUser entity by IDs.
func (m *AdminUserMutation) RemoveAppUserIDs(ids ...string) {
	if m.removedapp_users == nil {
		m.removedapp_users = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.app_users, ids[i])
		m.removedapp_users[ids[i]] = struct{}{}
	}
}

// RemovedAppUsers returns the removed IDs of the "app_users" edge to the AppUser entity.
func (m *AdminUserMutation) RemovedAppUsersIDs() (ids []string) {
	for id := range m.removedapp_users {
		ids = append(ids, id)
	}
	return
}

// AppUsersIDs returns the "app_users" edge IDs in the mutation.
func (m *AdminUserMutation) AppUsersIDs() (ids []string) {
	for id := range m.app_users {
		ids = append(ids, id)
	}
	return
}

// ResetAppUsers resets all changes to the "app_users" edge.
func (m *AdminUserMutation) ResetAppUsers() {
	m.app_users = nil
	m.clearedapp_users = false
	m.removedapp_users = nil
}

// Where appends a list predicates to the AdminUserMutation builder.
func (m *AdminUserMutation) Where(ps ...predicate.AdminUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AdminUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AdminUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AdminUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AdminUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AdminUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AdminUser).
func (m *AdminUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AdminUserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, adminuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, adminuser.FieldUpdatedAt)
	}
	if m.email != nil {
		fields = append(fields, adminuser.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, adminuser.FieldPhone)
	}
	if m.first_name != nil {
		fields = append(fields, adminuser.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, adminuser.FieldLastName)
	}
	if m.company != nil {
		fields = append(fields, adminuser.FieldCompany)
	}
	if m.locale != nil {
		fields = append(fields, adminuser.FieldLocale)
	}
	if m.role_id != nil {
		fields = append(fields, adminuser.FieldRoleID)
	}
	if m.status != nil {
		fields = append(fields, adminuser.FieldStatus)
	}
	if m.password != nil {
		fields = append(fields, adminuser.FieldPassword)
	}
	if m.secret != nil {
		fields = append(fields, adminuser.FieldSecret)
	}
	if m.api_key != nil {
		fields = append(fields, adminuser.FieldAPIKey)
	}
	if m.welcome_email_sent != nil {
		fields = append(fields, adminuser.FieldWelcomeEmailSent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AdminUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case adminuser.FieldCreatedAt:
		return m.CreatedAt()
	case adminuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case adminuser.FieldEmail:
		return m.Email()
	case adminuser.FieldPhone:
		return m.Phone()
	case adminuser.FieldFirstName:
		return m.FirstName()
	case adminuser.FieldLastName:
		return m.LastName()
	case adminuser.FieldCompany:
		return m.Company()
	case adminuser.FieldLocale:
		return m.Locale()
	case adminuser.FieldRoleID:
		return m.RoleID()
	case adminuser.FieldStatus:
		return m.Status()
	case adminuser.FieldPassword:
		return m.Password()
	case adminuser.FieldSecret:
		return m.Secret()
	case adminuser.FieldAPIKey:
		return m.APIKey()
	case adminuser.FieldWelcomeEmailSent:
		return m.WelcomeEmailSent()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AdminUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case adminuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case adminuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case adminuser.FieldEmail:
		return m.OldEmail(ctx)
	case adminuser.FieldPhone:
		return m.OldPhone(ctx)
	case adminuser.FieldFirstName:
		return m.OldFirstName(ctx)
	case adminuser.FieldLastName:
		return m.OldLastName(ctx)
	case adminuser.FieldCompany:
		return m.OldCompany(ctx)
	case adminuser.FieldLocale:
		return m.OldLocale(ctx)
	case adminuser.FieldRoleID:
		return m.OldRoleID(ctx)
	case adminuser.FieldStatus:
		return m.OldStatus(ctx)
	case adminuser.FieldPassword:
		return m.OldPassword(ctx)
	case adminuser.FieldSecret:
		return m.OldSecret(ctx)
	case adminuser.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case adminuser.FieldWelcomeEmailSent:
		return m.OldWelcomeEmailSent(ctx)
	}
	return nil, fmt.Errorf("unknown AdminUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case adminuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case adminuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case adminuser.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case adminuser.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case adminuser.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case adminuser.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case adminuser.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case adminuser.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case adminuser.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case adminuser.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case adminuser.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case adminuser.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case adminuser.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case adminuser.FieldWelcomeEmailSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWelcomeEmailSent(v)
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AdminUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AdminUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AdminUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AdminUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(adminuser.FieldCreatedAt) {
		fields = append(fields, adminuser.FieldCreatedAt)
	}
	if m.FieldCleared(adminuser.FieldUpdatedAt) {
		fields = append(fields, adminuser.FieldUpdatedAt)
	}
	if m.FieldCleared(adminuser.FieldPhone) {
		fields = append(fields, adminuser.FieldPhone)
	}
	if m.FieldCleared(adminuser.FieldFirstName) {
		fields = append(fields, adminuser.FieldFirstName)
	}
	if m.FieldCleared(adminuser.FieldLastName) {
		fields = append(fields, adminuser.FieldLastName)
	}
	if m.FieldCleared(adminuser.FieldCompany) {
		fields = append(fields, adminuser.FieldCompany)
	}
	if m.FieldCleared(adminuser.FieldLocale) {
		fields = append(fields, adminuser.FieldLocale)
	}
	if m.FieldCleared(adminuser.FieldRoleID) {
		fields = append(fields, adminuser.FieldRoleID)
	}
	if m.FieldCleared(adminuser.FieldStatus) {
		fields = append(fields, adminuser.FieldStatus)
	}
	if m.FieldCleared(adminuser.FieldPassword) {
		fields = append(fields, adminuser.FieldPassword)
	}
	if m.FieldCleared(adminuser.FieldSecret) {
		fields = append(fields, adminuser.FieldSecret)
	}
	if m.FieldCleared(adminuser.FieldAPIKey) {
		fields = append(fields, adminuser.FieldAPIKey)
	}
	if m.FieldCleared(adminuser.FieldWelcomeEmailSent) {
		fields = append(fields, adminuser.FieldWelcomeEmailSent)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AdminUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AdminUserMutation) ClearField(name string) error {
	switch name {
	case adminuser.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case adminuser.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case adminuser.FieldPhone:
		m.ClearPhone()
		return nil
	case adminuser.FieldFirstName:
		m.ClearFirstName()
		return nil
	case adminuser.FieldLastName:
		m.ClearLastName()
		return nil
	case adminuser.FieldCompany:
		m.ClearCompany()
		return nil
	case adminuser.FieldLocale:
		m.ClearLocale()
		return nil
	case adminuser.FieldRoleID:
		m.ClearRoleID()
		return nil
	case adminuser.FieldStatus:
		m.ClearStatus()
		return nil
	case adminuser.FieldPassword:
		m.ClearPassword()
		return nil
	case adminuser.FieldSecret:
		m.ClearSecret()
		return nil
	case adminuser.FieldAPIKey:
		m.ClearAPIKey()
		return nil
	case adminuser.FieldWelcomeEmailSent:
		m.ClearWelcomeEmailSent()
		return nil
	}
	return fmt.Errorf("unknown AdminUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AdminUserMutation) ResetField(name string) error {
	switch name {
	case adminuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case adminuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case adminuser.FieldEmail:
		m.ResetEmail()
		return nil
	case adminuser.FieldPhone:
		m.ResetPhone()
		return nil
	case adminuser.FieldFirstName:
		m.ResetFirstName()
		return nil
	case adminuser.FieldLastName:
		m.ResetLastName()
		return nil
	case adminuser.FieldCompany:
		m.ResetCompany()
		return nil
	case adminuser.FieldLocale:
		m.ResetLocale()
		return nil
	case adminuser.FieldRoleID:
		m.ResetRoleID()
		return nil
	case adminuser.FieldStatus:
		m.ResetStatus()
		return nil
	case adminuser.FieldPassword:
		m.ResetPassword()
		return nil
	case adminuser.FieldSecret:
		m.ResetSecret()
		return nil
	case adminuser.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case adminuser.FieldWelcomeEmailSent:
		m.ResetWelcomeEmailSent()
		return nil
	}
	return fmt.Errorf("unknown AdminUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AdminUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.apps != nil {
		edges = append(edges, adminuser.EdgeApps)
	}
	if m.app_users != nil {
		edges = append(edges, adminuser.EdgeAppUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AdminUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case adminuser.EdgeApps:
		ids := make([]ent.Value, 0, len(m.apps))
		for id := range m.apps {
			ids = append(ids, id)
		}
		return ids
	case adminuser.EdgeAppUsers:
		ids := make([]ent.Value, 0, len(m.app_users))
		for id := range m.app_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AdminUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedapps != nil {
		edges = append(edges, adminuser.EdgeApps)
	}
	if m.removedapp_users != nil {
		edges = append(edges, adminuser.EdgeAppUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AdminUserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case adminuser.EdgeApps:
		ids := make([]ent.Value, 0, len(m.removedapps))
		for id := range m.removedapps {
			ids = append(ids, id)
		}
		return ids
	case adminuser.EdgeAppUsers:
		ids := make([]ent.Value, 0, len(m.removedapp_users))
		for id := range m.removedapp_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AdminUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedapps {
		edges = append(edges, adminuser.EdgeApps)
	}
	if m.clearedapp_users {
		edges = append(edges, adminuser.EdgeAppUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AdminUserMutation) EdgeCleared(name string) bool {
	switch name {
	case adminuser.EdgeApps:
		return m.clearedapps
	case adminuser.EdgeAppUsers:
		return m.clearedapp_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AdminUserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown AdminUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AdminUserMutation) ResetEdge(name string) error {
	switch name {
	case adminuser.EdgeApps:
		m.ResetApps()
		return nil
	case adminuser.EdgeAppUsers:
		m.ResetAppUsers()
		return nil
	}
	return fmt.Errorf("unknown AdminUser edge %s", name)
}

// AppMutation represents an operation that mutates the App nodes in the graph.
type AppMutation struct {
	config
	op                              Op
	typ                             string
	id                              *string
	created_at                      *time.Time
	updated_at                      *time.Time
	name                            *string
	copyright                       *string
	email                           *string
	address                         *string
	social_tw                       *string
	social_fb                       *string
	social_in                       *string
	logo_url                        *string
	site_url                        *string
	auth_email_verify               *bool
	oauth_signin_can_signup         *bool
	auth_enable_password_login      *bool
	admin_user_id                   *string
	clearedFields                   map[string]struct{}
	default_mail_conn               *string
	cleareddefault_mail_conn        bool
	mail_layout_templ               *string
	clearedmail_layout_templ        bool
	wsapce_invite_templ             *string
	clearedwsapce_invite_templ      bool
	wsapce_success_templ            *string
	clearedwsapce_success_templ     bool
	auth_fp_templ                   *string
	clearedauth_fp_templ            bool
	auth_welcome_email_templ        *string
	clearedauth_welcome_email_templ bool
	auth_verification_templ         *string
	clearedauth_verification_templ  bool
	admin_user                      map[string]struct{}
	removedadmin_user               map[string]struct{}
	clearedadmin_user               bool
	app_users                       map[string]struct{}
	removedapp_users                map[string]struct{}
	clearedapp_users                bool
	done                            bool
	oldValue                        func(context.Context) (*App, error)
	predicates                      []predicate.App
}

var _ ent.Mutation = (*AppMutation)(nil)

// appOption allows management of the mutation configuration using functional options.
type appOption func(*AppMutation)

// newAppMutation creates new mutation for the App entity.
func newAppMutation(c config, op Op, opts ...appOption) *AppMutation {
	m := &AppMutation{
		config:        c,
		op:            op,
		typ:           TypeApp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppID sets the ID field of the mutation.
func withAppID(id string) appOption {
	return func(m *AppMutation) {
		var (
			err   error
			once  sync.Once
			value *App
		)
		m.oldValue = func(ctx context.Context) (*App, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().App.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withApp sets the old App of the mutation.
func withApp(node *App) appOption {
	return func(m *AppMutation) {
		m.oldValue = func(context.Context) (*App, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of App entities.
func (m *AppMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().App.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[app.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[app.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, app.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[app.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[app.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, app.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *AppMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppMutation) ClearName() {
	m.name = nil
	m.clearedFields[app.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppMutation) NameCleared() bool {
	_, ok := m.clearedFields[app.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, app.FieldName)
}

// SetCopyright sets the "copyright" field.
func (m *AppMutation) SetCopyright(s string) {
	m.copyright = &s
}

// Copyright returns the value of the "copyright" field in the mutation.
func (m *AppMutation) Copyright() (r string, exists bool) {
	v := m.copyright
	if v == nil {
		return
	}
	return *v, true
}

// OldCopyright returns the old "copyright" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldCopyright(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopyright is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopyright requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopyright: %w", err)
	}
	return oldValue.Copyright, nil
}

// ClearCopyright clears the value of the "copyright" field.
func (m *AppMutation) ClearCopyright() {
	m.copyright = nil
	m.clearedFields[app.FieldCopyright] = struct{}{}
}

// CopyrightCleared returns if the "copyright" field was cleared in this mutation.
func (m *AppMutation) CopyrightCleared() bool {
	_, ok := m.clearedFields[app.FieldCopyright]
	return ok
}

// ResetCopyright resets all changes to the "copyright" field.
func (m *AppMutation) ResetCopyright() {
	m.copyright = nil
	delete(m.clearedFields, app.FieldCopyright)
}

// SetEmail sets the "email" field.
func (m *AppMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *AppMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *AppMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[app.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *AppMutation) EmailCleared() bool {
	_, ok := m.clearedFields[app.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *AppMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, app.FieldEmail)
}

// SetAddress sets the "address" field.
func (m *AppMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *AppMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAddress(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *AppMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[app.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *AppMutation) AddressCleared() bool {
	_, ok := m.clearedFields[app.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *AppMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, app.FieldAddress)
}

// SetSocialTw sets the "social_tw" field.
func (m *AppMutation) SetSocialTw(s string) {
	m.social_tw = &s
}

// SocialTw returns the value of the "social_tw" field in the mutation.
func (m *AppMutation) SocialTw() (r string, exists bool) {
	v := m.social_tw
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialTw returns the old "social_tw" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSocialTw(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialTw is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialTw requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialTw: %w", err)
	}
	return oldValue.SocialTw, nil
}

// ClearSocialTw clears the value of the "social_tw" field.
func (m *AppMutation) ClearSocialTw() {
	m.social_tw = nil
	m.clearedFields[app.FieldSocialTw] = struct{}{}
}

// SocialTwCleared returns if the "social_tw" field was cleared in this mutation.
func (m *AppMutation) SocialTwCleared() bool {
	_, ok := m.clearedFields[app.FieldSocialTw]
	return ok
}

// ResetSocialTw resets all changes to the "social_tw" field.
func (m *AppMutation) ResetSocialTw() {
	m.social_tw = nil
	delete(m.clearedFields, app.FieldSocialTw)
}

// SetSocialFb sets the "social_fb" field.
func (m *AppMutation) SetSocialFb(s string) {
	m.social_fb = &s
}

// SocialFb returns the value of the "social_fb" field in the mutation.
func (m *AppMutation) SocialFb() (r string, exists bool) {
	v := m.social_fb
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialFb returns the old "social_fb" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSocialFb(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialFb is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialFb requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialFb: %w", err)
	}
	return oldValue.SocialFb, nil
}

// ClearSocialFb clears the value of the "social_fb" field.
func (m *AppMutation) ClearSocialFb() {
	m.social_fb = nil
	m.clearedFields[app.FieldSocialFb] = struct{}{}
}

// SocialFbCleared returns if the "social_fb" field was cleared in this mutation.
func (m *AppMutation) SocialFbCleared() bool {
	_, ok := m.clearedFields[app.FieldSocialFb]
	return ok
}

// ResetSocialFb resets all changes to the "social_fb" field.
func (m *AppMutation) ResetSocialFb() {
	m.social_fb = nil
	delete(m.clearedFields, app.FieldSocialFb)
}

// SetSocialIn sets the "social_in" field.
func (m *AppMutation) SetSocialIn(s string) {
	m.social_in = &s
}

// SocialIn returns the value of the "social_in" field in the mutation.
func (m *AppMutation) SocialIn() (r string, exists bool) {
	v := m.social_in
	if v == nil {
		return
	}
	return *v, true
}

// OldSocialIn returns the old "social_in" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSocialIn(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSocialIn is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSocialIn requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSocialIn: %w", err)
	}
	return oldValue.SocialIn, nil
}

// ClearSocialIn clears the value of the "social_in" field.
func (m *AppMutation) ClearSocialIn() {
	m.social_in = nil
	m.clearedFields[app.FieldSocialIn] = struct{}{}
}

// SocialInCleared returns if the "social_in" field was cleared in this mutation.
func (m *AppMutation) SocialInCleared() bool {
	_, ok := m.clearedFields[app.FieldSocialIn]
	return ok
}

// ResetSocialIn resets all changes to the "social_in" field.
func (m *AppMutation) ResetSocialIn() {
	m.social_in = nil
	delete(m.clearedFields, app.FieldSocialIn)
}

// SetLogoURL sets the "logo_url" field.
func (m *AppMutation) SetLogoURL(s string) {
	m.logo_url = &s
}

// LogoURL returns the value of the "logo_url" field in the mutation.
func (m *AppMutation) LogoURL() (r string, exists bool) {
	v := m.logo_url
	if v == nil {
		return
	}
	return *v, true
}

// OldLogoURL returns the old "logo_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldLogoURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLogoURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLogoURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLogoURL: %w", err)
	}
	return oldValue.LogoURL, nil
}

// ClearLogoURL clears the value of the "logo_url" field.
func (m *AppMutation) ClearLogoURL() {
	m.logo_url = nil
	m.clearedFields[app.FieldLogoURL] = struct{}{}
}

// LogoURLCleared returns if the "logo_url" field was cleared in this mutation.
func (m *AppMutation) LogoURLCleared() bool {
	_, ok := m.clearedFields[app.FieldLogoURL]
	return ok
}

// ResetLogoURL resets all changes to the "logo_url" field.
func (m *AppMutation) ResetLogoURL() {
	m.logo_url = nil
	delete(m.clearedFields, app.FieldLogoURL)
}

// SetSiteURL sets the "site_url" field.
func (m *AppMutation) SetSiteURL(s string) {
	m.site_url = &s
}

// SiteURL returns the value of the "site_url" field in the mutation.
func (m *AppMutation) SiteURL() (r string, exists bool) {
	v := m.site_url
	if v == nil {
		return
	}
	return *v, true
}

// OldSiteURL returns the old "site_url" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldSiteURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSiteURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSiteURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSiteURL: %w", err)
	}
	return oldValue.SiteURL, nil
}

// ClearSiteURL clears the value of the "site_url" field.
func (m *AppMutation) ClearSiteURL() {
	m.site_url = nil
	m.clearedFields[app.FieldSiteURL] = struct{}{}
}

// SiteURLCleared returns if the "site_url" field was cleared in this mutation.
func (m *AppMutation) SiteURLCleared() bool {
	_, ok := m.clearedFields[app.FieldSiteURL]
	return ok
}

// ResetSiteURL resets all changes to the "site_url" field.
func (m *AppMutation) ResetSiteURL() {
	m.site_url = nil
	delete(m.clearedFields, app.FieldSiteURL)
}

// SetDefaultMailConnID sets the "default_mail_conn_id" field.
func (m *AppMutation) SetDefaultMailConnID(s string) {
	m.default_mail_conn = &s
}

// DefaultMailConnID returns the value of the "default_mail_conn_id" field in the mutation.
func (m *AppMutation) DefaultMailConnID() (r string, exists bool) {
	v := m.default_mail_conn
	if v == nil {
		return
	}
	return *v, true
}

// OldDefaultMailConnID returns the old "default_mail_conn_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldDefaultMailConnID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDefaultMailConnID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDefaultMailConnID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDefaultMailConnID: %w", err)
	}
	return oldValue.DefaultMailConnID, nil
}

// ClearDefaultMailConnID clears the value of the "default_mail_conn_id" field.
func (m *AppMutation) ClearDefaultMailConnID() {
	m.default_mail_conn = nil
	m.clearedFields[app.FieldDefaultMailConnID] = struct{}{}
}

// DefaultMailConnIDCleared returns if the "default_mail_conn_id" field was cleared in this mutation.
func (m *AppMutation) DefaultMailConnIDCleared() bool {
	_, ok := m.clearedFields[app.FieldDefaultMailConnID]
	return ok
}

// ResetDefaultMailConnID resets all changes to the "default_mail_conn_id" field.
func (m *AppMutation) ResetDefaultMailConnID() {
	m.default_mail_conn = nil
	delete(m.clearedFields, app.FieldDefaultMailConnID)
}

// SetMailLayoutTemplID sets the "mail_layout_templ_id" field.
func (m *AppMutation) SetMailLayoutTemplID(s string) {
	m.mail_layout_templ = &s
}

// MailLayoutTemplID returns the value of the "mail_layout_templ_id" field in the mutation.
func (m *AppMutation) MailLayoutTemplID() (r string, exists bool) {
	v := m.mail_layout_templ
	if v == nil {
		return
	}
	return *v, true
}

// OldMailLayoutTemplID returns the old "mail_layout_templ_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldMailLayoutTemplID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailLayoutTemplID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailLayoutTemplID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailLayoutTemplID: %w", err)
	}
	return oldValue.MailLayoutTemplID, nil
}

// ClearMailLayoutTemplID clears the value of the "mail_layout_templ_id" field.
func (m *AppMutation) ClearMailLayoutTemplID() {
	m.mail_layout_templ = nil
	m.clearedFields[app.FieldMailLayoutTemplID] = struct{}{}
}

// MailLayoutTemplIDCleared returns if the "mail_layout_templ_id" field was cleared in this mutation.
func (m *AppMutation) MailLayoutTemplIDCleared() bool {
	_, ok := m.clearedFields[app.FieldMailLayoutTemplID]
	return ok
}

// ResetMailLayoutTemplID resets all changes to the "mail_layout_templ_id" field.
func (m *AppMutation) ResetMailLayoutTemplID() {
	m.mail_layout_templ = nil
	delete(m.clearedFields, app.FieldMailLayoutTemplID)
}

// SetWsapceInviteTemplID sets the "wsapce_invite_templ_id" field.
func (m *AppMutation) SetWsapceInviteTemplID(s string) {
	m.wsapce_invite_templ = &s
}

// WsapceInviteTemplID returns the value of the "wsapce_invite_templ_id" field in the mutation.
func (m *AppMutation) WsapceInviteTemplID() (r string, exists bool) {
	v := m.wsapce_invite_templ
	if v == nil {
		return
	}
	return *v, true
}

// OldWsapceInviteTemplID returns the old "wsapce_invite_templ_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldWsapceInviteTemplID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWsapceInviteTemplID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWsapceInviteTemplID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWsapceInviteTemplID: %w", err)
	}
	return oldValue.WsapceInviteTemplID, nil
}

// ClearWsapceInviteTemplID clears the value of the "wsapce_invite_templ_id" field.
func (m *AppMutation) ClearWsapceInviteTemplID() {
	m.wsapce_invite_templ = nil
	m.clearedFields[app.FieldWsapceInviteTemplID] = struct{}{}
}

// WsapceInviteTemplIDCleared returns if the "wsapce_invite_templ_id" field was cleared in this mutation.
func (m *AppMutation) WsapceInviteTemplIDCleared() bool {
	_, ok := m.clearedFields[app.FieldWsapceInviteTemplID]
	return ok
}

// ResetWsapceInviteTemplID resets all changes to the "wsapce_invite_templ_id" field.
func (m *AppMutation) ResetWsapceInviteTemplID() {
	m.wsapce_invite_templ = nil
	delete(m.clearedFields, app.FieldWsapceInviteTemplID)
}

// SetWsapceSuccessTemplID sets the "wsapce_success_templ_id" field.
func (m *AppMutation) SetWsapceSuccessTemplID(s string) {
	m.wsapce_success_templ = &s
}

// WsapceSuccessTemplID returns the value of the "wsapce_success_templ_id" field in the mutation.
func (m *AppMutation) WsapceSuccessTemplID() (r string, exists bool) {
	v := m.wsapce_success_templ
	if v == nil {
		return
	}
	return *v, true
}

// OldWsapceSuccessTemplID returns the old "wsapce_success_templ_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldWsapceSuccessTemplID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWsapceSuccessTemplID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWsapceSuccessTemplID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWsapceSuccessTemplID: %w", err)
	}
	return oldValue.WsapceSuccessTemplID, nil
}

// ClearWsapceSuccessTemplID clears the value of the "wsapce_success_templ_id" field.
func (m *AppMutation) ClearWsapceSuccessTemplID() {
	m.wsapce_success_templ = nil
	m.clearedFields[app.FieldWsapceSuccessTemplID] = struct{}{}
}

// WsapceSuccessTemplIDCleared returns if the "wsapce_success_templ_id" field was cleared in this mutation.
func (m *AppMutation) WsapceSuccessTemplIDCleared() bool {
	_, ok := m.clearedFields[app.FieldWsapceSuccessTemplID]
	return ok
}

// ResetWsapceSuccessTemplID resets all changes to the "wsapce_success_templ_id" field.
func (m *AppMutation) ResetWsapceSuccessTemplID() {
	m.wsapce_success_templ = nil
	delete(m.clearedFields, app.FieldWsapceSuccessTemplID)
}

// SetAuthFpTemplID sets the "auth_fp_templ_id" field.
func (m *AppMutation) SetAuthFpTemplID(s string) {
	m.auth_fp_templ = &s
}

// AuthFpTemplID returns the value of the "auth_fp_templ_id" field in the mutation.
func (m *AppMutation) AuthFpTemplID() (r string, exists bool) {
	v := m.auth_fp_templ
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthFpTemplID returns the old "auth_fp_templ_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAuthFpTemplID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthFpTemplID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthFpTemplID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthFpTemplID: %w", err)
	}
	return oldValue.AuthFpTemplID, nil
}

// ClearAuthFpTemplID clears the value of the "auth_fp_templ_id" field.
func (m *AppMutation) ClearAuthFpTemplID() {
	m.auth_fp_templ = nil
	m.clearedFields[app.FieldAuthFpTemplID] = struct{}{}
}

// AuthFpTemplIDCleared returns if the "auth_fp_templ_id" field was cleared in this mutation.
func (m *AppMutation) AuthFpTemplIDCleared() bool {
	_, ok := m.clearedFields[app.FieldAuthFpTemplID]
	return ok
}

// ResetAuthFpTemplID resets all changes to the "auth_fp_templ_id" field.
func (m *AppMutation) ResetAuthFpTemplID() {
	m.auth_fp_templ = nil
	delete(m.clearedFields, app.FieldAuthFpTemplID)
}

// SetAuthWelcomeEmailTemplID sets the "auth_welcome_email_templ_id" field.
func (m *AppMutation) SetAuthWelcomeEmailTemplID(s string) {
	m.auth_welcome_email_templ = &s
}

// AuthWelcomeEmailTemplID returns the value of the "auth_welcome_email_templ_id" field in the mutation.
func (m *AppMutation) AuthWelcomeEmailTemplID() (r string, exists bool) {
	v := m.auth_welcome_email_templ
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthWelcomeEmailTemplID returns the old "auth_welcome_email_templ_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAuthWelcomeEmailTemplID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthWelcomeEmailTemplID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthWelcomeEmailTemplID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthWelcomeEmailTemplID: %w", err)
	}
	return oldValue.AuthWelcomeEmailTemplID, nil
}

// ClearAuthWelcomeEmailTemplID clears the value of the "auth_welcome_email_templ_id" field.
func (m *AppMutation) ClearAuthWelcomeEmailTemplID() {
	m.auth_welcome_email_templ = nil
	m.clearedFields[app.FieldAuthWelcomeEmailTemplID] = struct{}{}
}

// AuthWelcomeEmailTemplIDCleared returns if the "auth_welcome_email_templ_id" field was cleared in this mutation.
func (m *AppMutation) AuthWelcomeEmailTemplIDCleared() bool {
	_, ok := m.clearedFields[app.FieldAuthWelcomeEmailTemplID]
	return ok
}

// ResetAuthWelcomeEmailTemplID resets all changes to the "auth_welcome_email_templ_id" field.
func (m *AppMutation) ResetAuthWelcomeEmailTemplID() {
	m.auth_welcome_email_templ = nil
	delete(m.clearedFields, app.FieldAuthWelcomeEmailTemplID)
}

// SetAuthVerificationTemplID sets the "auth_verification_templ_id" field.
func (m *AppMutation) SetAuthVerificationTemplID(s string) {
	m.auth_verification_templ = &s
}

// AuthVerificationTemplID returns the value of the "auth_verification_templ_id" field in the mutation.
func (m *AppMutation) AuthVerificationTemplID() (r string, exists bool) {
	v := m.auth_verification_templ
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthVerificationTemplID returns the old "auth_verification_templ_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAuthVerificationTemplID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthVerificationTemplID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthVerificationTemplID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthVerificationTemplID: %w", err)
	}
	return oldValue.AuthVerificationTemplID, nil
}

// ClearAuthVerificationTemplID clears the value of the "auth_verification_templ_id" field.
func (m *AppMutation) ClearAuthVerificationTemplID() {
	m.auth_verification_templ = nil
	m.clearedFields[app.FieldAuthVerificationTemplID] = struct{}{}
}

// AuthVerificationTemplIDCleared returns if the "auth_verification_templ_id" field was cleared in this mutation.
func (m *AppMutation) AuthVerificationTemplIDCleared() bool {
	_, ok := m.clearedFields[app.FieldAuthVerificationTemplID]
	return ok
}

// ResetAuthVerificationTemplID resets all changes to the "auth_verification_templ_id" field.
func (m *AppMutation) ResetAuthVerificationTemplID() {
	m.auth_verification_templ = nil
	delete(m.clearedFields, app.FieldAuthVerificationTemplID)
}

// SetAuthEmailVerify sets the "auth_email_verify" field.
func (m *AppMutation) SetAuthEmailVerify(b bool) {
	m.auth_email_verify = &b
}

// AuthEmailVerify returns the value of the "auth_email_verify" field in the mutation.
func (m *AppMutation) AuthEmailVerify() (r bool, exists bool) {
	v := m.auth_email_verify
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthEmailVerify returns the old "auth_email_verify" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAuthEmailVerify(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthEmailVerify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthEmailVerify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthEmailVerify: %w", err)
	}
	return oldValue.AuthEmailVerify, nil
}

// ClearAuthEmailVerify clears the value of the "auth_email_verify" field.
func (m *AppMutation) ClearAuthEmailVerify() {
	m.auth_email_verify = nil
	m.clearedFields[app.FieldAuthEmailVerify] = struct{}{}
}

// AuthEmailVerifyCleared returns if the "auth_email_verify" field was cleared in this mutation.
func (m *AppMutation) AuthEmailVerifyCleared() bool {
	_, ok := m.clearedFields[app.FieldAuthEmailVerify]
	return ok
}

// ResetAuthEmailVerify resets all changes to the "auth_email_verify" field.
func (m *AppMutation) ResetAuthEmailVerify() {
	m.auth_email_verify = nil
	delete(m.clearedFields, app.FieldAuthEmailVerify)
}

// SetOauthSigninCanSignup sets the "oauth_signin_can_signup" field.
func (m *AppMutation) SetOauthSigninCanSignup(b bool) {
	m.oauth_signin_can_signup = &b
}

// OauthSigninCanSignup returns the value of the "oauth_signin_can_signup" field in the mutation.
func (m *AppMutation) OauthSigninCanSignup() (r bool, exists bool) {
	v := m.oauth_signin_can_signup
	if v == nil {
		return
	}
	return *v, true
}

// OldOauthSigninCanSignup returns the old "oauth_signin_can_signup" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldOauthSigninCanSignup(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOauthSigninCanSignup is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOauthSigninCanSignup requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOauthSigninCanSignup: %w", err)
	}
	return oldValue.OauthSigninCanSignup, nil
}

// ClearOauthSigninCanSignup clears the value of the "oauth_signin_can_signup" field.
func (m *AppMutation) ClearOauthSigninCanSignup() {
	m.oauth_signin_can_signup = nil
	m.clearedFields[app.FieldOauthSigninCanSignup] = struct{}{}
}

// OauthSigninCanSignupCleared returns if the "oauth_signin_can_signup" field was cleared in this mutation.
func (m *AppMutation) OauthSigninCanSignupCleared() bool {
	_, ok := m.clearedFields[app.FieldOauthSigninCanSignup]
	return ok
}

// ResetOauthSigninCanSignup resets all changes to the "oauth_signin_can_signup" field.
func (m *AppMutation) ResetOauthSigninCanSignup() {
	m.oauth_signin_can_signup = nil
	delete(m.clearedFields, app.FieldOauthSigninCanSignup)
}

// SetAuthEnablePasswordLogin sets the "auth_enable_password_login" field.
func (m *AppMutation) SetAuthEnablePasswordLogin(b bool) {
	m.auth_enable_password_login = &b
}

// AuthEnablePasswordLogin returns the value of the "auth_enable_password_login" field in the mutation.
func (m *AppMutation) AuthEnablePasswordLogin() (r bool, exists bool) {
	v := m.auth_enable_password_login
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthEnablePasswordLogin returns the old "auth_enable_password_login" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAuthEnablePasswordLogin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAuthEnablePasswordLogin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAuthEnablePasswordLogin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthEnablePasswordLogin: %w", err)
	}
	return oldValue.AuthEnablePasswordLogin, nil
}

// ClearAuthEnablePasswordLogin clears the value of the "auth_enable_password_login" field.
func (m *AppMutation) ClearAuthEnablePasswordLogin() {
	m.auth_enable_password_login = nil
	m.clearedFields[app.FieldAuthEnablePasswordLogin] = struct{}{}
}

// AuthEnablePasswordLoginCleared returns if the "auth_enable_password_login" field was cleared in this mutation.
func (m *AppMutation) AuthEnablePasswordLoginCleared() bool {
	_, ok := m.clearedFields[app.FieldAuthEnablePasswordLogin]
	return ok
}

// ResetAuthEnablePasswordLogin resets all changes to the "auth_enable_password_login" field.
func (m *AppMutation) ResetAuthEnablePasswordLogin() {
	m.auth_enable_password_login = nil
	delete(m.clearedFields, app.FieldAuthEnablePasswordLogin)
}

// SetAdminUserID sets the "admin_user_id" field.
func (m *AppMutation) SetAdminUserID(s string) {
	m.admin_user_id = &s
}

// AdminUserID returns the value of the "admin_user_id" field in the mutation.
func (m *AppMutation) AdminUserID() (r string, exists bool) {
	v := m.admin_user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminUserID returns the old "admin_user_id" field's value of the App entity.
// If the App object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppMutation) OldAdminUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminUserID: %w", err)
	}
	return oldValue.AdminUserID, nil
}

// ClearAdminUserID clears the value of the "admin_user_id" field.
func (m *AppMutation) ClearAdminUserID() {
	m.admin_user_id = nil
	m.clearedFields[app.FieldAdminUserID] = struct{}{}
}

// AdminUserIDCleared returns if the "admin_user_id" field was cleared in this mutation.
func (m *AppMutation) AdminUserIDCleared() bool {
	_, ok := m.clearedFields[app.FieldAdminUserID]
	return ok
}

// ResetAdminUserID resets all changes to the "admin_user_id" field.
func (m *AppMutation) ResetAdminUserID() {
	m.admin_user_id = nil
	delete(m.clearedFields, app.FieldAdminUserID)
}

// ClearDefaultMailConn clears the "default_mail_conn" edge to the MailConn entity.
func (m *AppMutation) ClearDefaultMailConn() {
	m.cleareddefault_mail_conn = true
	m.clearedFields[app.FieldDefaultMailConnID] = struct{}{}
}

// DefaultMailConnCleared reports if the "default_mail_conn" edge to the MailConn entity was cleared.
func (m *AppMutation) DefaultMailConnCleared() bool {
	return m.DefaultMailConnIDCleared() || m.cleareddefault_mail_conn
}

// DefaultMailConnIDs returns the "default_mail_conn" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DefaultMailConnID instead. It exists only for internal usage by the builders.
func (m *AppMutation) DefaultMailConnIDs() (ids []string) {
	if id := m.default_mail_conn; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDefaultMailConn resets all changes to the "default_mail_conn" edge.
func (m *AppMutation) ResetDefaultMailConn() {
	m.default_mail_conn = nil
	m.cleareddefault_mail_conn = false
}

// ClearMailLayoutTempl clears the "mail_layout_templ" edge to the Templ entity.
func (m *AppMutation) ClearMailLayoutTempl() {
	m.clearedmail_layout_templ = true
	m.clearedFields[app.FieldMailLayoutTemplID] = struct{}{}
}

// MailLayoutTemplCleared reports if the "mail_layout_templ" edge to the Templ entity was cleared.
func (m *AppMutation) MailLayoutTemplCleared() bool {
	return m.MailLayoutTemplIDCleared() || m.clearedmail_layout_templ
}

// MailLayoutTemplIDs returns the "mail_layout_templ" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// MailLayoutTemplID instead. It exists only for internal usage by the builders.
func (m *AppMutation) MailLayoutTemplIDs() (ids []string) {
	if id := m.mail_layout_templ; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetMailLayoutTempl resets all changes to the "mail_layout_templ" edge.
func (m *AppMutation) ResetMailLayoutTempl() {
	m.mail_layout_templ = nil
	m.clearedmail_layout_templ = false
}

// ClearWsapceInviteTempl clears the "wsapce_invite_templ" edge to the Templ entity.
func (m *AppMutation) ClearWsapceInviteTempl() {
	m.clearedwsapce_invite_templ = true
	m.clearedFields[app.FieldWsapceInviteTemplID] = struct{}{}
}

// WsapceInviteTemplCleared reports if the "wsapce_invite_templ" edge to the Templ entity was cleared.
func (m *AppMutation) WsapceInviteTemplCleared() bool {
	return m.WsapceInviteTemplIDCleared() || m.clearedwsapce_invite_templ
}

// WsapceInviteTemplIDs returns the "wsapce_invite_templ" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WsapceInviteTemplID instead. It exists only for internal usage by the builders.
func (m *AppMutation) WsapceInviteTemplIDs() (ids []string) {
	if id := m.wsapce_invite_templ; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWsapceInviteTempl resets all changes to the "wsapce_invite_templ" edge.
func (m *AppMutation) ResetWsapceInviteTempl() {
	m.wsapce_invite_templ = nil
	m.clearedwsapce_invite_templ = false
}

// ClearWsapceSuccessTempl clears the "wsapce_success_templ" edge to the Templ entity.
func (m *AppMutation) ClearWsapceSuccessTempl() {
	m.clearedwsapce_success_templ = true
	m.clearedFields[app.FieldWsapceSuccessTemplID] = struct{}{}
}

// WsapceSuccessTemplCleared reports if the "wsapce_success_templ" edge to the Templ entity was cleared.
func (m *AppMutation) WsapceSuccessTemplCleared() bool {
	return m.WsapceSuccessTemplIDCleared() || m.clearedwsapce_success_templ
}

// WsapceSuccessTemplIDs returns the "wsapce_success_templ" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WsapceSuccessTemplID instead. It exists only for internal usage by the builders.
func (m *AppMutation) WsapceSuccessTemplIDs() (ids []string) {
	if id := m.wsapce_success_templ; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWsapceSuccessTempl resets all changes to the "wsapce_success_templ" edge.
func (m *AppMutation) ResetWsapceSuccessTempl() {
	m.wsapce_success_templ = nil
	m.clearedwsapce_success_templ = false
}

// ClearAuthFpTempl clears the "auth_fp_templ" edge to the Templ entity.
func (m *AppMutation) ClearAuthFpTempl() {
	m.clearedauth_fp_templ = true
	m.clearedFields[app.FieldAuthFpTemplID] = struct{}{}
}

// AuthFpTemplCleared reports if the "auth_fp_templ" edge to the Templ entity was cleared.
func (m *AppMutation) AuthFpTemplCleared() bool {
	return m.AuthFpTemplIDCleared() || m.clearedauth_fp_templ
}

// AuthFpTemplIDs returns the "auth_fp_templ" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthFpTemplID instead. It exists only for internal usage by the builders.
func (m *AppMutation) AuthFpTemplIDs() (ids []string) {
	if id := m.auth_fp_templ; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthFpTempl resets all changes to the "auth_fp_templ" edge.
func (m *AppMutation) ResetAuthFpTempl() {
	m.auth_fp_templ = nil
	m.clearedauth_fp_templ = false
}

// ClearAuthWelcomeEmailTempl clears the "auth_welcome_email_templ" edge to the Templ entity.
func (m *AppMutation) ClearAuthWelcomeEmailTempl() {
	m.clearedauth_welcome_email_templ = true
	m.clearedFields[app.FieldAuthWelcomeEmailTemplID] = struct{}{}
}

// AuthWelcomeEmailTemplCleared reports if the "auth_welcome_email_templ" edge to the Templ entity was cleared.
func (m *AppMutation) AuthWelcomeEmailTemplCleared() bool {
	return m.AuthWelcomeEmailTemplIDCleared() || m.clearedauth_welcome_email_templ
}

// AuthWelcomeEmailTemplIDs returns the "auth_welcome_email_templ" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthWelcomeEmailTemplID instead. It exists only for internal usage by the builders.
func (m *AppMutation) AuthWelcomeEmailTemplIDs() (ids []string) {
	if id := m.auth_welcome_email_templ; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthWelcomeEmailTempl resets all changes to the "auth_welcome_email_templ" edge.
func (m *AppMutation) ResetAuthWelcomeEmailTempl() {
	m.auth_welcome_email_templ = nil
	m.clearedauth_welcome_email_templ = false
}

// ClearAuthVerificationTempl clears the "auth_verification_templ" edge to the Templ entity.
func (m *AppMutation) ClearAuthVerificationTempl() {
	m.clearedauth_verification_templ = true
	m.clearedFields[app.FieldAuthVerificationTemplID] = struct{}{}
}

// AuthVerificationTemplCleared reports if the "auth_verification_templ" edge to the Templ entity was cleared.
func (m *AppMutation) AuthVerificationTemplCleared() bool {
	return m.AuthVerificationTemplIDCleared() || m.clearedauth_verification_templ
}

// AuthVerificationTemplIDs returns the "auth_verification_templ" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AuthVerificationTemplID instead. It exists only for internal usage by the builders.
func (m *AppMutation) AuthVerificationTemplIDs() (ids []string) {
	if id := m.auth_verification_templ; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAuthVerificationTempl resets all changes to the "auth_verification_templ" edge.
func (m *AppMutation) ResetAuthVerificationTempl() {
	m.auth_verification_templ = nil
	m.clearedauth_verification_templ = false
}

// AddAdminUserIDs adds the "admin_user" edge to the AdminUser entity by ids.
func (m *AppMutation) AddAdminUserIDs(ids ...string) {
	if m.admin_user == nil {
		m.admin_user = make(map[string]struct{})
	}
	for i := range ids {
		m.admin_user[ids[i]] = struct{}{}
	}
}

// ClearAdminUser clears the "admin_user" edge to the AdminUser entity.
func (m *AppMutation) ClearAdminUser() {
	m.clearedadmin_user = true
}

// AdminUserCleared reports if the "admin_user" edge to the AdminUser entity was cleared.
func (m *AppMutation) AdminUserCleared() bool {
	return m.clearedadmin_user
}

// RemoveAdminUserIDs removes the "admin_user" edge to the AdminUser entity by IDs.
func (m *AppMutation) RemoveAdminUserIDs(ids ...string) {
	if m.removedadmin_user == nil {
		m.removedadmin_user = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.admin_user, ids[i])
		m.removedadmin_user[ids[i]] = struct{}{}
	}
}

// RemovedAdminUser returns the removed IDs of the "admin_user" edge to the AdminUser entity.
func (m *AppMutation) RemovedAdminUserIDs() (ids []string) {
	for id := range m.removedadmin_user {
		ids = append(ids, id)
	}
	return
}

// AdminUserIDs returns the "admin_user" edge IDs in the mutation.
func (m *AppMutation) AdminUserIDs() (ids []string) {
	for id := range m.admin_user {
		ids = append(ids, id)
	}
	return
}

// ResetAdminUser resets all changes to the "admin_user" edge.
func (m *AppMutation) ResetAdminUser() {
	m.admin_user = nil
	m.clearedadmin_user = false
	m.removedadmin_user = nil
}

// AddAppUserIDs adds the "app_users" edge to the AppUser entity by ids.
func (m *AppMutation) AddAppUserIDs(ids ...string) {
	if m.app_users == nil {
		m.app_users = make(map[string]struct{})
	}
	for i := range ids {
		m.app_users[ids[i]] = struct{}{}
	}
}

// ClearAppUsers clears the "app_users" edge to the AppUser entity.
func (m *AppMutation) ClearAppUsers() {
	m.clearedapp_users = true
}

// AppUsersCleared reports if the "app_users" edge to the AppUser entity was cleared.
func (m *AppMutation) AppUsersCleared() bool {
	return m.clearedapp_users
}

// RemoveAppUserIDs removes the "app_users" edge to the AppUser entity by IDs.
func (m *AppMutation) RemoveAppUserIDs(ids ...string) {
	if m.removedapp_users == nil {
		m.removedapp_users = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.app_users, ids[i])
		m.removedapp_users[ids[i]] = struct{}{}
	}
}

// RemovedAppUsers returns the removed IDs of the "app_users" edge to the AppUser entity.
func (m *AppMutation) RemovedAppUsersIDs() (ids []string) {
	for id := range m.removedapp_users {
		ids = append(ids, id)
	}
	return
}

// AppUsersIDs returns the "app_users" edge IDs in the mutation.
func (m *AppMutation) AppUsersIDs() (ids []string) {
	for id := range m.app_users {
		ids = append(ids, id)
	}
	return
}

// ResetAppUsers resets all changes to the "app_users" edge.
func (m *AppMutation) ResetAppUsers() {
	m.app_users = nil
	m.clearedapp_users = false
	m.removedapp_users = nil
}

// Where appends a list predicates to the AppMutation builder.
func (m *AppMutation) Where(ps ...predicate.App) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.App, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (App).
func (m *AppMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.created_at != nil {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, app.FieldName)
	}
	if m.copyright != nil {
		fields = append(fields, app.FieldCopyright)
	}
	if m.email != nil {
		fields = append(fields, app.FieldEmail)
	}
	if m.address != nil {
		fields = append(fields, app.FieldAddress)
	}
	if m.social_tw != nil {
		fields = append(fields, app.FieldSocialTw)
	}
	if m.social_fb != nil {
		fields = append(fields, app.FieldSocialFb)
	}
	if m.social_in != nil {
		fields = append(fields, app.FieldSocialIn)
	}
	if m.logo_url != nil {
		fields = append(fields, app.FieldLogoURL)
	}
	if m.site_url != nil {
		fields = append(fields, app.FieldSiteURL)
	}
	if m.default_mail_conn != nil {
		fields = append(fields, app.FieldDefaultMailConnID)
	}
	if m.mail_layout_templ != nil {
		fields = append(fields, app.FieldMailLayoutTemplID)
	}
	if m.wsapce_invite_templ != nil {
		fields = append(fields, app.FieldWsapceInviteTemplID)
	}
	if m.wsapce_success_templ != nil {
		fields = append(fields, app.FieldWsapceSuccessTemplID)
	}
	if m.auth_fp_templ != nil {
		fields = append(fields, app.FieldAuthFpTemplID)
	}
	if m.auth_welcome_email_templ != nil {
		fields = append(fields, app.FieldAuthWelcomeEmailTemplID)
	}
	if m.auth_verification_templ != nil {
		fields = append(fields, app.FieldAuthVerificationTemplID)
	}
	if m.auth_email_verify != nil {
		fields = append(fields, app.FieldAuthEmailVerify)
	}
	if m.oauth_signin_can_signup != nil {
		fields = append(fields, app.FieldOauthSigninCanSignup)
	}
	if m.auth_enable_password_login != nil {
		fields = append(fields, app.FieldAuthEnablePasswordLogin)
	}
	if m.admin_user_id != nil {
		fields = append(fields, app.FieldAdminUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case app.FieldCreatedAt:
		return m.CreatedAt()
	case app.FieldUpdatedAt:
		return m.UpdatedAt()
	case app.FieldName:
		return m.Name()
	case app.FieldCopyright:
		return m.Copyright()
	case app.FieldEmail:
		return m.Email()
	case app.FieldAddress:
		return m.Address()
	case app.FieldSocialTw:
		return m.SocialTw()
	case app.FieldSocialFb:
		return m.SocialFb()
	case app.FieldSocialIn:
		return m.SocialIn()
	case app.FieldLogoURL:
		return m.LogoURL()
	case app.FieldSiteURL:
		return m.SiteURL()
	case app.FieldDefaultMailConnID:
		return m.DefaultMailConnID()
	case app.FieldMailLayoutTemplID:
		return m.MailLayoutTemplID()
	case app.FieldWsapceInviteTemplID:
		return m.WsapceInviteTemplID()
	case app.FieldWsapceSuccessTemplID:
		return m.WsapceSuccessTemplID()
	case app.FieldAuthFpTemplID:
		return m.AuthFpTemplID()
	case app.FieldAuthWelcomeEmailTemplID:
		return m.AuthWelcomeEmailTemplID()
	case app.FieldAuthVerificationTemplID:
		return m.AuthVerificationTemplID()
	case app.FieldAuthEmailVerify:
		return m.AuthEmailVerify()
	case app.FieldOauthSigninCanSignup:
		return m.OauthSigninCanSignup()
	case app.FieldAuthEnablePasswordLogin:
		return m.AuthEnablePasswordLogin()
	case app.FieldAdminUserID:
		return m.AdminUserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case app.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case app.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case app.FieldName:
		return m.OldName(ctx)
	case app.FieldCopyright:
		return m.OldCopyright(ctx)
	case app.FieldEmail:
		return m.OldEmail(ctx)
	case app.FieldAddress:
		return m.OldAddress(ctx)
	case app.FieldSocialTw:
		return m.OldSocialTw(ctx)
	case app.FieldSocialFb:
		return m.OldSocialFb(ctx)
	case app.FieldSocialIn:
		return m.OldSocialIn(ctx)
	case app.FieldLogoURL:
		return m.OldLogoURL(ctx)
	case app.FieldSiteURL:
		return m.OldSiteURL(ctx)
	case app.FieldDefaultMailConnID:
		return m.OldDefaultMailConnID(ctx)
	case app.FieldMailLayoutTemplID:
		return m.OldMailLayoutTemplID(ctx)
	case app.FieldWsapceInviteTemplID:
		return m.OldWsapceInviteTemplID(ctx)
	case app.FieldWsapceSuccessTemplID:
		return m.OldWsapceSuccessTemplID(ctx)
	case app.FieldAuthFpTemplID:
		return m.OldAuthFpTemplID(ctx)
	case app.FieldAuthWelcomeEmailTemplID:
		return m.OldAuthWelcomeEmailTemplID(ctx)
	case app.FieldAuthVerificationTemplID:
		return m.OldAuthVerificationTemplID(ctx)
	case app.FieldAuthEmailVerify:
		return m.OldAuthEmailVerify(ctx)
	case app.FieldOauthSigninCanSignup:
		return m.OldOauthSigninCanSignup(ctx)
	case app.FieldAuthEnablePasswordLogin:
		return m.OldAuthEnablePasswordLogin(ctx)
	case app.FieldAdminUserID:
		return m.OldAdminUserID(ctx)
	}
	return nil, fmt.Errorf("unknown App field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) SetField(name string, value ent.Value) error {
	switch name {
	case app.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case app.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case app.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case app.FieldCopyright:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopyright(v)
		return nil
	case app.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case app.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case app.FieldSocialTw:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialTw(v)
		return nil
	case app.FieldSocialFb:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialFb(v)
		return nil
	case app.FieldSocialIn:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSocialIn(v)
		return nil
	case app.FieldLogoURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLogoURL(v)
		return nil
	case app.FieldSiteURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSiteURL(v)
		return nil
	case app.FieldDefaultMailConnID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDefaultMailConnID(v)
		return nil
	case app.FieldMailLayoutTemplID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailLayoutTemplID(v)
		return nil
	case app.FieldWsapceInviteTemplID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWsapceInviteTemplID(v)
		return nil
	case app.FieldWsapceSuccessTemplID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWsapceSuccessTemplID(v)
		return nil
	case app.FieldAuthFpTemplID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthFpTemplID(v)
		return nil
	case app.FieldAuthWelcomeEmailTemplID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthWelcomeEmailTemplID(v)
		return nil
	case app.FieldAuthVerificationTemplID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthVerificationTemplID(v)
		return nil
	case app.FieldAuthEmailVerify:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthEmailVerify(v)
		return nil
	case app.FieldOauthSigninCanSignup:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOauthSigninCanSignup(v)
		return nil
	case app.FieldAuthEnablePasswordLogin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthEnablePasswordLogin(v)
		return nil
	case app.FieldAdminUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminUserID(v)
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown App numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(app.FieldCreatedAt) {
		fields = append(fields, app.FieldCreatedAt)
	}
	if m.FieldCleared(app.FieldUpdatedAt) {
		fields = append(fields, app.FieldUpdatedAt)
	}
	if m.FieldCleared(app.FieldName) {
		fields = append(fields, app.FieldName)
	}
	if m.FieldCleared(app.FieldCopyright) {
		fields = append(fields, app.FieldCopyright)
	}
	if m.FieldCleared(app.FieldEmail) {
		fields = append(fields, app.FieldEmail)
	}
	if m.FieldCleared(app.FieldAddress) {
		fields = append(fields, app.FieldAddress)
	}
	if m.FieldCleared(app.FieldSocialTw) {
		fields = append(fields, app.FieldSocialTw)
	}
	if m.FieldCleared(app.FieldSocialFb) {
		fields = append(fields, app.FieldSocialFb)
	}
	if m.FieldCleared(app.FieldSocialIn) {
		fields = append(fields, app.FieldSocialIn)
	}
	if m.FieldCleared(app.FieldLogoURL) {
		fields = append(fields, app.FieldLogoURL)
	}
	if m.FieldCleared(app.FieldSiteURL) {
		fields = append(fields, app.FieldSiteURL)
	}
	if m.FieldCleared(app.FieldDefaultMailConnID) {
		fields = append(fields, app.FieldDefaultMailConnID)
	}
	if m.FieldCleared(app.FieldMailLayoutTemplID) {
		fields = append(fields, app.FieldMailLayoutTemplID)
	}
	if m.FieldCleared(app.FieldWsapceInviteTemplID) {
		fields = append(fields, app.FieldWsapceInviteTemplID)
	}
	if m.FieldCleared(app.FieldWsapceSuccessTemplID) {
		fields = append(fields, app.FieldWsapceSuccessTemplID)
	}
	if m.FieldCleared(app.FieldAuthFpTemplID) {
		fields = append(fields, app.FieldAuthFpTemplID)
	}
	if m.FieldCleared(app.FieldAuthWelcomeEmailTemplID) {
		fields = append(fields, app.FieldAuthWelcomeEmailTemplID)
	}
	if m.FieldCleared(app.FieldAuthVerificationTemplID) {
		fields = append(fields, app.FieldAuthVerificationTemplID)
	}
	if m.FieldCleared(app.FieldAuthEmailVerify) {
		fields = append(fields, app.FieldAuthEmailVerify)
	}
	if m.FieldCleared(app.FieldOauthSigninCanSignup) {
		fields = append(fields, app.FieldOauthSigninCanSignup)
	}
	if m.FieldCleared(app.FieldAuthEnablePasswordLogin) {
		fields = append(fields, app.FieldAuthEnablePasswordLogin)
	}
	if m.FieldCleared(app.FieldAdminUserID) {
		fields = append(fields, app.FieldAdminUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppMutation) ClearField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case app.FieldName:
		m.ClearName()
		return nil
	case app.FieldCopyright:
		m.ClearCopyright()
		return nil
	case app.FieldEmail:
		m.ClearEmail()
		return nil
	case app.FieldAddress:
		m.ClearAddress()
		return nil
	case app.FieldSocialTw:
		m.ClearSocialTw()
		return nil
	case app.FieldSocialFb:
		m.ClearSocialFb()
		return nil
	case app.FieldSocialIn:
		m.ClearSocialIn()
		return nil
	case app.FieldLogoURL:
		m.ClearLogoURL()
		return nil
	case app.FieldSiteURL:
		m.ClearSiteURL()
		return nil
	case app.FieldDefaultMailConnID:
		m.ClearDefaultMailConnID()
		return nil
	case app.FieldMailLayoutTemplID:
		m.ClearMailLayoutTemplID()
		return nil
	case app.FieldWsapceInviteTemplID:
		m.ClearWsapceInviteTemplID()
		return nil
	case app.FieldWsapceSuccessTemplID:
		m.ClearWsapceSuccessTemplID()
		return nil
	case app.FieldAuthFpTemplID:
		m.ClearAuthFpTemplID()
		return nil
	case app.FieldAuthWelcomeEmailTemplID:
		m.ClearAuthWelcomeEmailTemplID()
		return nil
	case app.FieldAuthVerificationTemplID:
		m.ClearAuthVerificationTemplID()
		return nil
	case app.FieldAuthEmailVerify:
		m.ClearAuthEmailVerify()
		return nil
	case app.FieldOauthSigninCanSignup:
		m.ClearOauthSigninCanSignup()
		return nil
	case app.FieldAuthEnablePasswordLogin:
		m.ClearAuthEnablePasswordLogin()
		return nil
	case app.FieldAdminUserID:
		m.ClearAdminUserID()
		return nil
	}
	return fmt.Errorf("unknown App nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppMutation) ResetField(name string) error {
	switch name {
	case app.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case app.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case app.FieldName:
		m.ResetName()
		return nil
	case app.FieldCopyright:
		m.ResetCopyright()
		return nil
	case app.FieldEmail:
		m.ResetEmail()
		return nil
	case app.FieldAddress:
		m.ResetAddress()
		return nil
	case app.FieldSocialTw:
		m.ResetSocialTw()
		return nil
	case app.FieldSocialFb:
		m.ResetSocialFb()
		return nil
	case app.FieldSocialIn:
		m.ResetSocialIn()
		return nil
	case app.FieldLogoURL:
		m.ResetLogoURL()
		return nil
	case app.FieldSiteURL:
		m.ResetSiteURL()
		return nil
	case app.FieldDefaultMailConnID:
		m.ResetDefaultMailConnID()
		return nil
	case app.FieldMailLayoutTemplID:
		m.ResetMailLayoutTemplID()
		return nil
	case app.FieldWsapceInviteTemplID:
		m.ResetWsapceInviteTemplID()
		return nil
	case app.FieldWsapceSuccessTemplID:
		m.ResetWsapceSuccessTemplID()
		return nil
	case app.FieldAuthFpTemplID:
		m.ResetAuthFpTemplID()
		return nil
	case app.FieldAuthWelcomeEmailTemplID:
		m.ResetAuthWelcomeEmailTemplID()
		return nil
	case app.FieldAuthVerificationTemplID:
		m.ResetAuthVerificationTemplID()
		return nil
	case app.FieldAuthEmailVerify:
		m.ResetAuthEmailVerify()
		return nil
	case app.FieldOauthSigninCanSignup:
		m.ResetOauthSigninCanSignup()
		return nil
	case app.FieldAuthEnablePasswordLogin:
		m.ResetAuthEnablePasswordLogin()
		return nil
	case app.FieldAdminUserID:
		m.ResetAdminUserID()
		return nil
	}
	return fmt.Errorf("unknown App field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppMutation) AddedEdges() []string {
	edges := make([]string, 0, 9)
	if m.default_mail_conn != nil {
		edges = append(edges, app.EdgeDefaultMailConn)
	}
	if m.mail_layout_templ != nil {
		edges = append(edges, app.EdgeMailLayoutTempl)
	}
	if m.wsapce_invite_templ != nil {
		edges = append(edges, app.EdgeWsapceInviteTempl)
	}
	if m.wsapce_success_templ != nil {
		edges = append(edges, app.EdgeWsapceSuccessTempl)
	}
	if m.auth_fp_templ != nil {
		edges = append(edges, app.EdgeAuthFpTempl)
	}
	if m.auth_welcome_email_templ != nil {
		edges = append(edges, app.EdgeAuthWelcomeEmailTempl)
	}
	if m.auth_verification_templ != nil {
		edges = append(edges, app.EdgeAuthVerificationTempl)
	}
	if m.admin_user != nil {
		edges = append(edges, app.EdgeAdminUser)
	}
	if m.app_users != nil {
		edges = append(edges, app.EdgeAppUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeDefaultMailConn:
		if id := m.default_mail_conn; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeMailLayoutTempl:
		if id := m.mail_layout_templ; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeWsapceInviteTempl:
		if id := m.wsapce_invite_templ; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeWsapceSuccessTempl:
		if id := m.wsapce_success_templ; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeAuthFpTempl:
		if id := m.auth_fp_templ; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeAuthWelcomeEmailTempl:
		if id := m.auth_welcome_email_templ; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeAuthVerificationTempl:
		if id := m.auth_verification_templ; id != nil {
			return []ent.Value{*id}
		}
	case app.EdgeAdminUser:
		ids := make([]ent.Value, 0, len(m.admin_user))
		for id := range m.admin_user {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAppUsers:
		ids := make([]ent.Value, 0, len(m.app_users))
		for id := range m.app_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppMutation) RemovedEdges() []string {
	edges := make([]string, 0, 9)
	if m.removedadmin_user != nil {
		edges = append(edges, app.EdgeAdminUser)
	}
	if m.removedapp_users != nil {
		edges = append(edges, app.EdgeAppUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case app.EdgeAdminUser:
		ids := make([]ent.Value, 0, len(m.removedadmin_user))
		for id := range m.removedadmin_user {
			ids = append(ids, id)
		}
		return ids
	case app.EdgeAppUsers:
		ids := make([]ent.Value, 0, len(m.removedapp_users))
		for id := range m.removedapp_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppMutation) ClearedEdges() []string {
	edges := make([]string, 0, 9)
	if m.cleareddefault_mail_conn {
		edges = append(edges, app.EdgeDefaultMailConn)
	}
	if m.clearedmail_layout_templ {
		edges = append(edges, app.EdgeMailLayoutTempl)
	}
	if m.clearedwsapce_invite_templ {
		edges = append(edges, app.EdgeWsapceInviteTempl)
	}
	if m.clearedwsapce_success_templ {
		edges = append(edges, app.EdgeWsapceSuccessTempl)
	}
	if m.clearedauth_fp_templ {
		edges = append(edges, app.EdgeAuthFpTempl)
	}
	if m.clearedauth_welcome_email_templ {
		edges = append(edges, app.EdgeAuthWelcomeEmailTempl)
	}
	if m.clearedauth_verification_templ {
		edges = append(edges, app.EdgeAuthVerificationTempl)
	}
	if m.clearedadmin_user {
		edges = append(edges, app.EdgeAdminUser)
	}
	if m.clearedapp_users {
		edges = append(edges, app.EdgeAppUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppMutation) EdgeCleared(name string) bool {
	switch name {
	case app.EdgeDefaultMailConn:
		return m.cleareddefault_mail_conn
	case app.EdgeMailLayoutTempl:
		return m.clearedmail_layout_templ
	case app.EdgeWsapceInviteTempl:
		return m.clearedwsapce_invite_templ
	case app.EdgeWsapceSuccessTempl:
		return m.clearedwsapce_success_templ
	case app.EdgeAuthFpTempl:
		return m.clearedauth_fp_templ
	case app.EdgeAuthWelcomeEmailTempl:
		return m.clearedauth_welcome_email_templ
	case app.EdgeAuthVerificationTempl:
		return m.clearedauth_verification_templ
	case app.EdgeAdminUser:
		return m.clearedadmin_user
	case app.EdgeAppUsers:
		return m.clearedapp_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppMutation) ClearEdge(name string) error {
	switch name {
	case app.EdgeDefaultMailConn:
		m.ClearDefaultMailConn()
		return nil
	case app.EdgeMailLayoutTempl:
		m.ClearMailLayoutTempl()
		return nil
	case app.EdgeWsapceInviteTempl:
		m.ClearWsapceInviteTempl()
		return nil
	case app.EdgeWsapceSuccessTempl:
		m.ClearWsapceSuccessTempl()
		return nil
	case app.EdgeAuthFpTempl:
		m.ClearAuthFpTempl()
		return nil
	case app.EdgeAuthWelcomeEmailTempl:
		m.ClearAuthWelcomeEmailTempl()
		return nil
	case app.EdgeAuthVerificationTempl:
		m.ClearAuthVerificationTempl()
		return nil
	}
	return fmt.Errorf("unknown App unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppMutation) ResetEdge(name string) error {
	switch name {
	case app.EdgeDefaultMailConn:
		m.ResetDefaultMailConn()
		return nil
	case app.EdgeMailLayoutTempl:
		m.ResetMailLayoutTempl()
		return nil
	case app.EdgeWsapceInviteTempl:
		m.ResetWsapceInviteTempl()
		return nil
	case app.EdgeWsapceSuccessTempl:
		m.ResetWsapceSuccessTempl()
		return nil
	case app.EdgeAuthFpTempl:
		m.ResetAuthFpTempl()
		return nil
	case app.EdgeAuthWelcomeEmailTempl:
		m.ResetAuthWelcomeEmailTempl()
		return nil
	case app.EdgeAuthVerificationTempl:
		m.ResetAuthVerificationTempl()
		return nil
	case app.EdgeAdminUser:
		m.ResetAdminUser()
		return nil
	case app.EdgeAppUsers:
		m.ResetAppUsers()
		return nil
	}
	return fmt.Errorf("unknown App edge %s", name)
}

// AppPermMutation represents an operation that mutates the AppPerm nodes in the graph.
type AppPermMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	name                  *string
	clearedFields         map[string]struct{}
	app                   *string
	clearedapp            bool
	app_roles             map[string]struct{}
	removedapp_roles      map[string]struct{}
	clearedapp_roles      bool
	app_role_perms        map[string]struct{}
	removedapp_role_perms map[string]struct{}
	clearedapp_role_perms bool
	done                  bool
	oldValue              func(context.Context) (*AppPerm, error)
	predicates            []predicate.AppPerm
}

var _ ent.Mutation = (*AppPermMutation)(nil)

// apppermOption allows management of the mutation configuration using functional options.
type apppermOption func(*AppPermMutation)

// newAppPermMutation creates new mutation for the AppPerm entity.
func newAppPermMutation(c config, op Op, opts ...apppermOption) *AppPermMutation {
	m := &AppPermMutation{
		config:        c,
		op:            op,
		typ:           TypeAppPerm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppPermID sets the ID field of the mutation.
func withAppPermID(id string) apppermOption {
	return func(m *AppPermMutation) {
		var (
			err   error
			once  sync.Once
			value *AppPerm
		)
		m.oldValue = func(ctx context.Context) (*AppPerm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppPerm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppPerm sets the old AppPerm of the mutation.
func withAppPerm(node *AppPerm) apppermOption {
	return func(m *AppPermMutation) {
		m.oldValue = func(context.Context) (*AppPerm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppPermMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppPermMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppPerm entities.
func (m *AppPermMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppPermMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppPermMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppPerm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppPermMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppPermMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppPerm entity.
// If the AppPerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppPermMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[appperm.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppPermMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[appperm.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppPermMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, appperm.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppPermMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppPermMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppPerm entity.
// If the AppPerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppPermMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appperm.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppPermMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appperm.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppPermMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appperm.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *AppPermMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppPermMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppPerm entity.
// If the AppPerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppPermMutation) ClearName() {
	m.name = nil
	m.clearedFields[appperm.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppPermMutation) NameCleared() bool {
	_, ok := m.clearedFields[appperm.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppPermMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, appperm.FieldName)
}

// SetAppID sets the "app_id" field.
func (m *AppPermMutation) SetAppID(s string) {
	m.app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppPermMutation) AppID() (r string, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppPerm entity.
// If the AppPerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppPermMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppPermMutation) ClearAppID() {
	m.app = nil
	m.clearedFields[appperm.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppPermMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[appperm.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppPermMutation) ResetAppID() {
	m.app = nil
	delete(m.clearedFields, appperm.FieldAppID)
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppPermMutation) ClearApp() {
	m.clearedapp = true
	m.clearedFields[appperm.FieldAppID] = struct{}{}
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppPermMutation) AppCleared() bool {
	return m.AppIDCleared() || m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppPermMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppPermMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddAppRoleIDs adds the "app_roles" edge to the AppRole entity by ids.
func (m *AppPermMutation) AddAppRoleIDs(ids ...string) {
	if m.app_roles == nil {
		m.app_roles = make(map[string]struct{})
	}
	for i := range ids {
		m.app_roles[ids[i]] = struct{}{}
	}
}

// ClearAppRoles clears the "app_roles" edge to the AppRole entity.
func (m *AppPermMutation) ClearAppRoles() {
	m.clearedapp_roles = true
}

// AppRolesCleared reports if the "app_roles" edge to the AppRole entity was cleared.
func (m *AppPermMutation) AppRolesCleared() bool {
	return m.clearedapp_roles
}

// RemoveAppRoleIDs removes the "app_roles" edge to the AppRole entity by IDs.
func (m *AppPermMutation) RemoveAppRoleIDs(ids ...string) {
	if m.removedapp_roles == nil {
		m.removedapp_roles = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.app_roles, ids[i])
		m.removedapp_roles[ids[i]] = struct{}{}
	}
}

// RemovedAppRoles returns the removed IDs of the "app_roles" edge to the AppRole entity.
func (m *AppPermMutation) RemovedAppRolesIDs() (ids []string) {
	for id := range m.removedapp_roles {
		ids = append(ids, id)
	}
	return
}

// AppRolesIDs returns the "app_roles" edge IDs in the mutation.
func (m *AppPermMutation) AppRolesIDs() (ids []string) {
	for id := range m.app_roles {
		ids = append(ids, id)
	}
	return
}

// ResetAppRoles resets all changes to the "app_roles" edge.
func (m *AppPermMutation) ResetAppRoles() {
	m.app_roles = nil
	m.clearedapp_roles = false
	m.removedapp_roles = nil
}

// AddAppRolePermIDs adds the "app_role_perms" edge to the AppRolePerm entity by ids.
func (m *AppPermMutation) AddAppRolePermIDs(ids ...string) {
	if m.app_role_perms == nil {
		m.app_role_perms = make(map[string]struct{})
	}
	for i := range ids {
		m.app_role_perms[ids[i]] = struct{}{}
	}
}

// ClearAppRolePerms clears the "app_role_perms" edge to the AppRolePerm entity.
func (m *AppPermMutation) ClearAppRolePerms() {
	m.clearedapp_role_perms = true
}

// AppRolePermsCleared reports if the "app_role_perms" edge to the AppRolePerm entity was cleared.
func (m *AppPermMutation) AppRolePermsCleared() bool {
	return m.clearedapp_role_perms
}

// RemoveAppRolePermIDs removes the "app_role_perms" edge to the AppRolePerm entity by IDs.
func (m *AppPermMutation) RemoveAppRolePermIDs(ids ...string) {
	if m.removedapp_role_perms == nil {
		m.removedapp_role_perms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.app_role_perms, ids[i])
		m.removedapp_role_perms[ids[i]] = struct{}{}
	}
}

// RemovedAppRolePerms returns the removed IDs of the "app_role_perms" edge to the AppRolePerm entity.
func (m *AppPermMutation) RemovedAppRolePermsIDs() (ids []string) {
	for id := range m.removedapp_role_perms {
		ids = append(ids, id)
	}
	return
}

// AppRolePermsIDs returns the "app_role_perms" edge IDs in the mutation.
func (m *AppPermMutation) AppRolePermsIDs() (ids []string) {
	for id := range m.app_role_perms {
		ids = append(ids, id)
	}
	return
}

// ResetAppRolePerms resets all changes to the "app_role_perms" edge.
func (m *AppPermMutation) ResetAppRolePerms() {
	m.app_role_perms = nil
	m.clearedapp_role_perms = false
	m.removedapp_role_perms = nil
}

// Where appends a list predicates to the AppPermMutation builder.
func (m *AppPermMutation) Where(ps ...predicate.AppPerm) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppPermMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppPermMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppPerm, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppPermMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppPermMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppPerm).
func (m *AppPermMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppPermMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, appperm.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appperm.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, appperm.FieldName)
	}
	if m.app != nil {
		fields = append(fields, appperm.FieldAppID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppPermMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appperm.FieldCreatedAt:
		return m.CreatedAt()
	case appperm.FieldUpdatedAt:
		return m.UpdatedAt()
	case appperm.FieldName:
		return m.Name()
	case appperm.FieldAppID:
		return m.AppID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppPermMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appperm.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appperm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appperm.FieldName:
		return m.OldName(ctx)
	case appperm.FieldAppID:
		return m.OldAppID(ctx)
	}
	return nil, fmt.Errorf("unknown AppPerm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPermMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appperm.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appperm.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appperm.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case appperm.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	}
	return fmt.Errorf("unknown AppPerm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppPermMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppPermMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppPermMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppPerm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppPermMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appperm.FieldCreatedAt) {
		fields = append(fields, appperm.FieldCreatedAt)
	}
	if m.FieldCleared(appperm.FieldUpdatedAt) {
		fields = append(fields, appperm.FieldUpdatedAt)
	}
	if m.FieldCleared(appperm.FieldName) {
		fields = append(fields, appperm.FieldName)
	}
	if m.FieldCleared(appperm.FieldAppID) {
		fields = append(fields, appperm.FieldAppID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppPermMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppPermMutation) ClearField(name string) error {
	switch name {
	case appperm.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case appperm.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case appperm.FieldName:
		m.ClearName()
		return nil
	case appperm.FieldAppID:
		m.ClearAppID()
		return nil
	}
	return fmt.Errorf("unknown AppPerm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppPermMutation) ResetField(name string) error {
	switch name {
	case appperm.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appperm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appperm.FieldName:
		m.ResetName()
		return nil
	case appperm.FieldAppID:
		m.ResetAppID()
		return nil
	}
	return fmt.Errorf("unknown AppPerm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppPermMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, appperm.EdgeApp)
	}
	if m.app_roles != nil {
		edges = append(edges, appperm.EdgeAppRoles)
	}
	if m.app_role_perms != nil {
		edges = append(edges, appperm.EdgeAppRolePerms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppPermMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appperm.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appperm.EdgeAppRoles:
		ids := make([]ent.Value, 0, len(m.app_roles))
		for id := range m.app_roles {
			ids = append(ids, id)
		}
		return ids
	case appperm.EdgeAppRolePerms:
		ids := make([]ent.Value, 0, len(m.app_role_perms))
		for id := range m.app_role_perms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppPermMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedapp_roles != nil {
		edges = append(edges, appperm.EdgeAppRoles)
	}
	if m.removedapp_role_perms != nil {
		edges = append(edges, appperm.EdgeAppRolePerms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppPermMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case appperm.EdgeAppRoles:
		ids := make([]ent.Value, 0, len(m.removedapp_roles))
		for id := range m.removedapp_roles {
			ids = append(ids, id)
		}
		return ids
	case appperm.EdgeAppRolePerms:
		ids := make([]ent.Value, 0, len(m.removedapp_role_perms))
		for id := range m.removedapp_role_perms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppPermMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, appperm.EdgeApp)
	}
	if m.clearedapp_roles {
		edges = append(edges, appperm.EdgeAppRoles)
	}
	if m.clearedapp_role_perms {
		edges = append(edges, appperm.EdgeAppRolePerms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppPermMutation) EdgeCleared(name string) bool {
	switch name {
	case appperm.EdgeApp:
		return m.clearedapp
	case appperm.EdgeAppRoles:
		return m.clearedapp_roles
	case appperm.EdgeAppRolePerms:
		return m.clearedapp_role_perms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppPermMutation) ClearEdge(name string) error {
	switch name {
	case appperm.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppPerm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppPermMutation) ResetEdge(name string) error {
	switch name {
	case appperm.EdgeApp:
		m.ResetApp()
		return nil
	case appperm.EdgeAppRoles:
		m.ResetAppRoles()
		return nil
	case appperm.EdgeAppRolePerms:
		m.ResetAppRolePerms()
		return nil
	}
	return fmt.Errorf("unknown AppPerm edge %s", name)
}

// AppRoleMutation represents an operation that mutates the AppRole nodes in the graph.
type AppRoleMutation struct {
	config
	op                    Op
	typ                   string
	id                    *string
	created_at            *time.Time
	updated_at            *time.Time
	name                  *string
	is_global             *bool
	clearedFields         map[string]struct{}
	app                   *string
	clearedapp            bool
	app_perms             map[string]struct{}
	removedapp_perms      map[string]struct{}
	clearedapp_perms      bool
	app_role_perms        map[string]struct{}
	removedapp_role_perms map[string]struct{}
	clearedapp_role_perms bool
	done                  bool
	oldValue              func(context.Context) (*AppRole, error)
	predicates            []predicate.AppRole
}

var _ ent.Mutation = (*AppRoleMutation)(nil)

// approleOption allows management of the mutation configuration using functional options.
type approleOption func(*AppRoleMutation)

// newAppRoleMutation creates new mutation for the AppRole entity.
func newAppRoleMutation(c config, op Op, opts ...approleOption) *AppRoleMutation {
	m := &AppRoleMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRole,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRoleID sets the ID field of the mutation.
func withAppRoleID(id string) approleOption {
	return func(m *AppRoleMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRole
		)
		m.oldValue = func(ctx context.Context) (*AppRole, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRole.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRole sets the old AppRole of the mutation.
func withAppRole(node *AppRole) approleOption {
	return func(m *AppRoleMutation) {
		m.oldValue = func(context.Context) (*AppRole, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRoleMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRoleMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRole entities.
func (m *AppRoleMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRoleMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRoleMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRole.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRoleMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRoleMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppRoleMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[approle.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppRoleMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[approle.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRoleMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, approle.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRoleMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRoleMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppRoleMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[approle.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppRoleMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[approle.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRoleMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, approle.FieldUpdatedAt)
}

// SetName sets the "name" field.
func (m *AppRoleMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AppRoleMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *AppRoleMutation) ClearName() {
	m.name = nil
	m.clearedFields[approle.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *AppRoleMutation) NameCleared() bool {
	_, ok := m.clearedFields[approle.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *AppRoleMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, approle.FieldName)
}

// SetAppID sets the "app_id" field.
func (m *AppRoleMutation) SetAppID(s string) {
	m.app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRoleMutation) AppID() (r string, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *AppRoleMutation) ClearAppID() {
	m.app = nil
	m.clearedFields[approle.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *AppRoleMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[approle.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRoleMutation) ResetAppID() {
	m.app = nil
	delete(m.clearedFields, approle.FieldAppID)
}

// SetIsGlobal sets the "is_global" field.
func (m *AppRoleMutation) SetIsGlobal(b bool) {
	m.is_global = &b
}

// IsGlobal returns the value of the "is_global" field in the mutation.
func (m *AppRoleMutation) IsGlobal() (r bool, exists bool) {
	v := m.is_global
	if v == nil {
		return
	}
	return *v, true
}

// OldIsGlobal returns the old "is_global" field's value of the AppRole entity.
// If the AppRole object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRoleMutation) OldIsGlobal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsGlobal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsGlobal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsGlobal: %w", err)
	}
	return oldValue.IsGlobal, nil
}

// ResetIsGlobal resets all changes to the "is_global" field.
func (m *AppRoleMutation) ResetIsGlobal() {
	m.is_global = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppRoleMutation) ClearApp() {
	m.clearedapp = true
	m.clearedFields[approle.FieldAppID] = struct{}{}
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppRoleMutation) AppCleared() bool {
	return m.AppIDCleared() || m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppRoleMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppRoleMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// AddAppPermIDs adds the "app_perms" edge to the AppPerm entity by ids.
func (m *AppRoleMutation) AddAppPermIDs(ids ...string) {
	if m.app_perms == nil {
		m.app_perms = make(map[string]struct{})
	}
	for i := range ids {
		m.app_perms[ids[i]] = struct{}{}
	}
}

// ClearAppPerms clears the "app_perms" edge to the AppPerm entity.
func (m *AppRoleMutation) ClearAppPerms() {
	m.clearedapp_perms = true
}

// AppPermsCleared reports if the "app_perms" edge to the AppPerm entity was cleared.
func (m *AppRoleMutation) AppPermsCleared() bool {
	return m.clearedapp_perms
}

// RemoveAppPermIDs removes the "app_perms" edge to the AppPerm entity by IDs.
func (m *AppRoleMutation) RemoveAppPermIDs(ids ...string) {
	if m.removedapp_perms == nil {
		m.removedapp_perms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.app_perms, ids[i])
		m.removedapp_perms[ids[i]] = struct{}{}
	}
}

// RemovedAppPerms returns the removed IDs of the "app_perms" edge to the AppPerm entity.
func (m *AppRoleMutation) RemovedAppPermsIDs() (ids []string) {
	for id := range m.removedapp_perms {
		ids = append(ids, id)
	}
	return
}

// AppPermsIDs returns the "app_perms" edge IDs in the mutation.
func (m *AppRoleMutation) AppPermsIDs() (ids []string) {
	for id := range m.app_perms {
		ids = append(ids, id)
	}
	return
}

// ResetAppPerms resets all changes to the "app_perms" edge.
func (m *AppRoleMutation) ResetAppPerms() {
	m.app_perms = nil
	m.clearedapp_perms = false
	m.removedapp_perms = nil
}

// AddAppRolePermIDs adds the "app_role_perms" edge to the AppRolePerm entity by ids.
func (m *AppRoleMutation) AddAppRolePermIDs(ids ...string) {
	if m.app_role_perms == nil {
		m.app_role_perms = make(map[string]struct{})
	}
	for i := range ids {
		m.app_role_perms[ids[i]] = struct{}{}
	}
}

// ClearAppRolePerms clears the "app_role_perms" edge to the AppRolePerm entity.
func (m *AppRoleMutation) ClearAppRolePerms() {
	m.clearedapp_role_perms = true
}

// AppRolePermsCleared reports if the "app_role_perms" edge to the AppRolePerm entity was cleared.
func (m *AppRoleMutation) AppRolePermsCleared() bool {
	return m.clearedapp_role_perms
}

// RemoveAppRolePermIDs removes the "app_role_perms" edge to the AppRolePerm entity by IDs.
func (m *AppRoleMutation) RemoveAppRolePermIDs(ids ...string) {
	if m.removedapp_role_perms == nil {
		m.removedapp_role_perms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.app_role_perms, ids[i])
		m.removedapp_role_perms[ids[i]] = struct{}{}
	}
}

// RemovedAppRolePerms returns the removed IDs of the "app_role_perms" edge to the AppRolePerm entity.
func (m *AppRoleMutation) RemovedAppRolePermsIDs() (ids []string) {
	for id := range m.removedapp_role_perms {
		ids = append(ids, id)
	}
	return
}

// AppRolePermsIDs returns the "app_role_perms" edge IDs in the mutation.
func (m *AppRoleMutation) AppRolePermsIDs() (ids []string) {
	for id := range m.app_role_perms {
		ids = append(ids, id)
	}
	return
}

// ResetAppRolePerms resets all changes to the "app_role_perms" edge.
func (m *AppRoleMutation) ResetAppRolePerms() {
	m.app_role_perms = nil
	m.clearedapp_role_perms = false
	m.removedapp_role_perms = nil
}

// Where appends a list predicates to the AppRoleMutation builder.
func (m *AppRoleMutation) Where(ps ...predicate.AppRole) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRoleMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRoleMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRole, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRoleMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRoleMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRole).
func (m *AppRoleMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRoleMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.name != nil {
		fields = append(fields, approle.FieldName)
	}
	if m.app != nil {
		fields = append(fields, approle.FieldAppID)
	}
	if m.is_global != nil {
		fields = append(fields, approle.FieldIsGlobal)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRoleMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approle.FieldCreatedAt:
		return m.CreatedAt()
	case approle.FieldUpdatedAt:
		return m.UpdatedAt()
	case approle.FieldName:
		return m.Name()
	case approle.FieldAppID:
		return m.AppID()
	case approle.FieldIsGlobal:
		return m.IsGlobal()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRoleMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approle.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approle.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approle.FieldName:
		return m.OldName(ctx)
	case approle.FieldAppID:
		return m.OldAppID(ctx)
	case approle.FieldIsGlobal:
		return m.OldIsGlobal(ctx)
	}
	return nil, fmt.Errorf("unknown AppRole field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approle.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approle.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approle.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case approle.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case approle.FieldIsGlobal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsGlobal(v)
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRoleMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRoleMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRoleMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppRole numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRoleMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approle.FieldCreatedAt) {
		fields = append(fields, approle.FieldCreatedAt)
	}
	if m.FieldCleared(approle.FieldUpdatedAt) {
		fields = append(fields, approle.FieldUpdatedAt)
	}
	if m.FieldCleared(approle.FieldName) {
		fields = append(fields, approle.FieldName)
	}
	if m.FieldCleared(approle.FieldAppID) {
		fields = append(fields, approle.FieldAppID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRoleMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRoleMutation) ClearField(name string) error {
	switch name {
	case approle.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case approle.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case approle.FieldName:
		m.ClearName()
		return nil
	case approle.FieldAppID:
		m.ClearAppID()
		return nil
	}
	return fmt.Errorf("unknown AppRole nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRoleMutation) ResetField(name string) error {
	switch name {
	case approle.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approle.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approle.FieldName:
		m.ResetName()
		return nil
	case approle.FieldAppID:
		m.ResetAppID()
		return nil
	case approle.FieldIsGlobal:
		m.ResetIsGlobal()
		return nil
	}
	return fmt.Errorf("unknown AppRole field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRoleMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, approle.EdgeApp)
	}
	if m.app_perms != nil {
		edges = append(edges, approle.EdgeAppPerms)
	}
	if m.app_role_perms != nil {
		edges = append(edges, approle.EdgeAppRolePerms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRoleMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case approle.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case approle.EdgeAppPerms:
		ids := make([]ent.Value, 0, len(m.app_perms))
		for id := range m.app_perms {
			ids = append(ids, id)
		}
		return ids
	case approle.EdgeAppRolePerms:
		ids := make([]ent.Value, 0, len(m.app_role_perms))
		for id := range m.app_role_perms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRoleMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedapp_perms != nil {
		edges = append(edges, approle.EdgeAppPerms)
	}
	if m.removedapp_role_perms != nil {
		edges = append(edges, approle.EdgeAppRolePerms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRoleMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case approle.EdgeAppPerms:
		ids := make([]ent.Value, 0, len(m.removedapp_perms))
		for id := range m.removedapp_perms {
			ids = append(ids, id)
		}
		return ids
	case approle.EdgeAppRolePerms:
		ids := make([]ent.Value, 0, len(m.removedapp_role_perms))
		for id := range m.removedapp_role_perms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRoleMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, approle.EdgeApp)
	}
	if m.clearedapp_perms {
		edges = append(edges, approle.EdgeAppPerms)
	}
	if m.clearedapp_role_perms {
		edges = append(edges, approle.EdgeAppRolePerms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRoleMutation) EdgeCleared(name string) bool {
	switch name {
	case approle.EdgeApp:
		return m.clearedapp
	case approle.EdgeAppPerms:
		return m.clearedapp_perms
	case approle.EdgeAppRolePerms:
		return m.clearedapp_role_perms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRoleMutation) ClearEdge(name string) error {
	switch name {
	case approle.EdgeApp:
		m.ClearApp()
		return nil
	}
	return fmt.Errorf("unknown AppRole unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRoleMutation) ResetEdge(name string) error {
	switch name {
	case approle.EdgeApp:
		m.ResetApp()
		return nil
	case approle.EdgeAppPerms:
		m.ResetAppPerms()
		return nil
	case approle.EdgeAppRolePerms:
		m.ResetAppRolePerms()
		return nil
	}
	return fmt.Errorf("unknown AppRole edge %s", name)
}

// AppRolePermMutation represents an operation that mutates the AppRolePerm nodes in the graph.
type AppRolePermMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	clearedFields   map[string]struct{}
	app             *string
	clearedapp      bool
	app_perm        *string
	clearedapp_perm bool
	app_role        *string
	clearedapp_role bool
	done            bool
	oldValue        func(context.Context) (*AppRolePerm, error)
	predicates      []predicate.AppRolePerm
}

var _ ent.Mutation = (*AppRolePermMutation)(nil)

// approlepermOption allows management of the mutation configuration using functional options.
type approlepermOption func(*AppRolePermMutation)

// newAppRolePermMutation creates new mutation for the AppRolePerm entity.
func newAppRolePermMutation(c config, op Op, opts ...approlepermOption) *AppRolePermMutation {
	m := &AppRolePermMutation{
		config:        c,
		op:            op,
		typ:           TypeAppRolePerm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppRolePermID sets the ID field of the mutation.
func withAppRolePermID(id string) approlepermOption {
	return func(m *AppRolePermMutation) {
		var (
			err   error
			once  sync.Once
			value *AppRolePerm
		)
		m.oldValue = func(ctx context.Context) (*AppRolePerm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppRolePerm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppRolePerm sets the old AppRolePerm of the mutation.
func withAppRolePerm(node *AppRolePerm) approlepermOption {
	return func(m *AppRolePermMutation) {
		m.oldValue = func(context.Context) (*AppRolePerm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppRolePermMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppRolePermMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppRolePerm entities.
func (m *AppRolePermMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppRolePermMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppRolePermMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppRolePerm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppRolePermMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppRolePermMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppRolePerm entity.
// If the AppRolePerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePermMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppRolePermMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[approleperm.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppRolePermMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[approleperm.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppRolePermMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, approleperm.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppRolePermMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppRolePermMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppRolePerm entity.
// If the AppRolePerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePermMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppRolePermMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[approleperm.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppRolePermMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[approleperm.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppRolePermMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, approleperm.FieldUpdatedAt)
}

// SetAppRoleID sets the "app_role_id" field.
func (m *AppRolePermMutation) SetAppRoleID(s string) {
	m.app_role = &s
}

// AppRoleID returns the value of the "app_role_id" field in the mutation.
func (m *AppRolePermMutation) AppRoleID() (r string, exists bool) {
	v := m.app_role
	if v == nil {
		return
	}
	return *v, true
}

// OldAppRoleID returns the old "app_role_id" field's value of the AppRolePerm entity.
// If the AppRolePerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePermMutation) OldAppRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppRoleID: %w", err)
	}
	return oldValue.AppRoleID, nil
}

// ResetAppRoleID resets all changes to the "app_role_id" field.
func (m *AppRolePermMutation) ResetAppRoleID() {
	m.app_role = nil
}

// SetAppPermID sets the "app_perm_id" field.
func (m *AppRolePermMutation) SetAppPermID(s string) {
	m.app_perm = &s
}

// AppPermID returns the value of the "app_perm_id" field in the mutation.
func (m *AppRolePermMutation) AppPermID() (r string, exists bool) {
	v := m.app_perm
	if v == nil {
		return
	}
	return *v, true
}

// OldAppPermID returns the old "app_perm_id" field's value of the AppRolePerm entity.
// If the AppRolePerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePermMutation) OldAppPermID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppPermID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppPermID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppPermID: %w", err)
	}
	return oldValue.AppPermID, nil
}

// ResetAppPermID resets all changes to the "app_perm_id" field.
func (m *AppRolePermMutation) ResetAppPermID() {
	m.app_perm = nil
}

// SetAppID sets the "app_id" field.
func (m *AppRolePermMutation) SetAppID(s string) {
	m.app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppRolePermMutation) AppID() (r string, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppRolePerm entity.
// If the AppRolePerm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppRolePermMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppRolePermMutation) ResetAppID() {
	m.app = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppRolePermMutation) ClearApp() {
	m.clearedapp = true
	m.clearedFields[approleperm.FieldAppID] = struct{}{}
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppRolePermMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppRolePermMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppRolePermMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// ClearAppPerm clears the "app_perm" edge to the AppPerm entity.
func (m *AppRolePermMutation) ClearAppPerm() {
	m.clearedapp_perm = true
	m.clearedFields[approleperm.FieldAppPermID] = struct{}{}
}

// AppPermCleared reports if the "app_perm" edge to the AppPerm entity was cleared.
func (m *AppRolePermMutation) AppPermCleared() bool {
	return m.clearedapp_perm
}

// AppPermIDs returns the "app_perm" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppPermID instead. It exists only for internal usage by the builders.
func (m *AppRolePermMutation) AppPermIDs() (ids []string) {
	if id := m.app_perm; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppPerm resets all changes to the "app_perm" edge.
func (m *AppRolePermMutation) ResetAppPerm() {
	m.app_perm = nil
	m.clearedapp_perm = false
}

// ClearAppRole clears the "app_role" edge to the AppRole entity.
func (m *AppRolePermMutation) ClearAppRole() {
	m.clearedapp_role = true
	m.clearedFields[approleperm.FieldAppRoleID] = struct{}{}
}

// AppRoleCleared reports if the "app_role" edge to the AppRole entity was cleared.
func (m *AppRolePermMutation) AppRoleCleared() bool {
	return m.clearedapp_role
}

// AppRoleIDs returns the "app_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppRoleID instead. It exists only for internal usage by the builders.
func (m *AppRolePermMutation) AppRoleIDs() (ids []string) {
	if id := m.app_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppRole resets all changes to the "app_role" edge.
func (m *AppRolePermMutation) ResetAppRole() {
	m.app_role = nil
	m.clearedapp_role = false
}

// Where appends a list predicates to the AppRolePermMutation builder.
func (m *AppRolePermMutation) Where(ps ...predicate.AppRolePerm) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppRolePermMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppRolePermMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppRolePerm, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppRolePermMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppRolePermMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppRolePerm).
func (m *AppRolePermMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppRolePermMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, approleperm.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, approleperm.FieldUpdatedAt)
	}
	if m.app_role != nil {
		fields = append(fields, approleperm.FieldAppRoleID)
	}
	if m.app_perm != nil {
		fields = append(fields, approleperm.FieldAppPermID)
	}
	if m.app != nil {
		fields = append(fields, approleperm.FieldAppID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppRolePermMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case approleperm.FieldCreatedAt:
		return m.CreatedAt()
	case approleperm.FieldUpdatedAt:
		return m.UpdatedAt()
	case approleperm.FieldAppRoleID:
		return m.AppRoleID()
	case approleperm.FieldAppPermID:
		return m.AppPermID()
	case approleperm.FieldAppID:
		return m.AppID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppRolePermMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case approleperm.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case approleperm.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case approleperm.FieldAppRoleID:
		return m.OldAppRoleID(ctx)
	case approleperm.FieldAppPermID:
		return m.OldAppPermID(ctx)
	case approleperm.FieldAppID:
		return m.OldAppID(ctx)
	}
	return nil, fmt.Errorf("unknown AppRolePerm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRolePermMutation) SetField(name string, value ent.Value) error {
	switch name {
	case approleperm.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case approleperm.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case approleperm.FieldAppRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppRoleID(v)
		return nil
	case approleperm.FieldAppPermID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppPermID(v)
		return nil
	case approleperm.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	}
	return fmt.Errorf("unknown AppRolePerm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppRolePermMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppRolePermMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppRolePermMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppRolePerm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppRolePermMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(approleperm.FieldCreatedAt) {
		fields = append(fields, approleperm.FieldCreatedAt)
	}
	if m.FieldCleared(approleperm.FieldUpdatedAt) {
		fields = append(fields, approleperm.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppRolePermMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppRolePermMutation) ClearField(name string) error {
	switch name {
	case approleperm.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case approleperm.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppRolePerm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppRolePermMutation) ResetField(name string) error {
	switch name {
	case approleperm.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case approleperm.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case approleperm.FieldAppRoleID:
		m.ResetAppRoleID()
		return nil
	case approleperm.FieldAppPermID:
		m.ResetAppPermID()
		return nil
	case approleperm.FieldAppID:
		m.ResetAppID()
		return nil
	}
	return fmt.Errorf("unknown AppRolePerm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppRolePermMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, approleperm.EdgeApp)
	}
	if m.app_perm != nil {
		edges = append(edges, approleperm.EdgeAppPerm)
	}
	if m.app_role != nil {
		edges = append(edges, approleperm.EdgeAppRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppRolePermMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case approleperm.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case approleperm.EdgeAppPerm:
		if id := m.app_perm; id != nil {
			return []ent.Value{*id}
		}
	case approleperm.EdgeAppRole:
		if id := m.app_role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppRolePermMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppRolePermMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppRolePermMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, approleperm.EdgeApp)
	}
	if m.clearedapp_perm {
		edges = append(edges, approleperm.EdgeAppPerm)
	}
	if m.clearedapp_role {
		edges = append(edges, approleperm.EdgeAppRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppRolePermMutation) EdgeCleared(name string) bool {
	switch name {
	case approleperm.EdgeApp:
		return m.clearedapp
	case approleperm.EdgeAppPerm:
		return m.clearedapp_perm
	case approleperm.EdgeAppRole:
		return m.clearedapp_role
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppRolePermMutation) ClearEdge(name string) error {
	switch name {
	case approleperm.EdgeApp:
		m.ClearApp()
		return nil
	case approleperm.EdgeAppPerm:
		m.ClearAppPerm()
		return nil
	case approleperm.EdgeAppRole:
		m.ClearAppRole()
		return nil
	}
	return fmt.Errorf("unknown AppRolePerm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppRolePermMutation) ResetEdge(name string) error {
	switch name {
	case approleperm.EdgeApp:
		m.ResetApp()
		return nil
	case approleperm.EdgeAppPerm:
		m.ResetAppPerm()
		return nil
	case approleperm.EdgeAppRole:
		m.ResetAppRole()
		return nil
	}
	return fmt.Errorf("unknown AppRolePerm edge %s", name)
}

// AppUserMutation represents an operation that mutates the AppUser nodes in the graph.
type AppUserMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	clearedFields    map[string]struct{}
	app              *string
	clearedapp       bool
	adminuser        *string
	clearedadminuser bool
	app_role         *string
	clearedapp_role  bool
	done             bool
	oldValue         func(context.Context) (*AppUser, error)
	predicates       []predicate.AppUser
}

var _ ent.Mutation = (*AppUserMutation)(nil)

// appuserOption allows management of the mutation configuration using functional options.
type appuserOption func(*AppUserMutation)

// newAppUserMutation creates new mutation for the AppUser entity.
func newAppUserMutation(c config, op Op, opts ...appuserOption) *AppUserMutation {
	m := &AppUserMutation{
		config:        c,
		op:            op,
		typ:           TypeAppUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAppUserID sets the ID field of the mutation.
func withAppUserID(id string) appuserOption {
	return func(m *AppUserMutation) {
		var (
			err   error
			once  sync.Once
			value *AppUser
		)
		m.oldValue = func(ctx context.Context) (*AppUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().AppUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAppUser sets the old AppUser of the mutation.
func withAppUser(node *AppUser) appuserOption {
	return func(m *AppUserMutation) {
		m.oldValue = func(context.Context) (*AppUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AppUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AppUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of AppUser entities.
func (m *AppUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AppUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AppUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().AppUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AppUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AppUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *AppUserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[appuser.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *AppUserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[appuser.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AppUserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, appuser.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AppUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AppUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *AppUserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[appuser.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *AppUserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[appuser.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AppUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, appuser.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *AppUserMutation) SetAppID(s string) {
	m.app = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *AppUserMutation) AppID() (r string, exists bool) {
	v := m.app
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ResetAppID resets all changes to the "app_id" field.
func (m *AppUserMutation) ResetAppID() {
	m.app = nil
}

// SetAdminUserID sets the "admin_user_id" field.
func (m *AppUserMutation) SetAdminUserID(s string) {
	m.adminuser = &s
}

// AdminUserID returns the value of the "admin_user_id" field in the mutation.
func (m *AppUserMutation) AdminUserID() (r string, exists bool) {
	v := m.adminuser
	if v == nil {
		return
	}
	return *v, true
}

// OldAdminUserID returns the old "admin_user_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAdminUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdminUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdminUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdminUserID: %w", err)
	}
	return oldValue.AdminUserID, nil
}

// ResetAdminUserID resets all changes to the "admin_user_id" field.
func (m *AppUserMutation) ResetAdminUserID() {
	m.adminuser = nil
}

// SetAppRoleID sets the "app_role_id" field.
func (m *AppUserMutation) SetAppRoleID(s string) {
	m.app_role = &s
}

// AppRoleID returns the value of the "app_role_id" field in the mutation.
func (m *AppUserMutation) AppRoleID() (r string, exists bool) {
	v := m.app_role
	if v == nil {
		return
	}
	return *v, true
}

// OldAppRoleID returns the old "app_role_id" field's value of the AppUser entity.
// If the AppUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AppUserMutation) OldAppRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppRoleID: %w", err)
	}
	return oldValue.AppRoleID, nil
}

// ResetAppRoleID resets all changes to the "app_role_id" field.
func (m *AppUserMutation) ResetAppRoleID() {
	m.app_role = nil
}

// ClearApp clears the "app" edge to the App entity.
func (m *AppUserMutation) ClearApp() {
	m.clearedapp = true
	m.clearedFields[appuser.FieldAppID] = struct{}{}
}

// AppCleared reports if the "app" edge to the App entity was cleared.
func (m *AppUserMutation) AppCleared() bool {
	return m.clearedapp
}

// AppIDs returns the "app" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppID instead. It exists only for internal usage by the builders.
func (m *AppUserMutation) AppIDs() (ids []string) {
	if id := m.app; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetApp resets all changes to the "app" edge.
func (m *AppUserMutation) ResetApp() {
	m.app = nil
	m.clearedapp = false
}

// SetAdminuserID sets the "adminuser" edge to the AdminUser entity by id.
func (m *AppUserMutation) SetAdminuserID(id string) {
	m.adminuser = &id
}

// ClearAdminuser clears the "adminuser" edge to the AdminUser entity.
func (m *AppUserMutation) ClearAdminuser() {
	m.clearedadminuser = true
	m.clearedFields[appuser.FieldAdminUserID] = struct{}{}
}

// AdminuserCleared reports if the "adminuser" edge to the AdminUser entity was cleared.
func (m *AppUserMutation) AdminuserCleared() bool {
	return m.clearedadminuser
}

// AdminuserID returns the "adminuser" edge ID in the mutation.
func (m *AppUserMutation) AdminuserID() (id string, exists bool) {
	if m.adminuser != nil {
		return *m.adminuser, true
	}
	return
}

// AdminuserIDs returns the "adminuser" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AdminuserID instead. It exists only for internal usage by the builders.
func (m *AppUserMutation) AdminuserIDs() (ids []string) {
	if id := m.adminuser; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAdminuser resets all changes to the "adminuser" edge.
func (m *AppUserMutation) ResetAdminuser() {
	m.adminuser = nil
	m.clearedadminuser = false
}

// ClearAppRole clears the "app_role" edge to the AppRole entity.
func (m *AppUserMutation) ClearAppRole() {
	m.clearedapp_role = true
	m.clearedFields[appuser.FieldAppRoleID] = struct{}{}
}

// AppRoleCleared reports if the "app_role" edge to the AppRole entity was cleared.
func (m *AppUserMutation) AppRoleCleared() bool {
	return m.clearedapp_role
}

// AppRoleIDs returns the "app_role" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AppRoleID instead. It exists only for internal usage by the builders.
func (m *AppUserMutation) AppRoleIDs() (ids []string) {
	if id := m.app_role; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAppRole resets all changes to the "app_role" edge.
func (m *AppUserMutation) ResetAppRole() {
	m.app_role = nil
	m.clearedapp_role = false
}

// Where appends a list predicates to the AppUserMutation builder.
func (m *AppUserMutation) Where(ps ...predicate.AppUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AppUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AppUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.AppUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AppUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AppUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (AppUser).
func (m *AppUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AppUserMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.created_at != nil {
		fields = append(fields, appuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, appuser.FieldUpdatedAt)
	}
	if m.app != nil {
		fields = append(fields, appuser.FieldAppID)
	}
	if m.adminuser != nil {
		fields = append(fields, appuser.FieldAdminUserID)
	}
	if m.app_role != nil {
		fields = append(fields, appuser.FieldAppRoleID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AppUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.CreatedAt()
	case appuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case appuser.FieldAppID:
		return m.AppID()
	case appuser.FieldAdminUserID:
		return m.AdminUserID()
	case appuser.FieldAppRoleID:
		return m.AppRoleID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AppUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case appuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case appuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case appuser.FieldAppID:
		return m.OldAppID(ctx)
	case appuser.FieldAdminUserID:
		return m.OldAdminUserID(ctx)
	case appuser.FieldAppRoleID:
		return m.OldAppRoleID(ctx)
	}
	return nil, fmt.Errorf("unknown AppUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case appuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case appuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case appuser.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case appuser.FieldAdminUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdminUserID(v)
		return nil
	case appuser.FieldAppRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppRoleID(v)
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AppUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AppUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AppUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown AppUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AppUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(appuser.FieldCreatedAt) {
		fields = append(fields, appuser.FieldCreatedAt)
	}
	if m.FieldCleared(appuser.FieldUpdatedAt) {
		fields = append(fields, appuser.FieldUpdatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AppUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AppUserMutation) ClearField(name string) error {
	switch name {
	case appuser.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case appuser.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown AppUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AppUserMutation) ResetField(name string) error {
	switch name {
	case appuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case appuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case appuser.FieldAppID:
		m.ResetAppID()
		return nil
	case appuser.FieldAdminUserID:
		m.ResetAdminUserID()
		return nil
	case appuser.FieldAppRoleID:
		m.ResetAppRoleID()
		return nil
	}
	return fmt.Errorf("unknown AppUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AppUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.app != nil {
		edges = append(edges, appuser.EdgeApp)
	}
	if m.adminuser != nil {
		edges = append(edges, appuser.EdgeAdminuser)
	}
	if m.app_role != nil {
		edges = append(edges, appuser.EdgeAppRole)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AppUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case appuser.EdgeApp:
		if id := m.app; id != nil {
			return []ent.Value{*id}
		}
	case appuser.EdgeAdminuser:
		if id := m.adminuser; id != nil {
			return []ent.Value{*id}
		}
	case appuser.EdgeAppRole:
		if id := m.app_role; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AppUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AppUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AppUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedapp {
		edges = append(edges, appuser.EdgeApp)
	}
	if m.clearedadminuser {
		edges = append(edges, appuser.EdgeAdminuser)
	}
	if m.clearedapp_role {
		edges = append(edges, appuser.EdgeAppRole)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AppUserMutation) EdgeCleared(name string) bool {
	switch name {
	case appuser.EdgeApp:
		return m.clearedapp
	case appuser.EdgeAdminuser:
		return m.clearedadminuser
	case appuser.EdgeAppRole:
		return m.clearedapp_role
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AppUserMutation) ClearEdge(name string) error {
	switch name {
	case appuser.EdgeApp:
		m.ClearApp()
		return nil
	case appuser.EdgeAdminuser:
		m.ClearAdminuser()
		return nil
	case appuser.EdgeAppRole:
		m.ClearAppRole()
		return nil
	}
	return fmt.Errorf("unknown AppUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AppUserMutation) ResetEdge(name string) error {
	switch name {
	case appuser.EdgeApp:
		m.ResetApp()
		return nil
	case appuser.EdgeAdminuser:
		m.ResetAdminuser()
		return nil
	case appuser.EdgeAppRole:
		m.ResetAppRole()
		return nil
	}
	return fmt.Errorf("unknown AppUser edge %s", name)
}

// KacheMutation represents an operation that mutates the Kache nodes in the graph.
type KacheMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	key           *string
	value         *string
	expires       *int
	addexpires    *int
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Kache, error)
	predicates    []predicate.Kache
}

var _ ent.Mutation = (*KacheMutation)(nil)

// kacheOption allows management of the mutation configuration using functional options.
type kacheOption func(*KacheMutation)

// newKacheMutation creates new mutation for the Kache entity.
func newKacheMutation(c config, op Op, opts ...kacheOption) *KacheMutation {
	m := &KacheMutation{
		config:        c,
		op:            op,
		typ:           TypeKache,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKacheID sets the ID field of the mutation.
func withKacheID(id string) kacheOption {
	return func(m *KacheMutation) {
		var (
			err   error
			once  sync.Once
			value *Kache
		)
		m.oldValue = func(ctx context.Context) (*Kache, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Kache.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKache sets the old Kache of the mutation.
func withKache(node *Kache) kacheOption {
	return func(m *KacheMutation) {
		m.oldValue = func(context.Context) (*Kache, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KacheMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KacheMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Kache entities.
func (m *KacheMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KacheMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KacheMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Kache.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *KacheMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KacheMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Kache entity.
// If the Kache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KacheMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KacheMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[kache.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KacheMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[kache.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KacheMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, kache.FieldCreatedAt)
}

// SetKey sets the "key" field.
func (m *KacheMutation) SetKey(s string) {
	m.key = &s
}

// Key returns the value of the "key" field in the mutation.
func (m *KacheMutation) Key() (r string, exists bool) {
	v := m.key
	if v == nil {
		return
	}
	return *v, true
}

// OldKey returns the old "key" field's value of the Kache entity.
// If the Kache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KacheMutation) OldKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKey: %w", err)
	}
	return oldValue.Key, nil
}

// ResetKey resets all changes to the "key" field.
func (m *KacheMutation) ResetKey() {
	m.key = nil
}

// SetValue sets the "value" field.
func (m *KacheMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *KacheMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Kache entity.
// If the Kache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KacheMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *KacheMutation) ClearValue() {
	m.value = nil
	m.clearedFields[kache.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *KacheMutation) ValueCleared() bool {
	_, ok := m.clearedFields[kache.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *KacheMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, kache.FieldValue)
}

// SetExpires sets the "expires" field.
func (m *KacheMutation) SetExpires(i int) {
	m.expires = &i
	m.addexpires = nil
}

// Expires returns the value of the "expires" field in the mutation.
func (m *KacheMutation) Expires() (r int, exists bool) {
	v := m.expires
	if v == nil {
		return
	}
	return *v, true
}

// OldExpires returns the old "expires" field's value of the Kache entity.
// If the Kache object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KacheMutation) OldExpires(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpires is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpires requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpires: %w", err)
	}
	return oldValue.Expires, nil
}

// AddExpires adds i to the "expires" field.
func (m *KacheMutation) AddExpires(i int) {
	if m.addexpires != nil {
		*m.addexpires += i
	} else {
		m.addexpires = &i
	}
}

// AddedExpires returns the value that was added to the "expires" field in this mutation.
func (m *KacheMutation) AddedExpires() (r int, exists bool) {
	v := m.addexpires
	if v == nil {
		return
	}
	return *v, true
}

// ClearExpires clears the value of the "expires" field.
func (m *KacheMutation) ClearExpires() {
	m.expires = nil
	m.addexpires = nil
	m.clearedFields[kache.FieldExpires] = struct{}{}
}

// ExpiresCleared returns if the "expires" field was cleared in this mutation.
func (m *KacheMutation) ExpiresCleared() bool {
	_, ok := m.clearedFields[kache.FieldExpires]
	return ok
}

// ResetExpires resets all changes to the "expires" field.
func (m *KacheMutation) ResetExpires() {
	m.expires = nil
	m.addexpires = nil
	delete(m.clearedFields, kache.FieldExpires)
}

// Where appends a list predicates to the KacheMutation builder.
func (m *KacheMutation) Where(ps ...predicate.Kache) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KacheMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KacheMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Kache, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KacheMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KacheMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Kache).
func (m *KacheMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KacheMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.created_at != nil {
		fields = append(fields, kache.FieldCreatedAt)
	}
	if m.key != nil {
		fields = append(fields, kache.FieldKey)
	}
	if m.value != nil {
		fields = append(fields, kache.FieldValue)
	}
	if m.expires != nil {
		fields = append(fields, kache.FieldExpires)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KacheMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case kache.FieldCreatedAt:
		return m.CreatedAt()
	case kache.FieldKey:
		return m.Key()
	case kache.FieldValue:
		return m.Value()
	case kache.FieldExpires:
		return m.Expires()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KacheMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case kache.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case kache.FieldKey:
		return m.OldKey(ctx)
	case kache.FieldValue:
		return m.OldValue(ctx)
	case kache.FieldExpires:
		return m.OldExpires(ctx)
	}
	return nil, fmt.Errorf("unknown Kache field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KacheMutation) SetField(name string, value ent.Value) error {
	switch name {
	case kache.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case kache.FieldKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKey(v)
		return nil
	case kache.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case kache.FieldExpires:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpires(v)
		return nil
	}
	return fmt.Errorf("unknown Kache field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KacheMutation) AddedFields() []string {
	var fields []string
	if m.addexpires != nil {
		fields = append(fields, kache.FieldExpires)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KacheMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case kache.FieldExpires:
		return m.AddedExpires()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KacheMutation) AddField(name string, value ent.Value) error {
	switch name {
	case kache.FieldExpires:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddExpires(v)
		return nil
	}
	return fmt.Errorf("unknown Kache numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KacheMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(kache.FieldCreatedAt) {
		fields = append(fields, kache.FieldCreatedAt)
	}
	if m.FieldCleared(kache.FieldValue) {
		fields = append(fields, kache.FieldValue)
	}
	if m.FieldCleared(kache.FieldExpires) {
		fields = append(fields, kache.FieldExpires)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KacheMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KacheMutation) ClearField(name string) error {
	switch name {
	case kache.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case kache.FieldValue:
		m.ClearValue()
		return nil
	case kache.FieldExpires:
		m.ClearExpires()
		return nil
	}
	return fmt.Errorf("unknown Kache nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KacheMutation) ResetField(name string) error {
	switch name {
	case kache.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case kache.FieldKey:
		m.ResetKey()
		return nil
	case kache.FieldValue:
		m.ResetValue()
		return nil
	case kache.FieldExpires:
		m.ResetExpires()
		return nil
	}
	return fmt.Errorf("unknown Kache field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KacheMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KacheMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KacheMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KacheMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KacheMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KacheMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KacheMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Kache unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KacheMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Kache edge %s", name)
}

// KeyvalueMutation represents an operation that mutates the Keyvalue nodes in the graph.
type KeyvalueMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	value         *string
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Keyvalue, error)
	predicates    []predicate.Keyvalue
}

var _ ent.Mutation = (*KeyvalueMutation)(nil)

// keyvalueOption allows management of the mutation configuration using functional options.
type keyvalueOption func(*KeyvalueMutation)

// newKeyvalueMutation creates new mutation for the Keyvalue entity.
func newKeyvalueMutation(c config, op Op, opts ...keyvalueOption) *KeyvalueMutation {
	m := &KeyvalueMutation{
		config:        c,
		op:            op,
		typ:           TypeKeyvalue,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withKeyvalueID sets the ID field of the mutation.
func withKeyvalueID(id string) keyvalueOption {
	return func(m *KeyvalueMutation) {
		var (
			err   error
			once  sync.Once
			value *Keyvalue
		)
		m.oldValue = func(ctx context.Context) (*Keyvalue, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Keyvalue.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withKeyvalue sets the old Keyvalue of the mutation.
func withKeyvalue(node *Keyvalue) keyvalueOption {
	return func(m *KeyvalueMutation) {
		m.oldValue = func(context.Context) (*Keyvalue, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m KeyvalueMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m KeyvalueMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Keyvalue entities.
func (m *KeyvalueMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *KeyvalueMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *KeyvalueMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Keyvalue.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *KeyvalueMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *KeyvalueMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Keyvalue entity.
// If the Keyvalue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeyvalueMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *KeyvalueMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[keyvalue.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *KeyvalueMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[keyvalue.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *KeyvalueMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, keyvalue.FieldCreatedAt)
}

// SetValue sets the "value" field.
func (m *KeyvalueMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *KeyvalueMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Keyvalue entity.
// If the Keyvalue object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *KeyvalueMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ClearValue clears the value of the "value" field.
func (m *KeyvalueMutation) ClearValue() {
	m.value = nil
	m.clearedFields[keyvalue.FieldValue] = struct{}{}
}

// ValueCleared returns if the "value" field was cleared in this mutation.
func (m *KeyvalueMutation) ValueCleared() bool {
	_, ok := m.clearedFields[keyvalue.FieldValue]
	return ok
}

// ResetValue resets all changes to the "value" field.
func (m *KeyvalueMutation) ResetValue() {
	m.value = nil
	delete(m.clearedFields, keyvalue.FieldValue)
}

// Where appends a list predicates to the KeyvalueMutation builder.
func (m *KeyvalueMutation) Where(ps ...predicate.Keyvalue) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the KeyvalueMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *KeyvalueMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Keyvalue, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *KeyvalueMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *KeyvalueMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Keyvalue).
func (m *KeyvalueMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *KeyvalueMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.created_at != nil {
		fields = append(fields, keyvalue.FieldCreatedAt)
	}
	if m.value != nil {
		fields = append(fields, keyvalue.FieldValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *KeyvalueMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case keyvalue.FieldCreatedAt:
		return m.CreatedAt()
	case keyvalue.FieldValue:
		return m.Value()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *KeyvalueMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case keyvalue.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case keyvalue.FieldValue:
		return m.OldValue(ctx)
	}
	return nil, fmt.Errorf("unknown Keyvalue field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeyvalueMutation) SetField(name string, value ent.Value) error {
	switch name {
	case keyvalue.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case keyvalue.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	}
	return fmt.Errorf("unknown Keyvalue field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *KeyvalueMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *KeyvalueMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *KeyvalueMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Keyvalue numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *KeyvalueMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(keyvalue.FieldCreatedAt) {
		fields = append(fields, keyvalue.FieldCreatedAt)
	}
	if m.FieldCleared(keyvalue.FieldValue) {
		fields = append(fields, keyvalue.FieldValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *KeyvalueMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *KeyvalueMutation) ClearField(name string) error {
	switch name {
	case keyvalue.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case keyvalue.FieldValue:
		m.ClearValue()
		return nil
	}
	return fmt.Errorf("unknown Keyvalue nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *KeyvalueMutation) ResetField(name string) error {
	switch name {
	case keyvalue.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case keyvalue.FieldValue:
		m.ResetValue()
		return nil
	}
	return fmt.Errorf("unknown Keyvalue field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *KeyvalueMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *KeyvalueMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *KeyvalueMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *KeyvalueMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *KeyvalueMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *KeyvalueMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *KeyvalueMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Keyvalue unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *KeyvalueMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Keyvalue edge %s", name)
}

// MailConnMutation represents an operation that mutates the MailConn nodes in the graph.
type MailConnMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	app_id        *string
	name          *string
	host          *string
	port          *int
	addport       *int
	username      *string
	password      *string
	encryption    *int
	addencryption *int
	from_name     *string
	from_email    *string
	status        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*MailConn, error)
	predicates    []predicate.MailConn
}

var _ ent.Mutation = (*MailConnMutation)(nil)

// mailconnOption allows management of the mutation configuration using functional options.
type mailconnOption func(*MailConnMutation)

// newMailConnMutation creates new mutation for the MailConn entity.
func newMailConnMutation(c config, op Op, opts ...mailconnOption) *MailConnMutation {
	m := &MailConnMutation{
		config:        c,
		op:            op,
		typ:           TypeMailConn,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMailConnID sets the ID field of the mutation.
func withMailConnID(id string) mailconnOption {
	return func(m *MailConnMutation) {
		var (
			err   error
			once  sync.Once
			value *MailConn
		)
		m.oldValue = func(ctx context.Context) (*MailConn, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().MailConn.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMailConn sets the old MailConn of the mutation.
func withMailConn(node *MailConn) mailconnOption {
	return func(m *MailConnMutation) {
		m.oldValue = func(context.Context) (*MailConn, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MailConnMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MailConnMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of MailConn entities.
func (m *MailConnMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MailConnMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MailConnMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().MailConn.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MailConnMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MailConnMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MailConnMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[mailconn.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MailConnMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MailConnMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, mailconn.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MailConnMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MailConnMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MailConnMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[mailconn.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MailConnMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MailConnMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, mailconn.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *MailConnMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *MailConnMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *MailConnMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[mailconn.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *MailConnMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *MailConnMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, mailconn.FieldAppID)
}

// SetName sets the "name" field.
func (m *MailConnMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MailConnMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MailConnMutation) ClearName() {
	m.name = nil
	m.clearedFields[mailconn.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MailConnMutation) NameCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MailConnMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, mailconn.FieldName)
}

// SetHost sets the "host" field.
func (m *MailConnMutation) SetHost(s string) {
	m.host = &s
}

// Host returns the value of the "host" field in the mutation.
func (m *MailConnMutation) Host() (r string, exists bool) {
	v := m.host
	if v == nil {
		return
	}
	return *v, true
}

// OldHost returns the old "host" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHost: %w", err)
	}
	return oldValue.Host, nil
}

// ClearHost clears the value of the "host" field.
func (m *MailConnMutation) ClearHost() {
	m.host = nil
	m.clearedFields[mailconn.FieldHost] = struct{}{}
}

// HostCleared returns if the "host" field was cleared in this mutation.
func (m *MailConnMutation) HostCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldHost]
	return ok
}

// ResetHost resets all changes to the "host" field.
func (m *MailConnMutation) ResetHost() {
	m.host = nil
	delete(m.clearedFields, mailconn.FieldHost)
}

// SetPort sets the "port" field.
func (m *MailConnMutation) SetPort(i int) {
	m.port = &i
	m.addport = nil
}

// Port returns the value of the "port" field in the mutation.
func (m *MailConnMutation) Port() (r int, exists bool) {
	v := m.port
	if v == nil {
		return
	}
	return *v, true
}

// OldPort returns the old "port" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPort: %w", err)
	}
	return oldValue.Port, nil
}

// AddPort adds i to the "port" field.
func (m *MailConnMutation) AddPort(i int) {
	if m.addport != nil {
		*m.addport += i
	} else {
		m.addport = &i
	}
}

// AddedPort returns the value that was added to the "port" field in this mutation.
func (m *MailConnMutation) AddedPort() (r int, exists bool) {
	v := m.addport
	if v == nil {
		return
	}
	return *v, true
}

// ClearPort clears the value of the "port" field.
func (m *MailConnMutation) ClearPort() {
	m.port = nil
	m.addport = nil
	m.clearedFields[mailconn.FieldPort] = struct{}{}
}

// PortCleared returns if the "port" field was cleared in this mutation.
func (m *MailConnMutation) PortCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldPort]
	return ok
}

// ResetPort resets all changes to the "port" field.
func (m *MailConnMutation) ResetPort() {
	m.port = nil
	m.addport = nil
	delete(m.clearedFields, mailconn.FieldPort)
}

// SetUsername sets the "username" field.
func (m *MailConnMutation) SetUsername(s string) {
	m.username = &s
}

// Username returns the value of the "username" field in the mutation.
func (m *MailConnMutation) Username() (r string, exists bool) {
	v := m.username
	if v == nil {
		return
	}
	return *v, true
}

// OldUsername returns the old "username" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUsername: %w", err)
	}
	return oldValue.Username, nil
}

// ClearUsername clears the value of the "username" field.
func (m *MailConnMutation) ClearUsername() {
	m.username = nil
	m.clearedFields[mailconn.FieldUsername] = struct{}{}
}

// UsernameCleared returns if the "username" field was cleared in this mutation.
func (m *MailConnMutation) UsernameCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldUsername]
	return ok
}

// ResetUsername resets all changes to the "username" field.
func (m *MailConnMutation) ResetUsername() {
	m.username = nil
	delete(m.clearedFields, mailconn.FieldUsername)
}

// SetPassword sets the "password" field.
func (m *MailConnMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *MailConnMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *MailConnMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[mailconn.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *MailConnMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *MailConnMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, mailconn.FieldPassword)
}

// SetEncryption sets the "encryption" field.
func (m *MailConnMutation) SetEncryption(i int) {
	m.encryption = &i
	m.addencryption = nil
}

// Encryption returns the value of the "encryption" field in the mutation.
func (m *MailConnMutation) Encryption() (r int, exists bool) {
	v := m.encryption
	if v == nil {
		return
	}
	return *v, true
}

// OldEncryption returns the old "encryption" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldEncryption(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEncryption is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEncryption requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEncryption: %w", err)
	}
	return oldValue.Encryption, nil
}

// AddEncryption adds i to the "encryption" field.
func (m *MailConnMutation) AddEncryption(i int) {
	if m.addencryption != nil {
		*m.addencryption += i
	} else {
		m.addencryption = &i
	}
}

// AddedEncryption returns the value that was added to the "encryption" field in this mutation.
func (m *MailConnMutation) AddedEncryption() (r int, exists bool) {
	v := m.addencryption
	if v == nil {
		return
	}
	return *v, true
}

// ClearEncryption clears the value of the "encryption" field.
func (m *MailConnMutation) ClearEncryption() {
	m.encryption = nil
	m.addencryption = nil
	m.clearedFields[mailconn.FieldEncryption] = struct{}{}
}

// EncryptionCleared returns if the "encryption" field was cleared in this mutation.
func (m *MailConnMutation) EncryptionCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldEncryption]
	return ok
}

// ResetEncryption resets all changes to the "encryption" field.
func (m *MailConnMutation) ResetEncryption() {
	m.encryption = nil
	m.addencryption = nil
	delete(m.clearedFields, mailconn.FieldEncryption)
}

// SetFromName sets the "from_name" field.
func (m *MailConnMutation) SetFromName(s string) {
	m.from_name = &s
}

// FromName returns the value of the "from_name" field in the mutation.
func (m *MailConnMutation) FromName() (r string, exists bool) {
	v := m.from_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFromName returns the old "from_name" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldFromName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromName: %w", err)
	}
	return oldValue.FromName, nil
}

// ClearFromName clears the value of the "from_name" field.
func (m *MailConnMutation) ClearFromName() {
	m.from_name = nil
	m.clearedFields[mailconn.FieldFromName] = struct{}{}
}

// FromNameCleared returns if the "from_name" field was cleared in this mutation.
func (m *MailConnMutation) FromNameCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldFromName]
	return ok
}

// ResetFromName resets all changes to the "from_name" field.
func (m *MailConnMutation) ResetFromName() {
	m.from_name = nil
	delete(m.clearedFields, mailconn.FieldFromName)
}

// SetFromEmail sets the "from_email" field.
func (m *MailConnMutation) SetFromEmail(s string) {
	m.from_email = &s
}

// FromEmail returns the value of the "from_email" field in the mutation.
func (m *MailConnMutation) FromEmail() (r string, exists bool) {
	v := m.from_email
	if v == nil {
		return
	}
	return *v, true
}

// OldFromEmail returns the old "from_email" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldFromEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFromEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFromEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFromEmail: %w", err)
	}
	return oldValue.FromEmail, nil
}

// ClearFromEmail clears the value of the "from_email" field.
func (m *MailConnMutation) ClearFromEmail() {
	m.from_email = nil
	m.clearedFields[mailconn.FieldFromEmail] = struct{}{}
}

// FromEmailCleared returns if the "from_email" field was cleared in this mutation.
func (m *MailConnMutation) FromEmailCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldFromEmail]
	return ok
}

// ResetFromEmail resets all changes to the "from_email" field.
func (m *MailConnMutation) ResetFromEmail() {
	m.from_email = nil
	delete(m.clearedFields, mailconn.FieldFromEmail)
}

// SetStatus sets the "status" field.
func (m *MailConnMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *MailConnMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the MailConn entity.
// If the MailConn object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailConnMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MailConnMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[mailconn.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MailConnMutation) StatusCleared() bool {
	_, ok := m.clearedFields[mailconn.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MailConnMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, mailconn.FieldStatus)
}

// Where appends a list predicates to the MailConnMutation builder.
func (m *MailConnMutation) Where(ps ...predicate.MailConn) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MailConnMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MailConnMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.MailConn, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MailConnMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MailConnMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (MailConn).
func (m *MailConnMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MailConnMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, mailconn.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, mailconn.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, mailconn.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, mailconn.FieldName)
	}
	if m.host != nil {
		fields = append(fields, mailconn.FieldHost)
	}
	if m.port != nil {
		fields = append(fields, mailconn.FieldPort)
	}
	if m.username != nil {
		fields = append(fields, mailconn.FieldUsername)
	}
	if m.password != nil {
		fields = append(fields, mailconn.FieldPassword)
	}
	if m.encryption != nil {
		fields = append(fields, mailconn.FieldEncryption)
	}
	if m.from_name != nil {
		fields = append(fields, mailconn.FieldFromName)
	}
	if m.from_email != nil {
		fields = append(fields, mailconn.FieldFromEmail)
	}
	if m.status != nil {
		fields = append(fields, mailconn.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MailConnMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mailconn.FieldCreatedAt:
		return m.CreatedAt()
	case mailconn.FieldUpdatedAt:
		return m.UpdatedAt()
	case mailconn.FieldAppID:
		return m.AppID()
	case mailconn.FieldName:
		return m.Name()
	case mailconn.FieldHost:
		return m.Host()
	case mailconn.FieldPort:
		return m.Port()
	case mailconn.FieldUsername:
		return m.Username()
	case mailconn.FieldPassword:
		return m.Password()
	case mailconn.FieldEncryption:
		return m.Encryption()
	case mailconn.FieldFromName:
		return m.FromName()
	case mailconn.FieldFromEmail:
		return m.FromEmail()
	case mailconn.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MailConnMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mailconn.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mailconn.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mailconn.FieldAppID:
		return m.OldAppID(ctx)
	case mailconn.FieldName:
		return m.OldName(ctx)
	case mailconn.FieldHost:
		return m.OldHost(ctx)
	case mailconn.FieldPort:
		return m.OldPort(ctx)
	case mailconn.FieldUsername:
		return m.OldUsername(ctx)
	case mailconn.FieldPassword:
		return m.OldPassword(ctx)
	case mailconn.FieldEncryption:
		return m.OldEncryption(ctx)
	case mailconn.FieldFromName:
		return m.OldFromName(ctx)
	case mailconn.FieldFromEmail:
		return m.OldFromEmail(ctx)
	case mailconn.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown MailConn field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MailConnMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mailconn.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mailconn.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mailconn.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case mailconn.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case mailconn.FieldHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHost(v)
		return nil
	case mailconn.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPort(v)
		return nil
	case mailconn.FieldUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUsername(v)
		return nil
	case mailconn.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case mailconn.FieldEncryption:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEncryption(v)
		return nil
	case mailconn.FieldFromName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromName(v)
		return nil
	case mailconn.FieldFromEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFromEmail(v)
		return nil
	case mailconn.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown MailConn field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MailConnMutation) AddedFields() []string {
	var fields []string
	if m.addport != nil {
		fields = append(fields, mailconn.FieldPort)
	}
	if m.addencryption != nil {
		fields = append(fields, mailconn.FieldEncryption)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MailConnMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mailconn.FieldPort:
		return m.AddedPort()
	case mailconn.FieldEncryption:
		return m.AddedEncryption()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MailConnMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mailconn.FieldPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPort(v)
		return nil
	case mailconn.FieldEncryption:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddEncryption(v)
		return nil
	}
	return fmt.Errorf("unknown MailConn numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MailConnMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mailconn.FieldCreatedAt) {
		fields = append(fields, mailconn.FieldCreatedAt)
	}
	if m.FieldCleared(mailconn.FieldUpdatedAt) {
		fields = append(fields, mailconn.FieldUpdatedAt)
	}
	if m.FieldCleared(mailconn.FieldAppID) {
		fields = append(fields, mailconn.FieldAppID)
	}
	if m.FieldCleared(mailconn.FieldName) {
		fields = append(fields, mailconn.FieldName)
	}
	if m.FieldCleared(mailconn.FieldHost) {
		fields = append(fields, mailconn.FieldHost)
	}
	if m.FieldCleared(mailconn.FieldPort) {
		fields = append(fields, mailconn.FieldPort)
	}
	if m.FieldCleared(mailconn.FieldUsername) {
		fields = append(fields, mailconn.FieldUsername)
	}
	if m.FieldCleared(mailconn.FieldPassword) {
		fields = append(fields, mailconn.FieldPassword)
	}
	if m.FieldCleared(mailconn.FieldEncryption) {
		fields = append(fields, mailconn.FieldEncryption)
	}
	if m.FieldCleared(mailconn.FieldFromName) {
		fields = append(fields, mailconn.FieldFromName)
	}
	if m.FieldCleared(mailconn.FieldFromEmail) {
		fields = append(fields, mailconn.FieldFromEmail)
	}
	if m.FieldCleared(mailconn.FieldStatus) {
		fields = append(fields, mailconn.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MailConnMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MailConnMutation) ClearField(name string) error {
	switch name {
	case mailconn.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case mailconn.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case mailconn.FieldAppID:
		m.ClearAppID()
		return nil
	case mailconn.FieldName:
		m.ClearName()
		return nil
	case mailconn.FieldHost:
		m.ClearHost()
		return nil
	case mailconn.FieldPort:
		m.ClearPort()
		return nil
	case mailconn.FieldUsername:
		m.ClearUsername()
		return nil
	case mailconn.FieldPassword:
		m.ClearPassword()
		return nil
	case mailconn.FieldEncryption:
		m.ClearEncryption()
		return nil
	case mailconn.FieldFromName:
		m.ClearFromName()
		return nil
	case mailconn.FieldFromEmail:
		m.ClearFromEmail()
		return nil
	case mailconn.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown MailConn nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MailConnMutation) ResetField(name string) error {
	switch name {
	case mailconn.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mailconn.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mailconn.FieldAppID:
		m.ResetAppID()
		return nil
	case mailconn.FieldName:
		m.ResetName()
		return nil
	case mailconn.FieldHost:
		m.ResetHost()
		return nil
	case mailconn.FieldPort:
		m.ResetPort()
		return nil
	case mailconn.FieldUsername:
		m.ResetUsername()
		return nil
	case mailconn.FieldPassword:
		m.ResetPassword()
		return nil
	case mailconn.FieldEncryption:
		m.ResetEncryption()
		return nil
	case mailconn.FieldFromName:
		m.ResetFromName()
		return nil
	case mailconn.FieldFromEmail:
		m.ResetFromEmail()
		return nil
	case mailconn.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown MailConn field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MailConnMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MailConnMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MailConnMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MailConnMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MailConnMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MailConnMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MailConnMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown MailConn unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MailConnMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown MailConn edge %s", name)
}

// MediaMutation represents an operation that mutates the Media nodes in the graph.
type MediaMutation struct {
	config
	op                Op
	typ               string
	id                *string
	created_at        *time.Time
	updated_at        *time.Time
	app_id            *string
	disk              *string
	directory         *string
	name              *string
	original_name     *string
	extension         *string
	mime_type         *string
	aggregate_type    *string
	size              *uint
	addsize           *int
	description       *string
	is_variant        *bool
	variant_name      *string
	original_media_id *string
	checksum          *string
	workspace_id      *string
	alt               *string
	uid               *string
	status            *bool
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Media, error)
	predicates        []predicate.Media
}

var _ ent.Mutation = (*MediaMutation)(nil)

// mediaOption allows management of the mutation configuration using functional options.
type mediaOption func(*MediaMutation)

// newMediaMutation creates new mutation for the Media entity.
func newMediaMutation(c config, op Op, opts ...mediaOption) *MediaMutation {
	m := &MediaMutation{
		config:        c,
		op:            op,
		typ:           TypeMedia,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMediaID sets the ID field of the mutation.
func withMediaID(id string) mediaOption {
	return func(m *MediaMutation) {
		var (
			err   error
			once  sync.Once
			value *Media
		)
		m.oldValue = func(ctx context.Context) (*Media, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Media.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedia sets the old Media of the mutation.
func withMedia(node *Media) mediaOption {
	return func(m *MediaMutation) {
		m.oldValue = func(context.Context) (*Media, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MediaMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MediaMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Media entities.
func (m *MediaMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MediaMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MediaMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Media.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MediaMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MediaMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *MediaMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[media.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *MediaMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[media.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MediaMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, media.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MediaMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MediaMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *MediaMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[media.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *MediaMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[media.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MediaMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, media.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *MediaMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *MediaMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *MediaMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[media.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *MediaMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[media.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *MediaMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, media.FieldAppID)
}

// SetDisk sets the "disk" field.
func (m *MediaMutation) SetDisk(s string) {
	m.disk = &s
}

// Disk returns the value of the "disk" field in the mutation.
func (m *MediaMutation) Disk() (r string, exists bool) {
	v := m.disk
	if v == nil {
		return
	}
	return *v, true
}

// OldDisk returns the old "disk" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDisk(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDisk is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDisk requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDisk: %w", err)
	}
	return oldValue.Disk, nil
}

// ClearDisk clears the value of the "disk" field.
func (m *MediaMutation) ClearDisk() {
	m.disk = nil
	m.clearedFields[media.FieldDisk] = struct{}{}
}

// DiskCleared returns if the "disk" field was cleared in this mutation.
func (m *MediaMutation) DiskCleared() bool {
	_, ok := m.clearedFields[media.FieldDisk]
	return ok
}

// ResetDisk resets all changes to the "disk" field.
func (m *MediaMutation) ResetDisk() {
	m.disk = nil
	delete(m.clearedFields, media.FieldDisk)
}

// SetDirectory sets the "directory" field.
func (m *MediaMutation) SetDirectory(s string) {
	m.directory = &s
}

// Directory returns the value of the "directory" field in the mutation.
func (m *MediaMutation) Directory() (r string, exists bool) {
	v := m.directory
	if v == nil {
		return
	}
	return *v, true
}

// OldDirectory returns the old "directory" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDirectory(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDirectory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDirectory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDirectory: %w", err)
	}
	return oldValue.Directory, nil
}

// ClearDirectory clears the value of the "directory" field.
func (m *MediaMutation) ClearDirectory() {
	m.directory = nil
	m.clearedFields[media.FieldDirectory] = struct{}{}
}

// DirectoryCleared returns if the "directory" field was cleared in this mutation.
func (m *MediaMutation) DirectoryCleared() bool {
	_, ok := m.clearedFields[media.FieldDirectory]
	return ok
}

// ResetDirectory resets all changes to the "directory" field.
func (m *MediaMutation) ResetDirectory() {
	m.directory = nil
	delete(m.clearedFields, media.FieldDirectory)
}

// SetName sets the "name" field.
func (m *MediaMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *MediaMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *MediaMutation) ClearName() {
	m.name = nil
	m.clearedFields[media.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *MediaMutation) NameCleared() bool {
	_, ok := m.clearedFields[media.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *MediaMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, media.FieldName)
}

// SetOriginalName sets the "original_name" field.
func (m *MediaMutation) SetOriginalName(s string) {
	m.original_name = &s
}

// OriginalName returns the value of the "original_name" field in the mutation.
func (m *MediaMutation) OriginalName() (r string, exists bool) {
	v := m.original_name
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalName returns the old "original_name" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldOriginalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalName: %w", err)
	}
	return oldValue.OriginalName, nil
}

// ClearOriginalName clears the value of the "original_name" field.
func (m *MediaMutation) ClearOriginalName() {
	m.original_name = nil
	m.clearedFields[media.FieldOriginalName] = struct{}{}
}

// OriginalNameCleared returns if the "original_name" field was cleared in this mutation.
func (m *MediaMutation) OriginalNameCleared() bool {
	_, ok := m.clearedFields[media.FieldOriginalName]
	return ok
}

// ResetOriginalName resets all changes to the "original_name" field.
func (m *MediaMutation) ResetOriginalName() {
	m.original_name = nil
	delete(m.clearedFields, media.FieldOriginalName)
}

// SetExtension sets the "extension" field.
func (m *MediaMutation) SetExtension(s string) {
	m.extension = &s
}

// Extension returns the value of the "extension" field in the mutation.
func (m *MediaMutation) Extension() (r string, exists bool) {
	v := m.extension
	if v == nil {
		return
	}
	return *v, true
}

// OldExtension returns the old "extension" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldExtension(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExtension is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExtension requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExtension: %w", err)
	}
	return oldValue.Extension, nil
}

// ClearExtension clears the value of the "extension" field.
func (m *MediaMutation) ClearExtension() {
	m.extension = nil
	m.clearedFields[media.FieldExtension] = struct{}{}
}

// ExtensionCleared returns if the "extension" field was cleared in this mutation.
func (m *MediaMutation) ExtensionCleared() bool {
	_, ok := m.clearedFields[media.FieldExtension]
	return ok
}

// ResetExtension resets all changes to the "extension" field.
func (m *MediaMutation) ResetExtension() {
	m.extension = nil
	delete(m.clearedFields, media.FieldExtension)
}

// SetMimeType sets the "mime_type" field.
func (m *MediaMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *MediaMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *MediaMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[media.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *MediaMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[media.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *MediaMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, media.FieldMimeType)
}

// SetAggregateType sets the "aggregate_type" field.
func (m *MediaMutation) SetAggregateType(s string) {
	m.aggregate_type = &s
}

// AggregateType returns the value of the "aggregate_type" field in the mutation.
func (m *MediaMutation) AggregateType() (r string, exists bool) {
	v := m.aggregate_type
	if v == nil {
		return
	}
	return *v, true
}

// OldAggregateType returns the old "aggregate_type" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldAggregateType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAggregateType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAggregateType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAggregateType: %w", err)
	}
	return oldValue.AggregateType, nil
}

// ClearAggregateType clears the value of the "aggregate_type" field.
func (m *MediaMutation) ClearAggregateType() {
	m.aggregate_type = nil
	m.clearedFields[media.FieldAggregateType] = struct{}{}
}

// AggregateTypeCleared returns if the "aggregate_type" field was cleared in this mutation.
func (m *MediaMutation) AggregateTypeCleared() bool {
	_, ok := m.clearedFields[media.FieldAggregateType]
	return ok
}

// ResetAggregateType resets all changes to the "aggregate_type" field.
func (m *MediaMutation) ResetAggregateType() {
	m.aggregate_type = nil
	delete(m.clearedFields, media.FieldAggregateType)
}

// SetSize sets the "size" field.
func (m *MediaMutation) SetSize(u uint) {
	m.size = &u
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *MediaMutation) Size() (r uint, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldSize(ctx context.Context) (v uint, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds u to the "size" field.
func (m *MediaMutation) AddSize(u int) {
	if m.addsize != nil {
		*m.addsize += u
	} else {
		m.addsize = &u
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *MediaMutation) AddedSize() (r int, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *MediaMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[media.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *MediaMutation) SizeCleared() bool {
	_, ok := m.clearedFields[media.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *MediaMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, media.FieldSize)
}

// SetDescription sets the "description" field.
func (m *MediaMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *MediaMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *MediaMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[media.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *MediaMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[media.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *MediaMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, media.FieldDescription)
}

// SetIsVariant sets the "is_variant" field.
func (m *MediaMutation) SetIsVariant(b bool) {
	m.is_variant = &b
}

// IsVariant returns the value of the "is_variant" field in the mutation.
func (m *MediaMutation) IsVariant() (r bool, exists bool) {
	v := m.is_variant
	if v == nil {
		return
	}
	return *v, true
}

// OldIsVariant returns the old "is_variant" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldIsVariant(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsVariant is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsVariant requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsVariant: %w", err)
	}
	return oldValue.IsVariant, nil
}

// ClearIsVariant clears the value of the "is_variant" field.
func (m *MediaMutation) ClearIsVariant() {
	m.is_variant = nil
	m.clearedFields[media.FieldIsVariant] = struct{}{}
}

// IsVariantCleared returns if the "is_variant" field was cleared in this mutation.
func (m *MediaMutation) IsVariantCleared() bool {
	_, ok := m.clearedFields[media.FieldIsVariant]
	return ok
}

// ResetIsVariant resets all changes to the "is_variant" field.
func (m *MediaMutation) ResetIsVariant() {
	m.is_variant = nil
	delete(m.clearedFields, media.FieldIsVariant)
}

// SetVariantName sets the "variant_name" field.
func (m *MediaMutation) SetVariantName(s string) {
	m.variant_name = &s
}

// VariantName returns the value of the "variant_name" field in the mutation.
func (m *MediaMutation) VariantName() (r string, exists bool) {
	v := m.variant_name
	if v == nil {
		return
	}
	return *v, true
}

// OldVariantName returns the old "variant_name" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldVariantName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVariantName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVariantName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVariantName: %w", err)
	}
	return oldValue.VariantName, nil
}

// ClearVariantName clears the value of the "variant_name" field.
func (m *MediaMutation) ClearVariantName() {
	m.variant_name = nil
	m.clearedFields[media.FieldVariantName] = struct{}{}
}

// VariantNameCleared returns if the "variant_name" field was cleared in this mutation.
func (m *MediaMutation) VariantNameCleared() bool {
	_, ok := m.clearedFields[media.FieldVariantName]
	return ok
}

// ResetVariantName resets all changes to the "variant_name" field.
func (m *MediaMutation) ResetVariantName() {
	m.variant_name = nil
	delete(m.clearedFields, media.FieldVariantName)
}

// SetOriginalMediaID sets the "original_media_id" field.
func (m *MediaMutation) SetOriginalMediaID(s string) {
	m.original_media_id = &s
}

// OriginalMediaID returns the value of the "original_media_id" field in the mutation.
func (m *MediaMutation) OriginalMediaID() (r string, exists bool) {
	v := m.original_media_id
	if v == nil {
		return
	}
	return *v, true
}

// OldOriginalMediaID returns the old "original_media_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldOriginalMediaID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOriginalMediaID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOriginalMediaID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOriginalMediaID: %w", err)
	}
	return oldValue.OriginalMediaID, nil
}

// ClearOriginalMediaID clears the value of the "original_media_id" field.
func (m *MediaMutation) ClearOriginalMediaID() {
	m.original_media_id = nil
	m.clearedFields[media.FieldOriginalMediaID] = struct{}{}
}

// OriginalMediaIDCleared returns if the "original_media_id" field was cleared in this mutation.
func (m *MediaMutation) OriginalMediaIDCleared() bool {
	_, ok := m.clearedFields[media.FieldOriginalMediaID]
	return ok
}

// ResetOriginalMediaID resets all changes to the "original_media_id" field.
func (m *MediaMutation) ResetOriginalMediaID() {
	m.original_media_id = nil
	delete(m.clearedFields, media.FieldOriginalMediaID)
}

// SetChecksum sets the "checksum" field.
func (m *MediaMutation) SetChecksum(s string) {
	m.checksum = &s
}

// Checksum returns the value of the "checksum" field in the mutation.
func (m *MediaMutation) Checksum() (r string, exists bool) {
	v := m.checksum
	if v == nil {
		return
	}
	return *v, true
}

// OldChecksum returns the old "checksum" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldChecksum(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldChecksum is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldChecksum requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldChecksum: %w", err)
	}
	return oldValue.Checksum, nil
}

// ClearChecksum clears the value of the "checksum" field.
func (m *MediaMutation) ClearChecksum() {
	m.checksum = nil
	m.clearedFields[media.FieldChecksum] = struct{}{}
}

// ChecksumCleared returns if the "checksum" field was cleared in this mutation.
func (m *MediaMutation) ChecksumCleared() bool {
	_, ok := m.clearedFields[media.FieldChecksum]
	return ok
}

// ResetChecksum resets all changes to the "checksum" field.
func (m *MediaMutation) ResetChecksum() {
	m.checksum = nil
	delete(m.clearedFields, media.FieldChecksum)
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *MediaMutation) SetWorkspaceID(s string) {
	m.workspace_id = &s
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *MediaMutation) WorkspaceID() (r string, exists bool) {
	v := m.workspace_id
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldWorkspaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *MediaMutation) ResetWorkspaceID() {
	m.workspace_id = nil
}

// SetAlt sets the "alt" field.
func (m *MediaMutation) SetAlt(s string) {
	m.alt = &s
}

// Alt returns the value of the "alt" field in the mutation.
func (m *MediaMutation) Alt() (r string, exists bool) {
	v := m.alt
	if v == nil {
		return
	}
	return *v, true
}

// OldAlt returns the old "alt" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldAlt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAlt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAlt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAlt: %w", err)
	}
	return oldValue.Alt, nil
}

// ClearAlt clears the value of the "alt" field.
func (m *MediaMutation) ClearAlt() {
	m.alt = nil
	m.clearedFields[media.FieldAlt] = struct{}{}
}

// AltCleared returns if the "alt" field was cleared in this mutation.
func (m *MediaMutation) AltCleared() bool {
	_, ok := m.clearedFields[media.FieldAlt]
	return ok
}

// ResetAlt resets all changes to the "alt" field.
func (m *MediaMutation) ResetAlt() {
	m.alt = nil
	delete(m.clearedFields, media.FieldAlt)
}

// SetUID sets the "uid" field.
func (m *MediaMutation) SetUID(s string) {
	m.uid = &s
}

// UID returns the value of the "uid" field in the mutation.
func (m *MediaMutation) UID() (r string, exists bool) {
	v := m.uid
	if v == nil {
		return
	}
	return *v, true
}

// OldUID returns the old "uid" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldUID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUID: %w", err)
	}
	return oldValue.UID, nil
}

// ClearUID clears the value of the "uid" field.
func (m *MediaMutation) ClearUID() {
	m.uid = nil
	m.clearedFields[media.FieldUID] = struct{}{}
}

// UIDCleared returns if the "uid" field was cleared in this mutation.
func (m *MediaMutation) UIDCleared() bool {
	_, ok := m.clearedFields[media.FieldUID]
	return ok
}

// ResetUID resets all changes to the "uid" field.
func (m *MediaMutation) ResetUID() {
	m.uid = nil
	delete(m.clearedFields, media.FieldUID)
}

// SetStatus sets the "status" field.
func (m *MediaMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *MediaMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Media entity.
// If the Media object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MediaMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *MediaMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[media.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *MediaMutation) StatusCleared() bool {
	_, ok := m.clearedFields[media.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *MediaMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, media.FieldStatus)
}

// Where appends a list predicates to the MediaMutation builder.
func (m *MediaMutation) Where(ps ...predicate.Media) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MediaMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MediaMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Media, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MediaMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MediaMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Media).
func (m *MediaMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MediaMutation) Fields() []string {
	fields := make([]string, 0, 20)
	if m.created_at != nil {
		fields = append(fields, media.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, media.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, media.FieldAppID)
	}
	if m.disk != nil {
		fields = append(fields, media.FieldDisk)
	}
	if m.directory != nil {
		fields = append(fields, media.FieldDirectory)
	}
	if m.name != nil {
		fields = append(fields, media.FieldName)
	}
	if m.original_name != nil {
		fields = append(fields, media.FieldOriginalName)
	}
	if m.extension != nil {
		fields = append(fields, media.FieldExtension)
	}
	if m.mime_type != nil {
		fields = append(fields, media.FieldMimeType)
	}
	if m.aggregate_type != nil {
		fields = append(fields, media.FieldAggregateType)
	}
	if m.size != nil {
		fields = append(fields, media.FieldSize)
	}
	if m.description != nil {
		fields = append(fields, media.FieldDescription)
	}
	if m.is_variant != nil {
		fields = append(fields, media.FieldIsVariant)
	}
	if m.variant_name != nil {
		fields = append(fields, media.FieldVariantName)
	}
	if m.original_media_id != nil {
		fields = append(fields, media.FieldOriginalMediaID)
	}
	if m.checksum != nil {
		fields = append(fields, media.FieldChecksum)
	}
	if m.workspace_id != nil {
		fields = append(fields, media.FieldWorkspaceID)
	}
	if m.alt != nil {
		fields = append(fields, media.FieldAlt)
	}
	if m.uid != nil {
		fields = append(fields, media.FieldUID)
	}
	if m.status != nil {
		fields = append(fields, media.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MediaMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case media.FieldCreatedAt:
		return m.CreatedAt()
	case media.FieldUpdatedAt:
		return m.UpdatedAt()
	case media.FieldAppID:
		return m.AppID()
	case media.FieldDisk:
		return m.Disk()
	case media.FieldDirectory:
		return m.Directory()
	case media.FieldName:
		return m.Name()
	case media.FieldOriginalName:
		return m.OriginalName()
	case media.FieldExtension:
		return m.Extension()
	case media.FieldMimeType:
		return m.MimeType()
	case media.FieldAggregateType:
		return m.AggregateType()
	case media.FieldSize:
		return m.Size()
	case media.FieldDescription:
		return m.Description()
	case media.FieldIsVariant:
		return m.IsVariant()
	case media.FieldVariantName:
		return m.VariantName()
	case media.FieldOriginalMediaID:
		return m.OriginalMediaID()
	case media.FieldChecksum:
		return m.Checksum()
	case media.FieldWorkspaceID:
		return m.WorkspaceID()
	case media.FieldAlt:
		return m.Alt()
	case media.FieldUID:
		return m.UID()
	case media.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MediaMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case media.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case media.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case media.FieldAppID:
		return m.OldAppID(ctx)
	case media.FieldDisk:
		return m.OldDisk(ctx)
	case media.FieldDirectory:
		return m.OldDirectory(ctx)
	case media.FieldName:
		return m.OldName(ctx)
	case media.FieldOriginalName:
		return m.OldOriginalName(ctx)
	case media.FieldExtension:
		return m.OldExtension(ctx)
	case media.FieldMimeType:
		return m.OldMimeType(ctx)
	case media.FieldAggregateType:
		return m.OldAggregateType(ctx)
	case media.FieldSize:
		return m.OldSize(ctx)
	case media.FieldDescription:
		return m.OldDescription(ctx)
	case media.FieldIsVariant:
		return m.OldIsVariant(ctx)
	case media.FieldVariantName:
		return m.OldVariantName(ctx)
	case media.FieldOriginalMediaID:
		return m.OldOriginalMediaID(ctx)
	case media.FieldChecksum:
		return m.OldChecksum(ctx)
	case media.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case media.FieldAlt:
		return m.OldAlt(ctx)
	case media.FieldUID:
		return m.OldUID(ctx)
	case media.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Media field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) SetField(name string, value ent.Value) error {
	switch name {
	case media.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case media.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case media.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case media.FieldDisk:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDisk(v)
		return nil
	case media.FieldDirectory:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDirectory(v)
		return nil
	case media.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case media.FieldOriginalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalName(v)
		return nil
	case media.FieldExtension:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExtension(v)
		return nil
	case media.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case media.FieldAggregateType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAggregateType(v)
		return nil
	case media.FieldSize:
		v, ok := value.(uint)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case media.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case media.FieldIsVariant:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsVariant(v)
		return nil
	case media.FieldVariantName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVariantName(v)
		return nil
	case media.FieldOriginalMediaID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOriginalMediaID(v)
		return nil
	case media.FieldChecksum:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetChecksum(v)
		return nil
	case media.FieldWorkspaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case media.FieldAlt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAlt(v)
		return nil
	case media.FieldUID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUID(v)
		return nil
	case media.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MediaMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, media.FieldSize)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MediaMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case media.FieldSize:
		return m.AddedSize()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MediaMutation) AddField(name string, value ent.Value) error {
	switch name {
	case media.FieldSize:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	}
	return fmt.Errorf("unknown Media numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MediaMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(media.FieldCreatedAt) {
		fields = append(fields, media.FieldCreatedAt)
	}
	if m.FieldCleared(media.FieldUpdatedAt) {
		fields = append(fields, media.FieldUpdatedAt)
	}
	if m.FieldCleared(media.FieldAppID) {
		fields = append(fields, media.FieldAppID)
	}
	if m.FieldCleared(media.FieldDisk) {
		fields = append(fields, media.FieldDisk)
	}
	if m.FieldCleared(media.FieldDirectory) {
		fields = append(fields, media.FieldDirectory)
	}
	if m.FieldCleared(media.FieldName) {
		fields = append(fields, media.FieldName)
	}
	if m.FieldCleared(media.FieldOriginalName) {
		fields = append(fields, media.FieldOriginalName)
	}
	if m.FieldCleared(media.FieldExtension) {
		fields = append(fields, media.FieldExtension)
	}
	if m.FieldCleared(media.FieldMimeType) {
		fields = append(fields, media.FieldMimeType)
	}
	if m.FieldCleared(media.FieldAggregateType) {
		fields = append(fields, media.FieldAggregateType)
	}
	if m.FieldCleared(media.FieldSize) {
		fields = append(fields, media.FieldSize)
	}
	if m.FieldCleared(media.FieldDescription) {
		fields = append(fields, media.FieldDescription)
	}
	if m.FieldCleared(media.FieldIsVariant) {
		fields = append(fields, media.FieldIsVariant)
	}
	if m.FieldCleared(media.FieldVariantName) {
		fields = append(fields, media.FieldVariantName)
	}
	if m.FieldCleared(media.FieldOriginalMediaID) {
		fields = append(fields, media.FieldOriginalMediaID)
	}
	if m.FieldCleared(media.FieldChecksum) {
		fields = append(fields, media.FieldChecksum)
	}
	if m.FieldCleared(media.FieldAlt) {
		fields = append(fields, media.FieldAlt)
	}
	if m.FieldCleared(media.FieldUID) {
		fields = append(fields, media.FieldUID)
	}
	if m.FieldCleared(media.FieldStatus) {
		fields = append(fields, media.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MediaMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MediaMutation) ClearField(name string) error {
	switch name {
	case media.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case media.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case media.FieldAppID:
		m.ClearAppID()
		return nil
	case media.FieldDisk:
		m.ClearDisk()
		return nil
	case media.FieldDirectory:
		m.ClearDirectory()
		return nil
	case media.FieldName:
		m.ClearName()
		return nil
	case media.FieldOriginalName:
		m.ClearOriginalName()
		return nil
	case media.FieldExtension:
		m.ClearExtension()
		return nil
	case media.FieldMimeType:
		m.ClearMimeType()
		return nil
	case media.FieldAggregateType:
		m.ClearAggregateType()
		return nil
	case media.FieldSize:
		m.ClearSize()
		return nil
	case media.FieldDescription:
		m.ClearDescription()
		return nil
	case media.FieldIsVariant:
		m.ClearIsVariant()
		return nil
	case media.FieldVariantName:
		m.ClearVariantName()
		return nil
	case media.FieldOriginalMediaID:
		m.ClearOriginalMediaID()
		return nil
	case media.FieldChecksum:
		m.ClearChecksum()
		return nil
	case media.FieldAlt:
		m.ClearAlt()
		return nil
	case media.FieldUID:
		m.ClearUID()
		return nil
	case media.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Media nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MediaMutation) ResetField(name string) error {
	switch name {
	case media.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case media.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case media.FieldAppID:
		m.ResetAppID()
		return nil
	case media.FieldDisk:
		m.ResetDisk()
		return nil
	case media.FieldDirectory:
		m.ResetDirectory()
		return nil
	case media.FieldName:
		m.ResetName()
		return nil
	case media.FieldOriginalName:
		m.ResetOriginalName()
		return nil
	case media.FieldExtension:
		m.ResetExtension()
		return nil
	case media.FieldMimeType:
		m.ResetMimeType()
		return nil
	case media.FieldAggregateType:
		m.ResetAggregateType()
		return nil
	case media.FieldSize:
		m.ResetSize()
		return nil
	case media.FieldDescription:
		m.ResetDescription()
		return nil
	case media.FieldIsVariant:
		m.ResetIsVariant()
		return nil
	case media.FieldVariantName:
		m.ResetVariantName()
		return nil
	case media.FieldOriginalMediaID:
		m.ResetOriginalMediaID()
		return nil
	case media.FieldChecksum:
		m.ResetChecksum()
		return nil
	case media.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case media.FieldAlt:
		m.ResetAlt()
		return nil
	case media.FieldUID:
		m.ResetUID()
		return nil
	case media.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Media field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MediaMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MediaMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MediaMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MediaMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MediaMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MediaMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MediaMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Media unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MediaMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Media edge %s", name)
}

// OauthConnectionMutation represents an operation that mutates the OauthConnection nodes in the graph.
type OauthConnectionMutation struct {
	config
	op             Op
	typ            string
	id             *string
	created_at     *time.Time
	updated_at     *time.Time
	app_id         *string
	name           *string
	provider       *string
	client_id      *string
	client_secret  *string
	scopes         *string
	redirect_url   *string
	dashboard_link *string
	note           *string
	status         *bool
	clearedFields  map[string]struct{}
	done           bool
	oldValue       func(context.Context) (*OauthConnection, error)
	predicates     []predicate.OauthConnection
}

var _ ent.Mutation = (*OauthConnectionMutation)(nil)

// oauthconnectionOption allows management of the mutation configuration using functional options.
type oauthconnectionOption func(*OauthConnectionMutation)

// newOauthConnectionMutation creates new mutation for the OauthConnection entity.
func newOauthConnectionMutation(c config, op Op, opts ...oauthconnectionOption) *OauthConnectionMutation {
	m := &OauthConnectionMutation{
		config:        c,
		op:            op,
		typ:           TypeOauthConnection,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOauthConnectionID sets the ID field of the mutation.
func withOauthConnectionID(id string) oauthconnectionOption {
	return func(m *OauthConnectionMutation) {
		var (
			err   error
			once  sync.Once
			value *OauthConnection
		)
		m.oldValue = func(ctx context.Context) (*OauthConnection, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().OauthConnection.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOauthConnection sets the old OauthConnection of the mutation.
func withOauthConnection(node *OauthConnection) oauthconnectionOption {
	return func(m *OauthConnectionMutation) {
		m.oldValue = func(context.Context) (*OauthConnection, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OauthConnectionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OauthConnectionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of OauthConnection entities.
func (m *OauthConnectionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *OauthConnectionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *OauthConnectionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().OauthConnection.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *OauthConnectionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *OauthConnectionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *OauthConnectionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[oauthconnection.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *OauthConnectionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *OauthConnectionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, oauthconnection.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *OauthConnectionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *OauthConnectionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *OauthConnectionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[oauthconnection.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *OauthConnectionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *OauthConnectionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, oauthconnection.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *OauthConnectionMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *OauthConnectionMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *OauthConnectionMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[oauthconnection.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *OauthConnectionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *OauthConnectionMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, oauthconnection.FieldAppID)
}

// SetName sets the "name" field.
func (m *OauthConnectionMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *OauthConnectionMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *OauthConnectionMutation) ClearName() {
	m.name = nil
	m.clearedFields[oauthconnection.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *OauthConnectionMutation) NameCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *OauthConnectionMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, oauthconnection.FieldName)
}

// SetProvider sets the "provider" field.
func (m *OauthConnectionMutation) SetProvider(s string) {
	m.provider = &s
}

// Provider returns the value of the "provider" field in the mutation.
func (m *OauthConnectionMutation) Provider() (r string, exists bool) {
	v := m.provider
	if v == nil {
		return
	}
	return *v, true
}

// OldProvider returns the old "provider" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldProvider(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldProvider is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldProvider requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProvider: %w", err)
	}
	return oldValue.Provider, nil
}

// ClearProvider clears the value of the "provider" field.
func (m *OauthConnectionMutation) ClearProvider() {
	m.provider = nil
	m.clearedFields[oauthconnection.FieldProvider] = struct{}{}
}

// ProviderCleared returns if the "provider" field was cleared in this mutation.
func (m *OauthConnectionMutation) ProviderCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldProvider]
	return ok
}

// ResetProvider resets all changes to the "provider" field.
func (m *OauthConnectionMutation) ResetProvider() {
	m.provider = nil
	delete(m.clearedFields, oauthconnection.FieldProvider)
}

// SetClientID sets the "client_id" field.
func (m *OauthConnectionMutation) SetClientID(s string) {
	m.client_id = &s
}

// ClientID returns the value of the "client_id" field in the mutation.
func (m *OauthConnectionMutation) ClientID() (r string, exists bool) {
	v := m.client_id
	if v == nil {
		return
	}
	return *v, true
}

// OldClientID returns the old "client_id" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldClientID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientID: %w", err)
	}
	return oldValue.ClientID, nil
}

// ClearClientID clears the value of the "client_id" field.
func (m *OauthConnectionMutation) ClearClientID() {
	m.client_id = nil
	m.clearedFields[oauthconnection.FieldClientID] = struct{}{}
}

// ClientIDCleared returns if the "client_id" field was cleared in this mutation.
func (m *OauthConnectionMutation) ClientIDCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldClientID]
	return ok
}

// ResetClientID resets all changes to the "client_id" field.
func (m *OauthConnectionMutation) ResetClientID() {
	m.client_id = nil
	delete(m.clearedFields, oauthconnection.FieldClientID)
}

// SetClientSecret sets the "client_secret" field.
func (m *OauthConnectionMutation) SetClientSecret(s string) {
	m.client_secret = &s
}

// ClientSecret returns the value of the "client_secret" field in the mutation.
func (m *OauthConnectionMutation) ClientSecret() (r string, exists bool) {
	v := m.client_secret
	if v == nil {
		return
	}
	return *v, true
}

// OldClientSecret returns the old "client_secret" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldClientSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldClientSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldClientSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClientSecret: %w", err)
	}
	return oldValue.ClientSecret, nil
}

// ClearClientSecret clears the value of the "client_secret" field.
func (m *OauthConnectionMutation) ClearClientSecret() {
	m.client_secret = nil
	m.clearedFields[oauthconnection.FieldClientSecret] = struct{}{}
}

// ClientSecretCleared returns if the "client_secret" field was cleared in this mutation.
func (m *OauthConnectionMutation) ClientSecretCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldClientSecret]
	return ok
}

// ResetClientSecret resets all changes to the "client_secret" field.
func (m *OauthConnectionMutation) ResetClientSecret() {
	m.client_secret = nil
	delete(m.clearedFields, oauthconnection.FieldClientSecret)
}

// SetScopes sets the "scopes" field.
func (m *OauthConnectionMutation) SetScopes(s string) {
	m.scopes = &s
}

// Scopes returns the value of the "scopes" field in the mutation.
func (m *OauthConnectionMutation) Scopes() (r string, exists bool) {
	v := m.scopes
	if v == nil {
		return
	}
	return *v, true
}

// OldScopes returns the old "scopes" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldScopes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldScopes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldScopes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldScopes: %w", err)
	}
	return oldValue.Scopes, nil
}

// ClearScopes clears the value of the "scopes" field.
func (m *OauthConnectionMutation) ClearScopes() {
	m.scopes = nil
	m.clearedFields[oauthconnection.FieldScopes] = struct{}{}
}

// ScopesCleared returns if the "scopes" field was cleared in this mutation.
func (m *OauthConnectionMutation) ScopesCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldScopes]
	return ok
}

// ResetScopes resets all changes to the "scopes" field.
func (m *OauthConnectionMutation) ResetScopes() {
	m.scopes = nil
	delete(m.clearedFields, oauthconnection.FieldScopes)
}

// SetRedirectURL sets the "redirect_url" field.
func (m *OauthConnectionMutation) SetRedirectURL(s string) {
	m.redirect_url = &s
}

// RedirectURL returns the value of the "redirect_url" field in the mutation.
func (m *OauthConnectionMutation) RedirectURL() (r string, exists bool) {
	v := m.redirect_url
	if v == nil {
		return
	}
	return *v, true
}

// OldRedirectURL returns the old "redirect_url" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldRedirectURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRedirectURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRedirectURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRedirectURL: %w", err)
	}
	return oldValue.RedirectURL, nil
}

// ClearRedirectURL clears the value of the "redirect_url" field.
func (m *OauthConnectionMutation) ClearRedirectURL() {
	m.redirect_url = nil
	m.clearedFields[oauthconnection.FieldRedirectURL] = struct{}{}
}

// RedirectURLCleared returns if the "redirect_url" field was cleared in this mutation.
func (m *OauthConnectionMutation) RedirectURLCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldRedirectURL]
	return ok
}

// ResetRedirectURL resets all changes to the "redirect_url" field.
func (m *OauthConnectionMutation) ResetRedirectURL() {
	m.redirect_url = nil
	delete(m.clearedFields, oauthconnection.FieldRedirectURL)
}

// SetDashboardLink sets the "dashboard_link" field.
func (m *OauthConnectionMutation) SetDashboardLink(s string) {
	m.dashboard_link = &s
}

// DashboardLink returns the value of the "dashboard_link" field in the mutation.
func (m *OauthConnectionMutation) DashboardLink() (r string, exists bool) {
	v := m.dashboard_link
	if v == nil {
		return
	}
	return *v, true
}

// OldDashboardLink returns the old "dashboard_link" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldDashboardLink(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDashboardLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDashboardLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDashboardLink: %w", err)
	}
	return oldValue.DashboardLink, nil
}

// ClearDashboardLink clears the value of the "dashboard_link" field.
func (m *OauthConnectionMutation) ClearDashboardLink() {
	m.dashboard_link = nil
	m.clearedFields[oauthconnection.FieldDashboardLink] = struct{}{}
}

// DashboardLinkCleared returns if the "dashboard_link" field was cleared in this mutation.
func (m *OauthConnectionMutation) DashboardLinkCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldDashboardLink]
	return ok
}

// ResetDashboardLink resets all changes to the "dashboard_link" field.
func (m *OauthConnectionMutation) ResetDashboardLink() {
	m.dashboard_link = nil
	delete(m.clearedFields, oauthconnection.FieldDashboardLink)
}

// SetNote sets the "note" field.
func (m *OauthConnectionMutation) SetNote(s string) {
	m.note = &s
}

// Note returns the value of the "note" field in the mutation.
func (m *OauthConnectionMutation) Note() (r string, exists bool) {
	v := m.note
	if v == nil {
		return
	}
	return *v, true
}

// OldNote returns the old "note" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNote is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNote: %w", err)
	}
	return oldValue.Note, nil
}

// ClearNote clears the value of the "note" field.
func (m *OauthConnectionMutation) ClearNote() {
	m.note = nil
	m.clearedFields[oauthconnection.FieldNote] = struct{}{}
}

// NoteCleared returns if the "note" field was cleared in this mutation.
func (m *OauthConnectionMutation) NoteCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldNote]
	return ok
}

// ResetNote resets all changes to the "note" field.
func (m *OauthConnectionMutation) ResetNote() {
	m.note = nil
	delete(m.clearedFields, oauthconnection.FieldNote)
}

// SetStatus sets the "status" field.
func (m *OauthConnectionMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *OauthConnectionMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the OauthConnection entity.
// If the OauthConnection object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *OauthConnectionMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *OauthConnectionMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[oauthconnection.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *OauthConnectionMutation) StatusCleared() bool {
	_, ok := m.clearedFields[oauthconnection.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *OauthConnectionMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, oauthconnection.FieldStatus)
}

// Where appends a list predicates to the OauthConnectionMutation builder.
func (m *OauthConnectionMutation) Where(ps ...predicate.OauthConnection) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the OauthConnectionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *OauthConnectionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.OauthConnection, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *OauthConnectionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *OauthConnectionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (OauthConnection).
func (m *OauthConnectionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *OauthConnectionMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, oauthconnection.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, oauthconnection.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, oauthconnection.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, oauthconnection.FieldName)
	}
	if m.provider != nil {
		fields = append(fields, oauthconnection.FieldProvider)
	}
	if m.client_id != nil {
		fields = append(fields, oauthconnection.FieldClientID)
	}
	if m.client_secret != nil {
		fields = append(fields, oauthconnection.FieldClientSecret)
	}
	if m.scopes != nil {
		fields = append(fields, oauthconnection.FieldScopes)
	}
	if m.redirect_url != nil {
		fields = append(fields, oauthconnection.FieldRedirectURL)
	}
	if m.dashboard_link != nil {
		fields = append(fields, oauthconnection.FieldDashboardLink)
	}
	if m.note != nil {
		fields = append(fields, oauthconnection.FieldNote)
	}
	if m.status != nil {
		fields = append(fields, oauthconnection.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *OauthConnectionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case oauthconnection.FieldCreatedAt:
		return m.CreatedAt()
	case oauthconnection.FieldUpdatedAt:
		return m.UpdatedAt()
	case oauthconnection.FieldAppID:
		return m.AppID()
	case oauthconnection.FieldName:
		return m.Name()
	case oauthconnection.FieldProvider:
		return m.Provider()
	case oauthconnection.FieldClientID:
		return m.ClientID()
	case oauthconnection.FieldClientSecret:
		return m.ClientSecret()
	case oauthconnection.FieldScopes:
		return m.Scopes()
	case oauthconnection.FieldRedirectURL:
		return m.RedirectURL()
	case oauthconnection.FieldDashboardLink:
		return m.DashboardLink()
	case oauthconnection.FieldNote:
		return m.Note()
	case oauthconnection.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *OauthConnectionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case oauthconnection.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case oauthconnection.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case oauthconnection.FieldAppID:
		return m.OldAppID(ctx)
	case oauthconnection.FieldName:
		return m.OldName(ctx)
	case oauthconnection.FieldProvider:
		return m.OldProvider(ctx)
	case oauthconnection.FieldClientID:
		return m.OldClientID(ctx)
	case oauthconnection.FieldClientSecret:
		return m.OldClientSecret(ctx)
	case oauthconnection.FieldScopes:
		return m.OldScopes(ctx)
	case oauthconnection.FieldRedirectURL:
		return m.OldRedirectURL(ctx)
	case oauthconnection.FieldDashboardLink:
		return m.OldDashboardLink(ctx)
	case oauthconnection.FieldNote:
		return m.OldNote(ctx)
	case oauthconnection.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown OauthConnection field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthConnectionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case oauthconnection.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case oauthconnection.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case oauthconnection.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case oauthconnection.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case oauthconnection.FieldProvider:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProvider(v)
		return nil
	case oauthconnection.FieldClientID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientID(v)
		return nil
	case oauthconnection.FieldClientSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClientSecret(v)
		return nil
	case oauthconnection.FieldScopes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetScopes(v)
		return nil
	case oauthconnection.FieldRedirectURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRedirectURL(v)
		return nil
	case oauthconnection.FieldDashboardLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDashboardLink(v)
		return nil
	case oauthconnection.FieldNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNote(v)
		return nil
	case oauthconnection.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown OauthConnection field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *OauthConnectionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *OauthConnectionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *OauthConnectionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown OauthConnection numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *OauthConnectionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(oauthconnection.FieldCreatedAt) {
		fields = append(fields, oauthconnection.FieldCreatedAt)
	}
	if m.FieldCleared(oauthconnection.FieldUpdatedAt) {
		fields = append(fields, oauthconnection.FieldUpdatedAt)
	}
	if m.FieldCleared(oauthconnection.FieldAppID) {
		fields = append(fields, oauthconnection.FieldAppID)
	}
	if m.FieldCleared(oauthconnection.FieldName) {
		fields = append(fields, oauthconnection.FieldName)
	}
	if m.FieldCleared(oauthconnection.FieldProvider) {
		fields = append(fields, oauthconnection.FieldProvider)
	}
	if m.FieldCleared(oauthconnection.FieldClientID) {
		fields = append(fields, oauthconnection.FieldClientID)
	}
	if m.FieldCleared(oauthconnection.FieldClientSecret) {
		fields = append(fields, oauthconnection.FieldClientSecret)
	}
	if m.FieldCleared(oauthconnection.FieldScopes) {
		fields = append(fields, oauthconnection.FieldScopes)
	}
	if m.FieldCleared(oauthconnection.FieldRedirectURL) {
		fields = append(fields, oauthconnection.FieldRedirectURL)
	}
	if m.FieldCleared(oauthconnection.FieldDashboardLink) {
		fields = append(fields, oauthconnection.FieldDashboardLink)
	}
	if m.FieldCleared(oauthconnection.FieldNote) {
		fields = append(fields, oauthconnection.FieldNote)
	}
	if m.FieldCleared(oauthconnection.FieldStatus) {
		fields = append(fields, oauthconnection.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *OauthConnectionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *OauthConnectionMutation) ClearField(name string) error {
	switch name {
	case oauthconnection.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case oauthconnection.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case oauthconnection.FieldAppID:
		m.ClearAppID()
		return nil
	case oauthconnection.FieldName:
		m.ClearName()
		return nil
	case oauthconnection.FieldProvider:
		m.ClearProvider()
		return nil
	case oauthconnection.FieldClientID:
		m.ClearClientID()
		return nil
	case oauthconnection.FieldClientSecret:
		m.ClearClientSecret()
		return nil
	case oauthconnection.FieldScopes:
		m.ClearScopes()
		return nil
	case oauthconnection.FieldRedirectURL:
		m.ClearRedirectURL()
		return nil
	case oauthconnection.FieldDashboardLink:
		m.ClearDashboardLink()
		return nil
	case oauthconnection.FieldNote:
		m.ClearNote()
		return nil
	case oauthconnection.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown OauthConnection nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *OauthConnectionMutation) ResetField(name string) error {
	switch name {
	case oauthconnection.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case oauthconnection.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case oauthconnection.FieldAppID:
		m.ResetAppID()
		return nil
	case oauthconnection.FieldName:
		m.ResetName()
		return nil
	case oauthconnection.FieldProvider:
		m.ResetProvider()
		return nil
	case oauthconnection.FieldClientID:
		m.ResetClientID()
		return nil
	case oauthconnection.FieldClientSecret:
		m.ResetClientSecret()
		return nil
	case oauthconnection.FieldScopes:
		m.ResetScopes()
		return nil
	case oauthconnection.FieldRedirectURL:
		m.ResetRedirectURL()
		return nil
	case oauthconnection.FieldDashboardLink:
		m.ResetDashboardLink()
		return nil
	case oauthconnection.FieldNote:
		m.ResetNote()
		return nil
	case oauthconnection.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown OauthConnection field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *OauthConnectionMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *OauthConnectionMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *OauthConnectionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *OauthConnectionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *OauthConnectionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *OauthConnectionMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *OauthConnectionMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown OauthConnection unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *OauthConnectionMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown OauthConnection edge %s", name)
}

// PlanMutation represents an operation that mutates the Plan nodes in the graph.
type PlanMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	app_id        *string
	name          *string
	excerpt       *string
	description   *string
	status        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Plan, error)
	predicates    []predicate.Plan
}

var _ ent.Mutation = (*PlanMutation)(nil)

// planOption allows management of the mutation configuration using functional options.
type planOption func(*PlanMutation)

// newPlanMutation creates new mutation for the Plan entity.
func newPlanMutation(c config, op Op, opts ...planOption) *PlanMutation {
	m := &PlanMutation{
		config:        c,
		op:            op,
		typ:           TypePlan,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPlanID sets the ID field of the mutation.
func withPlanID(id string) planOption {
	return func(m *PlanMutation) {
		var (
			err   error
			once  sync.Once
			value *Plan
		)
		m.oldValue = func(ctx context.Context) (*Plan, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Plan.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPlan sets the old Plan of the mutation.
func withPlan(node *Plan) planOption {
	return func(m *PlanMutation) {
		m.oldValue = func(context.Context) (*Plan, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PlanMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PlanMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Plan entities.
func (m *PlanMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PlanMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PlanMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Plan.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PlanMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PlanMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PlanMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[plan.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PlanMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[plan.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PlanMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, plan.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PlanMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PlanMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PlanMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[plan.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PlanMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[plan.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PlanMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, plan.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *PlanMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PlanMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *PlanMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[plan.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *PlanMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[plan.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PlanMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, plan.FieldAppID)
}

// SetName sets the "name" field.
func (m *PlanMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PlanMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PlanMutation) ClearName() {
	m.name = nil
	m.clearedFields[plan.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PlanMutation) NameCleared() bool {
	_, ok := m.clearedFields[plan.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PlanMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, plan.FieldName)
}

// SetExcerpt sets the "excerpt" field.
func (m *PlanMutation) SetExcerpt(s string) {
	m.excerpt = &s
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *PlanMutation) Excerpt() (r string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldExcerpt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *PlanMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[plan.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *PlanMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[plan.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *PlanMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, plan.FieldExcerpt)
}

// SetDescription sets the "description" field.
func (m *PlanMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *PlanMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *PlanMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[plan.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *PlanMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[plan.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *PlanMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, plan.FieldDescription)
}

// SetStatus sets the "status" field.
func (m *PlanMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *PlanMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Plan entity.
// If the Plan object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PlanMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PlanMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[plan.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PlanMutation) StatusCleared() bool {
	_, ok := m.clearedFields[plan.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PlanMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, plan.FieldStatus)
}

// Where appends a list predicates to the PlanMutation builder.
func (m *PlanMutation) Where(ps ...predicate.Plan) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PlanMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PlanMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Plan, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PlanMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PlanMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Plan).
func (m *PlanMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PlanMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, plan.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, plan.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, plan.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, plan.FieldName)
	}
	if m.excerpt != nil {
		fields = append(fields, plan.FieldExcerpt)
	}
	if m.description != nil {
		fields = append(fields, plan.FieldDescription)
	}
	if m.status != nil {
		fields = append(fields, plan.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PlanMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case plan.FieldCreatedAt:
		return m.CreatedAt()
	case plan.FieldUpdatedAt:
		return m.UpdatedAt()
	case plan.FieldAppID:
		return m.AppID()
	case plan.FieldName:
		return m.Name()
	case plan.FieldExcerpt:
		return m.Excerpt()
	case plan.FieldDescription:
		return m.Description()
	case plan.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PlanMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case plan.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case plan.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case plan.FieldAppID:
		return m.OldAppID(ctx)
	case plan.FieldName:
		return m.OldName(ctx)
	case plan.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case plan.FieldDescription:
		return m.OldDescription(ctx)
	case plan.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Plan field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) SetField(name string, value ent.Value) error {
	switch name {
	case plan.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case plan.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case plan.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case plan.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case plan.FieldExcerpt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case plan.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case plan.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PlanMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PlanMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PlanMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Plan numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PlanMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(plan.FieldCreatedAt) {
		fields = append(fields, plan.FieldCreatedAt)
	}
	if m.FieldCleared(plan.FieldUpdatedAt) {
		fields = append(fields, plan.FieldUpdatedAt)
	}
	if m.FieldCleared(plan.FieldAppID) {
		fields = append(fields, plan.FieldAppID)
	}
	if m.FieldCleared(plan.FieldName) {
		fields = append(fields, plan.FieldName)
	}
	if m.FieldCleared(plan.FieldExcerpt) {
		fields = append(fields, plan.FieldExcerpt)
	}
	if m.FieldCleared(plan.FieldDescription) {
		fields = append(fields, plan.FieldDescription)
	}
	if m.FieldCleared(plan.FieldStatus) {
		fields = append(fields, plan.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PlanMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PlanMutation) ClearField(name string) error {
	switch name {
	case plan.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case plan.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case plan.FieldAppID:
		m.ClearAppID()
		return nil
	case plan.FieldName:
		m.ClearName()
		return nil
	case plan.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	case plan.FieldDescription:
		m.ClearDescription()
		return nil
	case plan.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Plan nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PlanMutation) ResetField(name string) error {
	switch name {
	case plan.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case plan.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case plan.FieldAppID:
		m.ResetAppID()
		return nil
	case plan.FieldName:
		m.ResetName()
		return nil
	case plan.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case plan.FieldDescription:
		m.ResetDescription()
		return nil
	case plan.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Plan field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PlanMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PlanMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PlanMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PlanMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PlanMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PlanMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PlanMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Plan unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PlanMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Plan edge %s", name)
}

// PostMutation represents an operation that mutates the Post nodes in the graph.
type PostMutation struct {
	config
	op                      Op
	typ                     string
	id                      *string
	created_at              *time.Time
	updated_at              *time.Time
	app_id                  *string
	name                    *string
	slug                    *string
	headline                *string
	excerpt                 *string
	content                 *string
	meta_title              *string
	meta_descr              *string
	meta_canonical_url      *string
	meta_robots             *string
	custom                  *map[string]interface{}
	clearedFields           map[string]struct{}
	post_status             *string
	clearedpost_status      bool
	post_type               *string
	clearedpost_type        bool
	primary_category        *string
	clearedprimary_category bool
	post_tags               map[string]struct{}
	removedpost_tags        map[string]struct{}
	clearedpost_tags        bool
	done                    bool
	oldValue                func(context.Context) (*Post, error)
	predicates              []predicate.Post
}

var _ ent.Mutation = (*PostMutation)(nil)

// postOption allows management of the mutation configuration using functional options.
type postOption func(*PostMutation)

// newPostMutation creates new mutation for the Post entity.
func newPostMutation(c config, op Op, opts ...postOption) *PostMutation {
	m := &PostMutation{
		config:        c,
		op:            op,
		typ:           TypePost,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostID sets the ID field of the mutation.
func withPostID(id string) postOption {
	return func(m *PostMutation) {
		var (
			err   error
			once  sync.Once
			value *Post
		)
		m.oldValue = func(ctx context.Context) (*Post, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Post.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPost sets the old Post of the mutation.
func withPost(node *Post) postOption {
	return func(m *PostMutation) {
		m.oldValue = func(context.Context) (*Post, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Post entities.
func (m *PostMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Post.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PostMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[post.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PostMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, post.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PostMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[post.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PostMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[post.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, post.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *PostMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PostMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *PostMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[post.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *PostMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[post.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PostMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, post.FieldAppID)
}

// SetName sets the "name" field.
func (m *PostMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PostMutation) ClearName() {
	m.name = nil
	m.clearedFields[post.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PostMutation) NameCleared() bool {
	_, ok := m.clearedFields[post.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PostMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, post.FieldName)
}

// SetSlug sets the "slug" field.
func (m *PostMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[post.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostMutation) SlugCleared() bool {
	_, ok := m.clearedFields[post.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, post.FieldSlug)
}

// SetPostStatusID sets the "post_status_id" field.
func (m *PostMutation) SetPostStatusID(s string) {
	m.post_status = &s
}

// PostStatusID returns the value of the "post_status_id" field in the mutation.
func (m *PostMutation) PostStatusID() (r string, exists bool) {
	v := m.post_status
	if v == nil {
		return
	}
	return *v, true
}

// OldPostStatusID returns the old "post_status_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPostStatusID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostStatusID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostStatusID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostStatusID: %w", err)
	}
	return oldValue.PostStatusID, nil
}

// ClearPostStatusID clears the value of the "post_status_id" field.
func (m *PostMutation) ClearPostStatusID() {
	m.post_status = nil
	m.clearedFields[post.FieldPostStatusID] = struct{}{}
}

// PostStatusIDCleared returns if the "post_status_id" field was cleared in this mutation.
func (m *PostMutation) PostStatusIDCleared() bool {
	_, ok := m.clearedFields[post.FieldPostStatusID]
	return ok
}

// ResetPostStatusID resets all changes to the "post_status_id" field.
func (m *PostMutation) ResetPostStatusID() {
	m.post_status = nil
	delete(m.clearedFields, post.FieldPostStatusID)
}

// SetPostTypeID sets the "post_type_id" field.
func (m *PostMutation) SetPostTypeID(s string) {
	m.post_type = &s
}

// PostTypeID returns the value of the "post_type_id" field in the mutation.
func (m *PostMutation) PostTypeID() (r string, exists bool) {
	v := m.post_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPostTypeID returns the old "post_type_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPostTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostTypeID: %w", err)
	}
	return oldValue.PostTypeID, nil
}

// ClearPostTypeID clears the value of the "post_type_id" field.
func (m *PostMutation) ClearPostTypeID() {
	m.post_type = nil
	m.clearedFields[post.FieldPostTypeID] = struct{}{}
}

// PostTypeIDCleared returns if the "post_type_id" field was cleared in this mutation.
func (m *PostMutation) PostTypeIDCleared() bool {
	_, ok := m.clearedFields[post.FieldPostTypeID]
	return ok
}

// ResetPostTypeID resets all changes to the "post_type_id" field.
func (m *PostMutation) ResetPostTypeID() {
	m.post_type = nil
	delete(m.clearedFields, post.FieldPostTypeID)
}

// SetPrimaryCategoryID sets the "primary_category_id" field.
func (m *PostMutation) SetPrimaryCategoryID(s string) {
	m.primary_category = &s
}

// PrimaryCategoryID returns the value of the "primary_category_id" field in the mutation.
func (m *PostMutation) PrimaryCategoryID() (r string, exists bool) {
	v := m.primary_category
	if v == nil {
		return
	}
	return *v, true
}

// OldPrimaryCategoryID returns the old "primary_category_id" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldPrimaryCategoryID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrimaryCategoryID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrimaryCategoryID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrimaryCategoryID: %w", err)
	}
	return oldValue.PrimaryCategoryID, nil
}

// ClearPrimaryCategoryID clears the value of the "primary_category_id" field.
func (m *PostMutation) ClearPrimaryCategoryID() {
	m.primary_category = nil
	m.clearedFields[post.FieldPrimaryCategoryID] = struct{}{}
}

// PrimaryCategoryIDCleared returns if the "primary_category_id" field was cleared in this mutation.
func (m *PostMutation) PrimaryCategoryIDCleared() bool {
	_, ok := m.clearedFields[post.FieldPrimaryCategoryID]
	return ok
}

// ResetPrimaryCategoryID resets all changes to the "primary_category_id" field.
func (m *PostMutation) ResetPrimaryCategoryID() {
	m.primary_category = nil
	delete(m.clearedFields, post.FieldPrimaryCategoryID)
}

// SetHeadline sets the "headline" field.
func (m *PostMutation) SetHeadline(s string) {
	m.headline = &s
}

// Headline returns the value of the "headline" field in the mutation.
func (m *PostMutation) Headline() (r string, exists bool) {
	v := m.headline
	if v == nil {
		return
	}
	return *v, true
}

// OldHeadline returns the old "headline" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldHeadline(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHeadline is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHeadline requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHeadline: %w", err)
	}
	return oldValue.Headline, nil
}

// ClearHeadline clears the value of the "headline" field.
func (m *PostMutation) ClearHeadline() {
	m.headline = nil
	m.clearedFields[post.FieldHeadline] = struct{}{}
}

// HeadlineCleared returns if the "headline" field was cleared in this mutation.
func (m *PostMutation) HeadlineCleared() bool {
	_, ok := m.clearedFields[post.FieldHeadline]
	return ok
}

// ResetHeadline resets all changes to the "headline" field.
func (m *PostMutation) ResetHeadline() {
	m.headline = nil
	delete(m.clearedFields, post.FieldHeadline)
}

// SetExcerpt sets the "excerpt" field.
func (m *PostMutation) SetExcerpt(s string) {
	m.excerpt = &s
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *PostMutation) Excerpt() (r string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldExcerpt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *PostMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[post.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *PostMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[post.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *PostMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, post.FieldExcerpt)
}

// SetContent sets the "content" field.
func (m *PostMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *PostMutation) ClearContent() {
	m.content = nil
	m.clearedFields[post.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *PostMutation) ContentCleared() bool {
	_, ok := m.clearedFields[post.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *PostMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, post.FieldContent)
}

// SetMetaTitle sets the "meta_title" field.
func (m *PostMutation) SetMetaTitle(s string) {
	m.meta_title = &s
}

// MetaTitle returns the value of the "meta_title" field in the mutation.
func (m *PostMutation) MetaTitle() (r string, exists bool) {
	v := m.meta_title
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaTitle returns the old "meta_title" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMetaTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaTitle: %w", err)
	}
	return oldValue.MetaTitle, nil
}

// ClearMetaTitle clears the value of the "meta_title" field.
func (m *PostMutation) ClearMetaTitle() {
	m.meta_title = nil
	m.clearedFields[post.FieldMetaTitle] = struct{}{}
}

// MetaTitleCleared returns if the "meta_title" field was cleared in this mutation.
func (m *PostMutation) MetaTitleCleared() bool {
	_, ok := m.clearedFields[post.FieldMetaTitle]
	return ok
}

// ResetMetaTitle resets all changes to the "meta_title" field.
func (m *PostMutation) ResetMetaTitle() {
	m.meta_title = nil
	delete(m.clearedFields, post.FieldMetaTitle)
}

// SetMetaDescr sets the "meta_descr" field.
func (m *PostMutation) SetMetaDescr(s string) {
	m.meta_descr = &s
}

// MetaDescr returns the value of the "meta_descr" field in the mutation.
func (m *PostMutation) MetaDescr() (r string, exists bool) {
	v := m.meta_descr
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaDescr returns the old "meta_descr" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMetaDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaDescr: %w", err)
	}
	return oldValue.MetaDescr, nil
}

// ClearMetaDescr clears the value of the "meta_descr" field.
func (m *PostMutation) ClearMetaDescr() {
	m.meta_descr = nil
	m.clearedFields[post.FieldMetaDescr] = struct{}{}
}

// MetaDescrCleared returns if the "meta_descr" field was cleared in this mutation.
func (m *PostMutation) MetaDescrCleared() bool {
	_, ok := m.clearedFields[post.FieldMetaDescr]
	return ok
}

// ResetMetaDescr resets all changes to the "meta_descr" field.
func (m *PostMutation) ResetMetaDescr() {
	m.meta_descr = nil
	delete(m.clearedFields, post.FieldMetaDescr)
}

// SetMetaCanonicalURL sets the "meta_canonical_url" field.
func (m *PostMutation) SetMetaCanonicalURL(s string) {
	m.meta_canonical_url = &s
}

// MetaCanonicalURL returns the value of the "meta_canonical_url" field in the mutation.
func (m *PostMutation) MetaCanonicalURL() (r string, exists bool) {
	v := m.meta_canonical_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaCanonicalURL returns the old "meta_canonical_url" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMetaCanonicalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaCanonicalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaCanonicalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaCanonicalURL: %w", err)
	}
	return oldValue.MetaCanonicalURL, nil
}

// ClearMetaCanonicalURL clears the value of the "meta_canonical_url" field.
func (m *PostMutation) ClearMetaCanonicalURL() {
	m.meta_canonical_url = nil
	m.clearedFields[post.FieldMetaCanonicalURL] = struct{}{}
}

// MetaCanonicalURLCleared returns if the "meta_canonical_url" field was cleared in this mutation.
func (m *PostMutation) MetaCanonicalURLCleared() bool {
	_, ok := m.clearedFields[post.FieldMetaCanonicalURL]
	return ok
}

// ResetMetaCanonicalURL resets all changes to the "meta_canonical_url" field.
func (m *PostMutation) ResetMetaCanonicalURL() {
	m.meta_canonical_url = nil
	delete(m.clearedFields, post.FieldMetaCanonicalURL)
}

// SetMetaRobots sets the "meta_robots" field.
func (m *PostMutation) SetMetaRobots(s string) {
	m.meta_robots = &s
}

// MetaRobots returns the value of the "meta_robots" field in the mutation.
func (m *PostMutation) MetaRobots() (r string, exists bool) {
	v := m.meta_robots
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaRobots returns the old "meta_robots" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldMetaRobots(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaRobots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaRobots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaRobots: %w", err)
	}
	return oldValue.MetaRobots, nil
}

// ClearMetaRobots clears the value of the "meta_robots" field.
func (m *PostMutation) ClearMetaRobots() {
	m.meta_robots = nil
	m.clearedFields[post.FieldMetaRobots] = struct{}{}
}

// MetaRobotsCleared returns if the "meta_robots" field was cleared in this mutation.
func (m *PostMutation) MetaRobotsCleared() bool {
	_, ok := m.clearedFields[post.FieldMetaRobots]
	return ok
}

// ResetMetaRobots resets all changes to the "meta_robots" field.
func (m *PostMutation) ResetMetaRobots() {
	m.meta_robots = nil
	delete(m.clearedFields, post.FieldMetaRobots)
}

// SetCustom sets the "custom" field.
func (m *PostMutation) SetCustom(value map[string]interface{}) {
	m.custom = &value
}

// Custom returns the value of the "custom" field in the mutation.
func (m *PostMutation) Custom() (r map[string]interface{}, exists bool) {
	v := m.custom
	if v == nil {
		return
	}
	return *v, true
}

// OldCustom returns the old "custom" field's value of the Post entity.
// If the Post object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostMutation) OldCustom(ctx context.Context) (v map[string]interface{}, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCustom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCustom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCustom: %w", err)
	}
	return oldValue.Custom, nil
}

// ClearCustom clears the value of the "custom" field.
func (m *PostMutation) ClearCustom() {
	m.custom = nil
	m.clearedFields[post.FieldCustom] = struct{}{}
}

// CustomCleared returns if the "custom" field was cleared in this mutation.
func (m *PostMutation) CustomCleared() bool {
	_, ok := m.clearedFields[post.FieldCustom]
	return ok
}

// ResetCustom resets all changes to the "custom" field.
func (m *PostMutation) ResetCustom() {
	m.custom = nil
	delete(m.clearedFields, post.FieldCustom)
}

// ClearPostStatus clears the "post_status" edge to the PostStatus entity.
func (m *PostMutation) ClearPostStatus() {
	m.clearedpost_status = true
	m.clearedFields[post.FieldPostStatusID] = struct{}{}
}

// PostStatusCleared reports if the "post_status" edge to the PostStatus entity was cleared.
func (m *PostMutation) PostStatusCleared() bool {
	return m.PostStatusIDCleared() || m.clearedpost_status
}

// PostStatusIDs returns the "post_status" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostStatusID instead. It exists only for internal usage by the builders.
func (m *PostMutation) PostStatusIDs() (ids []string) {
	if id := m.post_status; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPostStatus resets all changes to the "post_status" edge.
func (m *PostMutation) ResetPostStatus() {
	m.post_status = nil
	m.clearedpost_status = false
}

// ClearPostType clears the "post_type" edge to the PostType entity.
func (m *PostMutation) ClearPostType() {
	m.clearedpost_type = true
	m.clearedFields[post.FieldPostTypeID] = struct{}{}
}

// PostTypeCleared reports if the "post_type" edge to the PostType entity was cleared.
func (m *PostMutation) PostTypeCleared() bool {
	return m.PostTypeIDCleared() || m.clearedpost_type
}

// PostTypeIDs returns the "post_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostTypeID instead. It exists only for internal usage by the builders.
func (m *PostMutation) PostTypeIDs() (ids []string) {
	if id := m.post_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPostType resets all changes to the "post_type" edge.
func (m *PostMutation) ResetPostType() {
	m.post_type = nil
	m.clearedpost_type = false
}

// ClearPrimaryCategory clears the "primary_category" edge to the PostCategory entity.
func (m *PostMutation) ClearPrimaryCategory() {
	m.clearedprimary_category = true
	m.clearedFields[post.FieldPrimaryCategoryID] = struct{}{}
}

// PrimaryCategoryCleared reports if the "primary_category" edge to the PostCategory entity was cleared.
func (m *PostMutation) PrimaryCategoryCleared() bool {
	return m.PrimaryCategoryIDCleared() || m.clearedprimary_category
}

// PrimaryCategoryIDs returns the "primary_category" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PrimaryCategoryID instead. It exists only for internal usage by the builders.
func (m *PostMutation) PrimaryCategoryIDs() (ids []string) {
	if id := m.primary_category; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrimaryCategory resets all changes to the "primary_category" edge.
func (m *PostMutation) ResetPrimaryCategory() {
	m.primary_category = nil
	m.clearedprimary_category = false
}

// AddPostTagIDs adds the "post_tags" edge to the PostTag entity by ids.
func (m *PostMutation) AddPostTagIDs(ids ...string) {
	if m.post_tags == nil {
		m.post_tags = make(map[string]struct{})
	}
	for i := range ids {
		m.post_tags[ids[i]] = struct{}{}
	}
}

// ClearPostTags clears the "post_tags" edge to the PostTag entity.
func (m *PostMutation) ClearPostTags() {
	m.clearedpost_tags = true
}

// PostTagsCleared reports if the "post_tags" edge to the PostTag entity was cleared.
func (m *PostMutation) PostTagsCleared() bool {
	return m.clearedpost_tags
}

// RemovePostTagIDs removes the "post_tags" edge to the PostTag entity by IDs.
func (m *PostMutation) RemovePostTagIDs(ids ...string) {
	if m.removedpost_tags == nil {
		m.removedpost_tags = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_tags, ids[i])
		m.removedpost_tags[ids[i]] = struct{}{}
	}
}

// RemovedPostTags returns the removed IDs of the "post_tags" edge to the PostTag entity.
func (m *PostMutation) RemovedPostTagsIDs() (ids []string) {
	for id := range m.removedpost_tags {
		ids = append(ids, id)
	}
	return
}

// PostTagsIDs returns the "post_tags" edge IDs in the mutation.
func (m *PostMutation) PostTagsIDs() (ids []string) {
	for id := range m.post_tags {
		ids = append(ids, id)
	}
	return
}

// ResetPostTags resets all changes to the "post_tags" edge.
func (m *PostMutation) ResetPostTags() {
	m.post_tags = nil
	m.clearedpost_tags = false
	m.removedpost_tags = nil
}

// Where appends a list predicates to the PostMutation builder.
func (m *PostMutation) Where(ps ...predicate.Post) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Post, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Post).
func (m *PostMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, post.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, post.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, post.FieldSlug)
	}
	if m.post_status != nil {
		fields = append(fields, post.FieldPostStatusID)
	}
	if m.post_type != nil {
		fields = append(fields, post.FieldPostTypeID)
	}
	if m.primary_category != nil {
		fields = append(fields, post.FieldPrimaryCategoryID)
	}
	if m.headline != nil {
		fields = append(fields, post.FieldHeadline)
	}
	if m.excerpt != nil {
		fields = append(fields, post.FieldExcerpt)
	}
	if m.content != nil {
		fields = append(fields, post.FieldContent)
	}
	if m.meta_title != nil {
		fields = append(fields, post.FieldMetaTitle)
	}
	if m.meta_descr != nil {
		fields = append(fields, post.FieldMetaDescr)
	}
	if m.meta_canonical_url != nil {
		fields = append(fields, post.FieldMetaCanonicalURL)
	}
	if m.meta_robots != nil {
		fields = append(fields, post.FieldMetaRobots)
	}
	if m.custom != nil {
		fields = append(fields, post.FieldCustom)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case post.FieldCreatedAt:
		return m.CreatedAt()
	case post.FieldUpdatedAt:
		return m.UpdatedAt()
	case post.FieldAppID:
		return m.AppID()
	case post.FieldName:
		return m.Name()
	case post.FieldSlug:
		return m.Slug()
	case post.FieldPostStatusID:
		return m.PostStatusID()
	case post.FieldPostTypeID:
		return m.PostTypeID()
	case post.FieldPrimaryCategoryID:
		return m.PrimaryCategoryID()
	case post.FieldHeadline:
		return m.Headline()
	case post.FieldExcerpt:
		return m.Excerpt()
	case post.FieldContent:
		return m.Content()
	case post.FieldMetaTitle:
		return m.MetaTitle()
	case post.FieldMetaDescr:
		return m.MetaDescr()
	case post.FieldMetaCanonicalURL:
		return m.MetaCanonicalURL()
	case post.FieldMetaRobots:
		return m.MetaRobots()
	case post.FieldCustom:
		return m.Custom()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case post.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case post.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case post.FieldAppID:
		return m.OldAppID(ctx)
	case post.FieldName:
		return m.OldName(ctx)
	case post.FieldSlug:
		return m.OldSlug(ctx)
	case post.FieldPostStatusID:
		return m.OldPostStatusID(ctx)
	case post.FieldPostTypeID:
		return m.OldPostTypeID(ctx)
	case post.FieldPrimaryCategoryID:
		return m.OldPrimaryCategoryID(ctx)
	case post.FieldHeadline:
		return m.OldHeadline(ctx)
	case post.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case post.FieldContent:
		return m.OldContent(ctx)
	case post.FieldMetaTitle:
		return m.OldMetaTitle(ctx)
	case post.FieldMetaDescr:
		return m.OldMetaDescr(ctx)
	case post.FieldMetaCanonicalURL:
		return m.OldMetaCanonicalURL(ctx)
	case post.FieldMetaRobots:
		return m.OldMetaRobots(ctx)
	case post.FieldCustom:
		return m.OldCustom(ctx)
	}
	return nil, fmt.Errorf("unknown Post field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) SetField(name string, value ent.Value) error {
	switch name {
	case post.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case post.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case post.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case post.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case post.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case post.FieldPostStatusID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostStatusID(v)
		return nil
	case post.FieldPostTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostTypeID(v)
		return nil
	case post.FieldPrimaryCategoryID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrimaryCategoryID(v)
		return nil
	case post.FieldHeadline:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHeadline(v)
		return nil
	case post.FieldExcerpt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case post.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case post.FieldMetaTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaTitle(v)
		return nil
	case post.FieldMetaDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaDescr(v)
		return nil
	case post.FieldMetaCanonicalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaCanonicalURL(v)
		return nil
	case post.FieldMetaRobots:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaRobots(v)
		return nil
	case post.FieldCustom:
		v, ok := value.(map[string]interface{})
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCustom(v)
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Post numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(post.FieldCreatedAt) {
		fields = append(fields, post.FieldCreatedAt)
	}
	if m.FieldCleared(post.FieldUpdatedAt) {
		fields = append(fields, post.FieldUpdatedAt)
	}
	if m.FieldCleared(post.FieldAppID) {
		fields = append(fields, post.FieldAppID)
	}
	if m.FieldCleared(post.FieldName) {
		fields = append(fields, post.FieldName)
	}
	if m.FieldCleared(post.FieldSlug) {
		fields = append(fields, post.FieldSlug)
	}
	if m.FieldCleared(post.FieldPostStatusID) {
		fields = append(fields, post.FieldPostStatusID)
	}
	if m.FieldCleared(post.FieldPostTypeID) {
		fields = append(fields, post.FieldPostTypeID)
	}
	if m.FieldCleared(post.FieldPrimaryCategoryID) {
		fields = append(fields, post.FieldPrimaryCategoryID)
	}
	if m.FieldCleared(post.FieldHeadline) {
		fields = append(fields, post.FieldHeadline)
	}
	if m.FieldCleared(post.FieldExcerpt) {
		fields = append(fields, post.FieldExcerpt)
	}
	if m.FieldCleared(post.FieldContent) {
		fields = append(fields, post.FieldContent)
	}
	if m.FieldCleared(post.FieldMetaTitle) {
		fields = append(fields, post.FieldMetaTitle)
	}
	if m.FieldCleared(post.FieldMetaDescr) {
		fields = append(fields, post.FieldMetaDescr)
	}
	if m.FieldCleared(post.FieldMetaCanonicalURL) {
		fields = append(fields, post.FieldMetaCanonicalURL)
	}
	if m.FieldCleared(post.FieldMetaRobots) {
		fields = append(fields, post.FieldMetaRobots)
	}
	if m.FieldCleared(post.FieldCustom) {
		fields = append(fields, post.FieldCustom)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostMutation) ClearField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case post.FieldAppID:
		m.ClearAppID()
		return nil
	case post.FieldName:
		m.ClearName()
		return nil
	case post.FieldSlug:
		m.ClearSlug()
		return nil
	case post.FieldPostStatusID:
		m.ClearPostStatusID()
		return nil
	case post.FieldPostTypeID:
		m.ClearPostTypeID()
		return nil
	case post.FieldPrimaryCategoryID:
		m.ClearPrimaryCategoryID()
		return nil
	case post.FieldHeadline:
		m.ClearHeadline()
		return nil
	case post.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	case post.FieldContent:
		m.ClearContent()
		return nil
	case post.FieldMetaTitle:
		m.ClearMetaTitle()
		return nil
	case post.FieldMetaDescr:
		m.ClearMetaDescr()
		return nil
	case post.FieldMetaCanonicalURL:
		m.ClearMetaCanonicalURL()
		return nil
	case post.FieldMetaRobots:
		m.ClearMetaRobots()
		return nil
	case post.FieldCustom:
		m.ClearCustom()
		return nil
	}
	return fmt.Errorf("unknown Post nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostMutation) ResetField(name string) error {
	switch name {
	case post.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case post.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case post.FieldAppID:
		m.ResetAppID()
		return nil
	case post.FieldName:
		m.ResetName()
		return nil
	case post.FieldSlug:
		m.ResetSlug()
		return nil
	case post.FieldPostStatusID:
		m.ResetPostStatusID()
		return nil
	case post.FieldPostTypeID:
		m.ResetPostTypeID()
		return nil
	case post.FieldPrimaryCategoryID:
		m.ResetPrimaryCategoryID()
		return nil
	case post.FieldHeadline:
		m.ResetHeadline()
		return nil
	case post.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case post.FieldContent:
		m.ResetContent()
		return nil
	case post.FieldMetaTitle:
		m.ResetMetaTitle()
		return nil
	case post.FieldMetaDescr:
		m.ResetMetaDescr()
		return nil
	case post.FieldMetaCanonicalURL:
		m.ResetMetaCanonicalURL()
		return nil
	case post.FieldMetaRobots:
		m.ResetMetaRobots()
		return nil
	case post.FieldCustom:
		m.ResetCustom()
		return nil
	}
	return fmt.Errorf("unknown Post field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.post_status != nil {
		edges = append(edges, post.EdgePostStatus)
	}
	if m.post_type != nil {
		edges = append(edges, post.EdgePostType)
	}
	if m.primary_category != nil {
		edges = append(edges, post.EdgePrimaryCategory)
	}
	if m.post_tags != nil {
		edges = append(edges, post.EdgePostTags)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case post.EdgePostStatus:
		if id := m.post_status; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgePostType:
		if id := m.post_type; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgePrimaryCategory:
		if id := m.primary_category; id != nil {
			return []ent.Value{*id}
		}
	case post.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.post_tags))
		for id := range m.post_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedpost_tags != nil {
		edges = append(edges, post.EdgePostTags)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case post.EdgePostTags:
		ids := make([]ent.Value, 0, len(m.removedpost_tags))
		for id := range m.removedpost_tags {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedpost_status {
		edges = append(edges, post.EdgePostStatus)
	}
	if m.clearedpost_type {
		edges = append(edges, post.EdgePostType)
	}
	if m.clearedprimary_category {
		edges = append(edges, post.EdgePrimaryCategory)
	}
	if m.clearedpost_tags {
		edges = append(edges, post.EdgePostTags)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostMutation) EdgeCleared(name string) bool {
	switch name {
	case post.EdgePostStatus:
		return m.clearedpost_status
	case post.EdgePostType:
		return m.clearedpost_type
	case post.EdgePrimaryCategory:
		return m.clearedprimary_category
	case post.EdgePostTags:
		return m.clearedpost_tags
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostMutation) ClearEdge(name string) error {
	switch name {
	case post.EdgePostStatus:
		m.ClearPostStatus()
		return nil
	case post.EdgePostType:
		m.ClearPostType()
		return nil
	case post.EdgePrimaryCategory:
		m.ClearPrimaryCategory()
		return nil
	}
	return fmt.Errorf("unknown Post unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostMutation) ResetEdge(name string) error {
	switch name {
	case post.EdgePostStatus:
		m.ResetPostStatus()
		return nil
	case post.EdgePostType:
		m.ResetPostType()
		return nil
	case post.EdgePrimaryCategory:
		m.ResetPrimaryCategory()
		return nil
	case post.EdgePostTags:
		m.ResetPostTags()
		return nil
	}
	return fmt.Errorf("unknown Post edge %s", name)
}

// PostCategoryMutation represents an operation that mutates the PostCategory nodes in the graph.
type PostCategoryMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	app_id             *string
	name               *string
	slug               *string
	status             *string
	excerpt            *string
	content            *string
	meta_title         *string
	meta_descr         *string
	meta_canonical_url *string
	meta_robots        *string
	clearedFields      map[string]struct{}
	posts              map[string]struct{}
	removedposts       map[string]struct{}
	clearedposts       bool
	parent             *string
	clearedparent      bool
	children           map[string]struct{}
	removedchildren    map[string]struct{}
	clearedchildren    bool
	done               bool
	oldValue           func(context.Context) (*PostCategory, error)
	predicates         []predicate.PostCategory
}

var _ ent.Mutation = (*PostCategoryMutation)(nil)

// postcategoryOption allows management of the mutation configuration using functional options.
type postcategoryOption func(*PostCategoryMutation)

// newPostCategoryMutation creates new mutation for the PostCategory entity.
func newPostCategoryMutation(c config, op Op, opts ...postcategoryOption) *PostCategoryMutation {
	m := &PostCategoryMutation{
		config:        c,
		op:            op,
		typ:           TypePostCategory,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostCategoryID sets the ID field of the mutation.
func withPostCategoryID(id string) postcategoryOption {
	return func(m *PostCategoryMutation) {
		var (
			err   error
			once  sync.Once
			value *PostCategory
		)
		m.oldValue = func(ctx context.Context) (*PostCategory, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostCategory.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostCategory sets the old PostCategory of the mutation.
func withPostCategory(node *PostCategory) postcategoryOption {
	return func(m *PostCategoryMutation) {
		m.oldValue = func(context.Context) (*PostCategory, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostCategoryMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostCategoryMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostCategory entities.
func (m *PostCategoryMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostCategoryMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostCategoryMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostCategory.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostCategoryMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostCategoryMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PostCategoryMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[postcategory.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PostCategoryMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostCategoryMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, postcategory.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostCategoryMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostCategoryMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PostCategoryMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[postcategory.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PostCategoryMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostCategoryMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, postcategory.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *PostCategoryMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PostCategoryMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *PostCategoryMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[postcategory.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *PostCategoryMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PostCategoryMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, postcategory.FieldAppID)
}

// SetParentID sets the "parent_id" field.
func (m *PostCategoryMutation) SetParentID(s string) {
	m.parent = &s
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *PostCategoryMutation) ParentID() (r string, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldParentID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *PostCategoryMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[postcategory.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *PostCategoryMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *PostCategoryMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, postcategory.FieldParentID)
}

// SetName sets the "name" field.
func (m *PostCategoryMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostCategoryMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PostCategoryMutation) ClearName() {
	m.name = nil
	m.clearedFields[postcategory.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PostCategoryMutation) NameCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PostCategoryMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, postcategory.FieldName)
}

// SetSlug sets the "slug" field.
func (m *PostCategoryMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostCategoryMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostCategoryMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[postcategory.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostCategoryMutation) SlugCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostCategoryMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, postcategory.FieldSlug)
}

// SetStatus sets the "status" field.
func (m *PostCategoryMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PostCategoryMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PostCategoryMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[postcategory.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PostCategoryMutation) StatusCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PostCategoryMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, postcategory.FieldStatus)
}

// SetExcerpt sets the "excerpt" field.
func (m *PostCategoryMutation) SetExcerpt(s string) {
	m.excerpt = &s
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *PostCategoryMutation) Excerpt() (r string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldExcerpt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *PostCategoryMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[postcategory.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *PostCategoryMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *PostCategoryMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, postcategory.FieldExcerpt)
}

// SetContent sets the "content" field.
func (m *PostCategoryMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostCategoryMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *PostCategoryMutation) ClearContent() {
	m.content = nil
	m.clearedFields[postcategory.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *PostCategoryMutation) ContentCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *PostCategoryMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, postcategory.FieldContent)
}

// SetMetaTitle sets the "meta_title" field.
func (m *PostCategoryMutation) SetMetaTitle(s string) {
	m.meta_title = &s
}

// MetaTitle returns the value of the "meta_title" field in the mutation.
func (m *PostCategoryMutation) MetaTitle() (r string, exists bool) {
	v := m.meta_title
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaTitle returns the old "meta_title" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldMetaTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaTitle: %w", err)
	}
	return oldValue.MetaTitle, nil
}

// ClearMetaTitle clears the value of the "meta_title" field.
func (m *PostCategoryMutation) ClearMetaTitle() {
	m.meta_title = nil
	m.clearedFields[postcategory.FieldMetaTitle] = struct{}{}
}

// MetaTitleCleared returns if the "meta_title" field was cleared in this mutation.
func (m *PostCategoryMutation) MetaTitleCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldMetaTitle]
	return ok
}

// ResetMetaTitle resets all changes to the "meta_title" field.
func (m *PostCategoryMutation) ResetMetaTitle() {
	m.meta_title = nil
	delete(m.clearedFields, postcategory.FieldMetaTitle)
}

// SetMetaDescr sets the "meta_descr" field.
func (m *PostCategoryMutation) SetMetaDescr(s string) {
	m.meta_descr = &s
}

// MetaDescr returns the value of the "meta_descr" field in the mutation.
func (m *PostCategoryMutation) MetaDescr() (r string, exists bool) {
	v := m.meta_descr
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaDescr returns the old "meta_descr" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldMetaDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaDescr: %w", err)
	}
	return oldValue.MetaDescr, nil
}

// ClearMetaDescr clears the value of the "meta_descr" field.
func (m *PostCategoryMutation) ClearMetaDescr() {
	m.meta_descr = nil
	m.clearedFields[postcategory.FieldMetaDescr] = struct{}{}
}

// MetaDescrCleared returns if the "meta_descr" field was cleared in this mutation.
func (m *PostCategoryMutation) MetaDescrCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldMetaDescr]
	return ok
}

// ResetMetaDescr resets all changes to the "meta_descr" field.
func (m *PostCategoryMutation) ResetMetaDescr() {
	m.meta_descr = nil
	delete(m.clearedFields, postcategory.FieldMetaDescr)
}

// SetMetaCanonicalURL sets the "meta_canonical_url" field.
func (m *PostCategoryMutation) SetMetaCanonicalURL(s string) {
	m.meta_canonical_url = &s
}

// MetaCanonicalURL returns the value of the "meta_canonical_url" field in the mutation.
func (m *PostCategoryMutation) MetaCanonicalURL() (r string, exists bool) {
	v := m.meta_canonical_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaCanonicalURL returns the old "meta_canonical_url" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldMetaCanonicalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaCanonicalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaCanonicalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaCanonicalURL: %w", err)
	}
	return oldValue.MetaCanonicalURL, nil
}

// ClearMetaCanonicalURL clears the value of the "meta_canonical_url" field.
func (m *PostCategoryMutation) ClearMetaCanonicalURL() {
	m.meta_canonical_url = nil
	m.clearedFields[postcategory.FieldMetaCanonicalURL] = struct{}{}
}

// MetaCanonicalURLCleared returns if the "meta_canonical_url" field was cleared in this mutation.
func (m *PostCategoryMutation) MetaCanonicalURLCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldMetaCanonicalURL]
	return ok
}

// ResetMetaCanonicalURL resets all changes to the "meta_canonical_url" field.
func (m *PostCategoryMutation) ResetMetaCanonicalURL() {
	m.meta_canonical_url = nil
	delete(m.clearedFields, postcategory.FieldMetaCanonicalURL)
}

// SetMetaRobots sets the "meta_robots" field.
func (m *PostCategoryMutation) SetMetaRobots(s string) {
	m.meta_robots = &s
}

// MetaRobots returns the value of the "meta_robots" field in the mutation.
func (m *PostCategoryMutation) MetaRobots() (r string, exists bool) {
	v := m.meta_robots
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaRobots returns the old "meta_robots" field's value of the PostCategory entity.
// If the PostCategory object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostCategoryMutation) OldMetaRobots(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaRobots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaRobots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaRobots: %w", err)
	}
	return oldValue.MetaRobots, nil
}

// ClearMetaRobots clears the value of the "meta_robots" field.
func (m *PostCategoryMutation) ClearMetaRobots() {
	m.meta_robots = nil
	m.clearedFields[postcategory.FieldMetaRobots] = struct{}{}
}

// MetaRobotsCleared returns if the "meta_robots" field was cleared in this mutation.
func (m *PostCategoryMutation) MetaRobotsCleared() bool {
	_, ok := m.clearedFields[postcategory.FieldMetaRobots]
	return ok
}

// ResetMetaRobots resets all changes to the "meta_robots" field.
func (m *PostCategoryMutation) ResetMetaRobots() {
	m.meta_robots = nil
	delete(m.clearedFields, postcategory.FieldMetaRobots)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *PostCategoryMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *PostCategoryMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *PostCategoryMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *PostCategoryMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *PostCategoryMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *PostCategoryMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *PostCategoryMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// ClearParent clears the "parent" edge to the PostCategory entity.
func (m *PostCategoryMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[postcategory.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the PostCategory entity was cleared.
func (m *PostCategoryMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *PostCategoryMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *PostCategoryMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// AddChildIDs adds the "children" edge to the PostCategory entity by ids.
func (m *PostCategoryMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the PostCategory entity.
func (m *PostCategoryMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the PostCategory entity was cleared.
func (m *PostCategoryMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the PostCategory entity by IDs.
func (m *PostCategoryMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the PostCategory entity.
func (m *PostCategoryMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *PostCategoryMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *PostCategoryMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// Where appends a list predicates to the PostCategoryMutation builder.
func (m *PostCategoryMutation) Where(ps ...predicate.PostCategory) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostCategoryMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostCategoryMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostCategory, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostCategoryMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostCategoryMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostCategory).
func (m *PostCategoryMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostCategoryMutation) Fields() []string {
	fields := make([]string, 0, 13)
	if m.created_at != nil {
		fields = append(fields, postcategory.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, postcategory.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, postcategory.FieldAppID)
	}
	if m.parent != nil {
		fields = append(fields, postcategory.FieldParentID)
	}
	if m.name != nil {
		fields = append(fields, postcategory.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, postcategory.FieldSlug)
	}
	if m.status != nil {
		fields = append(fields, postcategory.FieldStatus)
	}
	if m.excerpt != nil {
		fields = append(fields, postcategory.FieldExcerpt)
	}
	if m.content != nil {
		fields = append(fields, postcategory.FieldContent)
	}
	if m.meta_title != nil {
		fields = append(fields, postcategory.FieldMetaTitle)
	}
	if m.meta_descr != nil {
		fields = append(fields, postcategory.FieldMetaDescr)
	}
	if m.meta_canonical_url != nil {
		fields = append(fields, postcategory.FieldMetaCanonicalURL)
	}
	if m.meta_robots != nil {
		fields = append(fields, postcategory.FieldMetaRobots)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostCategoryMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case postcategory.FieldCreatedAt:
		return m.CreatedAt()
	case postcategory.FieldUpdatedAt:
		return m.UpdatedAt()
	case postcategory.FieldAppID:
		return m.AppID()
	case postcategory.FieldParentID:
		return m.ParentID()
	case postcategory.FieldName:
		return m.Name()
	case postcategory.FieldSlug:
		return m.Slug()
	case postcategory.FieldStatus:
		return m.Status()
	case postcategory.FieldExcerpt:
		return m.Excerpt()
	case postcategory.FieldContent:
		return m.Content()
	case postcategory.FieldMetaTitle:
		return m.MetaTitle()
	case postcategory.FieldMetaDescr:
		return m.MetaDescr()
	case postcategory.FieldMetaCanonicalURL:
		return m.MetaCanonicalURL()
	case postcategory.FieldMetaRobots:
		return m.MetaRobots()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostCategoryMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case postcategory.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case postcategory.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case postcategory.FieldAppID:
		return m.OldAppID(ctx)
	case postcategory.FieldParentID:
		return m.OldParentID(ctx)
	case postcategory.FieldName:
		return m.OldName(ctx)
	case postcategory.FieldSlug:
		return m.OldSlug(ctx)
	case postcategory.FieldStatus:
		return m.OldStatus(ctx)
	case postcategory.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case postcategory.FieldContent:
		return m.OldContent(ctx)
	case postcategory.FieldMetaTitle:
		return m.OldMetaTitle(ctx)
	case postcategory.FieldMetaDescr:
		return m.OldMetaDescr(ctx)
	case postcategory.FieldMetaCanonicalURL:
		return m.OldMetaCanonicalURL(ctx)
	case postcategory.FieldMetaRobots:
		return m.OldMetaRobots(ctx)
	}
	return nil, fmt.Errorf("unknown PostCategory field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostCategoryMutation) SetField(name string, value ent.Value) error {
	switch name {
	case postcategory.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case postcategory.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case postcategory.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case postcategory.FieldParentID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case postcategory.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case postcategory.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case postcategory.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case postcategory.FieldExcerpt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case postcategory.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case postcategory.FieldMetaTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaTitle(v)
		return nil
	case postcategory.FieldMetaDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaDescr(v)
		return nil
	case postcategory.FieldMetaCanonicalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaCanonicalURL(v)
		return nil
	case postcategory.FieldMetaRobots:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaRobots(v)
		return nil
	}
	return fmt.Errorf("unknown PostCategory field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostCategoryMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostCategoryMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostCategoryMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostCategory numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostCategoryMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(postcategory.FieldCreatedAt) {
		fields = append(fields, postcategory.FieldCreatedAt)
	}
	if m.FieldCleared(postcategory.FieldUpdatedAt) {
		fields = append(fields, postcategory.FieldUpdatedAt)
	}
	if m.FieldCleared(postcategory.FieldAppID) {
		fields = append(fields, postcategory.FieldAppID)
	}
	if m.FieldCleared(postcategory.FieldParentID) {
		fields = append(fields, postcategory.FieldParentID)
	}
	if m.FieldCleared(postcategory.FieldName) {
		fields = append(fields, postcategory.FieldName)
	}
	if m.FieldCleared(postcategory.FieldSlug) {
		fields = append(fields, postcategory.FieldSlug)
	}
	if m.FieldCleared(postcategory.FieldStatus) {
		fields = append(fields, postcategory.FieldStatus)
	}
	if m.FieldCleared(postcategory.FieldExcerpt) {
		fields = append(fields, postcategory.FieldExcerpt)
	}
	if m.FieldCleared(postcategory.FieldContent) {
		fields = append(fields, postcategory.FieldContent)
	}
	if m.FieldCleared(postcategory.FieldMetaTitle) {
		fields = append(fields, postcategory.FieldMetaTitle)
	}
	if m.FieldCleared(postcategory.FieldMetaDescr) {
		fields = append(fields, postcategory.FieldMetaDescr)
	}
	if m.FieldCleared(postcategory.FieldMetaCanonicalURL) {
		fields = append(fields, postcategory.FieldMetaCanonicalURL)
	}
	if m.FieldCleared(postcategory.FieldMetaRobots) {
		fields = append(fields, postcategory.FieldMetaRobots)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostCategoryMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostCategoryMutation) ClearField(name string) error {
	switch name {
	case postcategory.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case postcategory.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case postcategory.FieldAppID:
		m.ClearAppID()
		return nil
	case postcategory.FieldParentID:
		m.ClearParentID()
		return nil
	case postcategory.FieldName:
		m.ClearName()
		return nil
	case postcategory.FieldSlug:
		m.ClearSlug()
		return nil
	case postcategory.FieldStatus:
		m.ClearStatus()
		return nil
	case postcategory.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	case postcategory.FieldContent:
		m.ClearContent()
		return nil
	case postcategory.FieldMetaTitle:
		m.ClearMetaTitle()
		return nil
	case postcategory.FieldMetaDescr:
		m.ClearMetaDescr()
		return nil
	case postcategory.FieldMetaCanonicalURL:
		m.ClearMetaCanonicalURL()
		return nil
	case postcategory.FieldMetaRobots:
		m.ClearMetaRobots()
		return nil
	}
	return fmt.Errorf("unknown PostCategory nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostCategoryMutation) ResetField(name string) error {
	switch name {
	case postcategory.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case postcategory.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case postcategory.FieldAppID:
		m.ResetAppID()
		return nil
	case postcategory.FieldParentID:
		m.ResetParentID()
		return nil
	case postcategory.FieldName:
		m.ResetName()
		return nil
	case postcategory.FieldSlug:
		m.ResetSlug()
		return nil
	case postcategory.FieldStatus:
		m.ResetStatus()
		return nil
	case postcategory.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case postcategory.FieldContent:
		m.ResetContent()
		return nil
	case postcategory.FieldMetaTitle:
		m.ResetMetaTitle()
		return nil
	case postcategory.FieldMetaDescr:
		m.ResetMetaDescr()
		return nil
	case postcategory.FieldMetaCanonicalURL:
		m.ResetMetaCanonicalURL()
		return nil
	case postcategory.FieldMetaRobots:
		m.ResetMetaRobots()
		return nil
	}
	return fmt.Errorf("unknown PostCategory field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostCategoryMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.posts != nil {
		edges = append(edges, postcategory.EdgePosts)
	}
	if m.parent != nil {
		edges = append(edges, postcategory.EdgeParent)
	}
	if m.children != nil {
		edges = append(edges, postcategory.EdgeChildren)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostCategoryMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case postcategory.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case postcategory.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case postcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostCategoryMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedposts != nil {
		edges = append(edges, postcategory.EdgePosts)
	}
	if m.removedchildren != nil {
		edges = append(edges, postcategory.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostCategoryMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case postcategory.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case postcategory.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostCategoryMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedposts {
		edges = append(edges, postcategory.EdgePosts)
	}
	if m.clearedparent {
		edges = append(edges, postcategory.EdgeParent)
	}
	if m.clearedchildren {
		edges = append(edges, postcategory.EdgeChildren)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostCategoryMutation) EdgeCleared(name string) bool {
	switch name {
	case postcategory.EdgePosts:
		return m.clearedposts
	case postcategory.EdgeParent:
		return m.clearedparent
	case postcategory.EdgeChildren:
		return m.clearedchildren
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostCategoryMutation) ClearEdge(name string) error {
	switch name {
	case postcategory.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown PostCategory unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostCategoryMutation) ResetEdge(name string) error {
	switch name {
	case postcategory.EdgePosts:
		m.ResetPosts()
		return nil
	case postcategory.EdgeParent:
		m.ResetParent()
		return nil
	case postcategory.EdgeChildren:
		m.ResetChildren()
		return nil
	}
	return fmt.Errorf("unknown PostCategory edge %s", name)
}

// PostStatusMutation represents an operation that mutates the PostStatus nodes in the graph.
type PostStatusMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	app_id           *string
	name             *string
	slug             *string
	status           *bool
	clearedFields    map[string]struct{}
	post_type        *string
	clearedpost_type bool
	posts            map[string]struct{}
	removedposts     map[string]struct{}
	clearedposts     bool
	done             bool
	oldValue         func(context.Context) (*PostStatus, error)
	predicates       []predicate.PostStatus
}

var _ ent.Mutation = (*PostStatusMutation)(nil)

// poststatusOption allows management of the mutation configuration using functional options.
type poststatusOption func(*PostStatusMutation)

// newPostStatusMutation creates new mutation for the PostStatus entity.
func newPostStatusMutation(c config, op Op, opts ...poststatusOption) *PostStatusMutation {
	m := &PostStatusMutation{
		config:        c,
		op:            op,
		typ:           TypePostStatus,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostStatusID sets the ID field of the mutation.
func withPostStatusID(id string) poststatusOption {
	return func(m *PostStatusMutation) {
		var (
			err   error
			once  sync.Once
			value *PostStatus
		)
		m.oldValue = func(ctx context.Context) (*PostStatus, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostStatus.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostStatus sets the old PostStatus of the mutation.
func withPostStatus(node *PostStatus) poststatusOption {
	return func(m *PostStatusMutation) {
		m.oldValue = func(context.Context) (*PostStatus, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostStatusMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostStatusMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostStatus entities.
func (m *PostStatusMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostStatusMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostStatusMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostStatus.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostStatusMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostStatusMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostStatus entity.
// If the PostStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostStatusMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PostStatusMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[poststatus.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PostStatusMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[poststatus.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostStatusMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, poststatus.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostStatusMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostStatusMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostStatus entity.
// If the PostStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostStatusMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PostStatusMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[poststatus.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PostStatusMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[poststatus.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostStatusMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, poststatus.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *PostStatusMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PostStatusMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the PostStatus entity.
// If the PostStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostStatusMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *PostStatusMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[poststatus.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *PostStatusMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[poststatus.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PostStatusMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, poststatus.FieldAppID)
}

// SetName sets the "name" field.
func (m *PostStatusMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostStatusMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostStatus entity.
// If the PostStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostStatusMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PostStatusMutation) ClearName() {
	m.name = nil
	m.clearedFields[poststatus.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PostStatusMutation) NameCleared() bool {
	_, ok := m.clearedFields[poststatus.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PostStatusMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, poststatus.FieldName)
}

// SetSlug sets the "slug" field.
func (m *PostStatusMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostStatusMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the PostStatus entity.
// If the PostStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostStatusMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostStatusMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[poststatus.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostStatusMutation) SlugCleared() bool {
	_, ok := m.clearedFields[poststatus.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostStatusMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, poststatus.FieldSlug)
}

// SetStatus sets the "status" field.
func (m *PostStatusMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *PostStatusMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PostStatus entity.
// If the PostStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostStatusMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PostStatusMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[poststatus.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PostStatusMutation) StatusCleared() bool {
	_, ok := m.clearedFields[poststatus.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PostStatusMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, poststatus.FieldStatus)
}

// SetPostTypeID sets the "post_type_id" field.
func (m *PostStatusMutation) SetPostTypeID(s string) {
	m.post_type = &s
}

// PostTypeID returns the value of the "post_type_id" field in the mutation.
func (m *PostStatusMutation) PostTypeID() (r string, exists bool) {
	v := m.post_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPostTypeID returns the old "post_type_id" field's value of the PostStatus entity.
// If the PostStatus object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostStatusMutation) OldPostTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostTypeID: %w", err)
	}
	return oldValue.PostTypeID, nil
}

// ClearPostTypeID clears the value of the "post_type_id" field.
func (m *PostStatusMutation) ClearPostTypeID() {
	m.post_type = nil
	m.clearedFields[poststatus.FieldPostTypeID] = struct{}{}
}

// PostTypeIDCleared returns if the "post_type_id" field was cleared in this mutation.
func (m *PostStatusMutation) PostTypeIDCleared() bool {
	_, ok := m.clearedFields[poststatus.FieldPostTypeID]
	return ok
}

// ResetPostTypeID resets all changes to the "post_type_id" field.
func (m *PostStatusMutation) ResetPostTypeID() {
	m.post_type = nil
	delete(m.clearedFields, poststatus.FieldPostTypeID)
}

// ClearPostType clears the "post_type" edge to the PostType entity.
func (m *PostStatusMutation) ClearPostType() {
	m.clearedpost_type = true
	m.clearedFields[poststatus.FieldPostTypeID] = struct{}{}
}

// PostTypeCleared reports if the "post_type" edge to the PostType entity was cleared.
func (m *PostStatusMutation) PostTypeCleared() bool {
	return m.PostTypeIDCleared() || m.clearedpost_type
}

// PostTypeIDs returns the "post_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostTypeID instead. It exists only for internal usage by the builders.
func (m *PostStatusMutation) PostTypeIDs() (ids []string) {
	if id := m.post_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPostType resets all changes to the "post_type" edge.
func (m *PostStatusMutation) ResetPostType() {
	m.post_type = nil
	m.clearedpost_type = false
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *PostStatusMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *PostStatusMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *PostStatusMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *PostStatusMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *PostStatusMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *PostStatusMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *PostStatusMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the PostStatusMutation builder.
func (m *PostStatusMutation) Where(ps ...predicate.PostStatus) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostStatusMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostStatusMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostStatus, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostStatusMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostStatusMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostStatus).
func (m *PostStatusMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostStatusMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, poststatus.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, poststatus.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, poststatus.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, poststatus.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, poststatus.FieldSlug)
	}
	if m.status != nil {
		fields = append(fields, poststatus.FieldStatus)
	}
	if m.post_type != nil {
		fields = append(fields, poststatus.FieldPostTypeID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostStatusMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case poststatus.FieldCreatedAt:
		return m.CreatedAt()
	case poststatus.FieldUpdatedAt:
		return m.UpdatedAt()
	case poststatus.FieldAppID:
		return m.AppID()
	case poststatus.FieldName:
		return m.Name()
	case poststatus.FieldSlug:
		return m.Slug()
	case poststatus.FieldStatus:
		return m.Status()
	case poststatus.FieldPostTypeID:
		return m.PostTypeID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostStatusMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case poststatus.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case poststatus.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case poststatus.FieldAppID:
		return m.OldAppID(ctx)
	case poststatus.FieldName:
		return m.OldName(ctx)
	case poststatus.FieldSlug:
		return m.OldSlug(ctx)
	case poststatus.FieldStatus:
		return m.OldStatus(ctx)
	case poststatus.FieldPostTypeID:
		return m.OldPostTypeID(ctx)
	}
	return nil, fmt.Errorf("unknown PostStatus field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostStatusMutation) SetField(name string, value ent.Value) error {
	switch name {
	case poststatus.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case poststatus.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case poststatus.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case poststatus.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case poststatus.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case poststatus.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case poststatus.FieldPostTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostTypeID(v)
		return nil
	}
	return fmt.Errorf("unknown PostStatus field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostStatusMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostStatusMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostStatusMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostStatus numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostStatusMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(poststatus.FieldCreatedAt) {
		fields = append(fields, poststatus.FieldCreatedAt)
	}
	if m.FieldCleared(poststatus.FieldUpdatedAt) {
		fields = append(fields, poststatus.FieldUpdatedAt)
	}
	if m.FieldCleared(poststatus.FieldAppID) {
		fields = append(fields, poststatus.FieldAppID)
	}
	if m.FieldCleared(poststatus.FieldName) {
		fields = append(fields, poststatus.FieldName)
	}
	if m.FieldCleared(poststatus.FieldSlug) {
		fields = append(fields, poststatus.FieldSlug)
	}
	if m.FieldCleared(poststatus.FieldStatus) {
		fields = append(fields, poststatus.FieldStatus)
	}
	if m.FieldCleared(poststatus.FieldPostTypeID) {
		fields = append(fields, poststatus.FieldPostTypeID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostStatusMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostStatusMutation) ClearField(name string) error {
	switch name {
	case poststatus.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case poststatus.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case poststatus.FieldAppID:
		m.ClearAppID()
		return nil
	case poststatus.FieldName:
		m.ClearName()
		return nil
	case poststatus.FieldSlug:
		m.ClearSlug()
		return nil
	case poststatus.FieldStatus:
		m.ClearStatus()
		return nil
	case poststatus.FieldPostTypeID:
		m.ClearPostTypeID()
		return nil
	}
	return fmt.Errorf("unknown PostStatus nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostStatusMutation) ResetField(name string) error {
	switch name {
	case poststatus.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case poststatus.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case poststatus.FieldAppID:
		m.ResetAppID()
		return nil
	case poststatus.FieldName:
		m.ResetName()
		return nil
	case poststatus.FieldSlug:
		m.ResetSlug()
		return nil
	case poststatus.FieldStatus:
		m.ResetStatus()
		return nil
	case poststatus.FieldPostTypeID:
		m.ResetPostTypeID()
		return nil
	}
	return fmt.Errorf("unknown PostStatus field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostStatusMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.post_type != nil {
		edges = append(edges, poststatus.EdgePostType)
	}
	if m.posts != nil {
		edges = append(edges, poststatus.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostStatusMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case poststatus.EdgePostType:
		if id := m.post_type; id != nil {
			return []ent.Value{*id}
		}
	case poststatus.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostStatusMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedposts != nil {
		edges = append(edges, poststatus.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostStatusMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case poststatus.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostStatusMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedpost_type {
		edges = append(edges, poststatus.EdgePostType)
	}
	if m.clearedposts {
		edges = append(edges, poststatus.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostStatusMutation) EdgeCleared(name string) bool {
	switch name {
	case poststatus.EdgePostType:
		return m.clearedpost_type
	case poststatus.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostStatusMutation) ClearEdge(name string) error {
	switch name {
	case poststatus.EdgePostType:
		m.ClearPostType()
		return nil
	}
	return fmt.Errorf("unknown PostStatus unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostStatusMutation) ResetEdge(name string) error {
	switch name {
	case poststatus.EdgePostType:
		m.ResetPostType()
		return nil
	case poststatus.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown PostStatus edge %s", name)
}

// PostTagMutation represents an operation that mutates the PostTag nodes in the graph.
type PostTagMutation struct {
	config
	op                 Op
	typ                string
	id                 *string
	created_at         *time.Time
	updated_at         *time.Time
	app_id             *string
	name               *string
	slug               *string
	status             *string
	excerpt            *string
	meta_title         *string
	meta_descr         *string
	meta_canonical_url *string
	meta_robots        *string
	clearedFields      map[string]struct{}
	posts              map[string]struct{}
	removedposts       map[string]struct{}
	clearedposts       bool
	done               bool
	oldValue           func(context.Context) (*PostTag, error)
	predicates         []predicate.PostTag
}

var _ ent.Mutation = (*PostTagMutation)(nil)

// posttagOption allows management of the mutation configuration using functional options.
type posttagOption func(*PostTagMutation)

// newPostTagMutation creates new mutation for the PostTag entity.
func newPostTagMutation(c config, op Op, opts ...posttagOption) *PostTagMutation {
	m := &PostTagMutation{
		config:        c,
		op:            op,
		typ:           TypePostTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostTagID sets the ID field of the mutation.
func withPostTagID(id string) posttagOption {
	return func(m *PostTagMutation) {
		var (
			err   error
			once  sync.Once
			value *PostTag
		)
		m.oldValue = func(ctx context.Context) (*PostTag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostTag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostTag sets the old PostTag of the mutation.
func withPostTag(node *PostTag) posttagOption {
	return func(m *PostTagMutation) {
		m.oldValue = func(context.Context) (*PostTag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostTagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostTagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostTag entities.
func (m *PostTagMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostTagMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostTagMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostTag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostTagMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostTagMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PostTagMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[posttag.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PostTagMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[posttag.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostTagMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, posttag.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostTagMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostTagMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PostTagMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[posttag.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PostTagMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[posttag.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostTagMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, posttag.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *PostTagMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PostTagMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *PostTagMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[posttag.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *PostTagMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[posttag.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PostTagMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, posttag.FieldAppID)
}

// SetName sets the "name" field.
func (m *PostTagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostTagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PostTagMutation) ClearName() {
	m.name = nil
	m.clearedFields[posttag.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PostTagMutation) NameCleared() bool {
	_, ok := m.clearedFields[posttag.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PostTagMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, posttag.FieldName)
}

// SetSlug sets the "slug" field.
func (m *PostTagMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostTagMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostTagMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[posttag.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostTagMutation) SlugCleared() bool {
	_, ok := m.clearedFields[posttag.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostTagMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, posttag.FieldSlug)
}

// SetStatus sets the "status" field.
func (m *PostTagMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PostTagMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PostTagMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[posttag.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PostTagMutation) StatusCleared() bool {
	_, ok := m.clearedFields[posttag.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PostTagMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, posttag.FieldStatus)
}

// SetExcerpt sets the "excerpt" field.
func (m *PostTagMutation) SetExcerpt(s string) {
	m.excerpt = &s
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *PostTagMutation) Excerpt() (r string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldExcerpt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *PostTagMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[posttag.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *PostTagMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[posttag.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *PostTagMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, posttag.FieldExcerpt)
}

// SetMetaTitle sets the "meta_title" field.
func (m *PostTagMutation) SetMetaTitle(s string) {
	m.meta_title = &s
}

// MetaTitle returns the value of the "meta_title" field in the mutation.
func (m *PostTagMutation) MetaTitle() (r string, exists bool) {
	v := m.meta_title
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaTitle returns the old "meta_title" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldMetaTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaTitle: %w", err)
	}
	return oldValue.MetaTitle, nil
}

// ClearMetaTitle clears the value of the "meta_title" field.
func (m *PostTagMutation) ClearMetaTitle() {
	m.meta_title = nil
	m.clearedFields[posttag.FieldMetaTitle] = struct{}{}
}

// MetaTitleCleared returns if the "meta_title" field was cleared in this mutation.
func (m *PostTagMutation) MetaTitleCleared() bool {
	_, ok := m.clearedFields[posttag.FieldMetaTitle]
	return ok
}

// ResetMetaTitle resets all changes to the "meta_title" field.
func (m *PostTagMutation) ResetMetaTitle() {
	m.meta_title = nil
	delete(m.clearedFields, posttag.FieldMetaTitle)
}

// SetMetaDescr sets the "meta_descr" field.
func (m *PostTagMutation) SetMetaDescr(s string) {
	m.meta_descr = &s
}

// MetaDescr returns the value of the "meta_descr" field in the mutation.
func (m *PostTagMutation) MetaDescr() (r string, exists bool) {
	v := m.meta_descr
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaDescr returns the old "meta_descr" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldMetaDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaDescr: %w", err)
	}
	return oldValue.MetaDescr, nil
}

// ClearMetaDescr clears the value of the "meta_descr" field.
func (m *PostTagMutation) ClearMetaDescr() {
	m.meta_descr = nil
	m.clearedFields[posttag.FieldMetaDescr] = struct{}{}
}

// MetaDescrCleared returns if the "meta_descr" field was cleared in this mutation.
func (m *PostTagMutation) MetaDescrCleared() bool {
	_, ok := m.clearedFields[posttag.FieldMetaDescr]
	return ok
}

// ResetMetaDescr resets all changes to the "meta_descr" field.
func (m *PostTagMutation) ResetMetaDescr() {
	m.meta_descr = nil
	delete(m.clearedFields, posttag.FieldMetaDescr)
}

// SetMetaCanonicalURL sets the "meta_canonical_url" field.
func (m *PostTagMutation) SetMetaCanonicalURL(s string) {
	m.meta_canonical_url = &s
}

// MetaCanonicalURL returns the value of the "meta_canonical_url" field in the mutation.
func (m *PostTagMutation) MetaCanonicalURL() (r string, exists bool) {
	v := m.meta_canonical_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaCanonicalURL returns the old "meta_canonical_url" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldMetaCanonicalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaCanonicalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaCanonicalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaCanonicalURL: %w", err)
	}
	return oldValue.MetaCanonicalURL, nil
}

// ClearMetaCanonicalURL clears the value of the "meta_canonical_url" field.
func (m *PostTagMutation) ClearMetaCanonicalURL() {
	m.meta_canonical_url = nil
	m.clearedFields[posttag.FieldMetaCanonicalURL] = struct{}{}
}

// MetaCanonicalURLCleared returns if the "meta_canonical_url" field was cleared in this mutation.
func (m *PostTagMutation) MetaCanonicalURLCleared() bool {
	_, ok := m.clearedFields[posttag.FieldMetaCanonicalURL]
	return ok
}

// ResetMetaCanonicalURL resets all changes to the "meta_canonical_url" field.
func (m *PostTagMutation) ResetMetaCanonicalURL() {
	m.meta_canonical_url = nil
	delete(m.clearedFields, posttag.FieldMetaCanonicalURL)
}

// SetMetaRobots sets the "meta_robots" field.
func (m *PostTagMutation) SetMetaRobots(s string) {
	m.meta_robots = &s
}

// MetaRobots returns the value of the "meta_robots" field in the mutation.
func (m *PostTagMutation) MetaRobots() (r string, exists bool) {
	v := m.meta_robots
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaRobots returns the old "meta_robots" field's value of the PostTag entity.
// If the PostTag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTagMutation) OldMetaRobots(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaRobots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaRobots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaRobots: %w", err)
	}
	return oldValue.MetaRobots, nil
}

// ClearMetaRobots clears the value of the "meta_robots" field.
func (m *PostTagMutation) ClearMetaRobots() {
	m.meta_robots = nil
	m.clearedFields[posttag.FieldMetaRobots] = struct{}{}
}

// MetaRobotsCleared returns if the "meta_robots" field was cleared in this mutation.
func (m *PostTagMutation) MetaRobotsCleared() bool {
	_, ok := m.clearedFields[posttag.FieldMetaRobots]
	return ok
}

// ResetMetaRobots resets all changes to the "meta_robots" field.
func (m *PostTagMutation) ResetMetaRobots() {
	m.meta_robots = nil
	delete(m.clearedFields, posttag.FieldMetaRobots)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *PostTagMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *PostTagMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *PostTagMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *PostTagMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *PostTagMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *PostTagMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *PostTagMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// Where appends a list predicates to the PostTagMutation builder.
func (m *PostTagMutation) Where(ps ...predicate.PostTag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostTagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostTagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostTag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostTagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostTagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostTag).
func (m *PostTagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostTagMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, posttag.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, posttag.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, posttag.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, posttag.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, posttag.FieldSlug)
	}
	if m.status != nil {
		fields = append(fields, posttag.FieldStatus)
	}
	if m.excerpt != nil {
		fields = append(fields, posttag.FieldExcerpt)
	}
	if m.meta_title != nil {
		fields = append(fields, posttag.FieldMetaTitle)
	}
	if m.meta_descr != nil {
		fields = append(fields, posttag.FieldMetaDescr)
	}
	if m.meta_canonical_url != nil {
		fields = append(fields, posttag.FieldMetaCanonicalURL)
	}
	if m.meta_robots != nil {
		fields = append(fields, posttag.FieldMetaRobots)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostTagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case posttag.FieldCreatedAt:
		return m.CreatedAt()
	case posttag.FieldUpdatedAt:
		return m.UpdatedAt()
	case posttag.FieldAppID:
		return m.AppID()
	case posttag.FieldName:
		return m.Name()
	case posttag.FieldSlug:
		return m.Slug()
	case posttag.FieldStatus:
		return m.Status()
	case posttag.FieldExcerpt:
		return m.Excerpt()
	case posttag.FieldMetaTitle:
		return m.MetaTitle()
	case posttag.FieldMetaDescr:
		return m.MetaDescr()
	case posttag.FieldMetaCanonicalURL:
		return m.MetaCanonicalURL()
	case posttag.FieldMetaRobots:
		return m.MetaRobots()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostTagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case posttag.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case posttag.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case posttag.FieldAppID:
		return m.OldAppID(ctx)
	case posttag.FieldName:
		return m.OldName(ctx)
	case posttag.FieldSlug:
		return m.OldSlug(ctx)
	case posttag.FieldStatus:
		return m.OldStatus(ctx)
	case posttag.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case posttag.FieldMetaTitle:
		return m.OldMetaTitle(ctx)
	case posttag.FieldMetaDescr:
		return m.OldMetaDescr(ctx)
	case posttag.FieldMetaCanonicalURL:
		return m.OldMetaCanonicalURL(ctx)
	case posttag.FieldMetaRobots:
		return m.OldMetaRobots(ctx)
	}
	return nil, fmt.Errorf("unknown PostTag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case posttag.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case posttag.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case posttag.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case posttag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case posttag.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case posttag.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case posttag.FieldExcerpt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case posttag.FieldMetaTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaTitle(v)
		return nil
	case posttag.FieldMetaDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaDescr(v)
		return nil
	case posttag.FieldMetaCanonicalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaCanonicalURL(v)
		return nil
	case posttag.FieldMetaRobots:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaRobots(v)
		return nil
	}
	return fmt.Errorf("unknown PostTag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostTagMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostTagMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostTag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostTagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(posttag.FieldCreatedAt) {
		fields = append(fields, posttag.FieldCreatedAt)
	}
	if m.FieldCleared(posttag.FieldUpdatedAt) {
		fields = append(fields, posttag.FieldUpdatedAt)
	}
	if m.FieldCleared(posttag.FieldAppID) {
		fields = append(fields, posttag.FieldAppID)
	}
	if m.FieldCleared(posttag.FieldName) {
		fields = append(fields, posttag.FieldName)
	}
	if m.FieldCleared(posttag.FieldSlug) {
		fields = append(fields, posttag.FieldSlug)
	}
	if m.FieldCleared(posttag.FieldStatus) {
		fields = append(fields, posttag.FieldStatus)
	}
	if m.FieldCleared(posttag.FieldExcerpt) {
		fields = append(fields, posttag.FieldExcerpt)
	}
	if m.FieldCleared(posttag.FieldMetaTitle) {
		fields = append(fields, posttag.FieldMetaTitle)
	}
	if m.FieldCleared(posttag.FieldMetaDescr) {
		fields = append(fields, posttag.FieldMetaDescr)
	}
	if m.FieldCleared(posttag.FieldMetaCanonicalURL) {
		fields = append(fields, posttag.FieldMetaCanonicalURL)
	}
	if m.FieldCleared(posttag.FieldMetaRobots) {
		fields = append(fields, posttag.FieldMetaRobots)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostTagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostTagMutation) ClearField(name string) error {
	switch name {
	case posttag.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case posttag.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case posttag.FieldAppID:
		m.ClearAppID()
		return nil
	case posttag.FieldName:
		m.ClearName()
		return nil
	case posttag.FieldSlug:
		m.ClearSlug()
		return nil
	case posttag.FieldStatus:
		m.ClearStatus()
		return nil
	case posttag.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	case posttag.FieldMetaTitle:
		m.ClearMetaTitle()
		return nil
	case posttag.FieldMetaDescr:
		m.ClearMetaDescr()
		return nil
	case posttag.FieldMetaCanonicalURL:
		m.ClearMetaCanonicalURL()
		return nil
	case posttag.FieldMetaRobots:
		m.ClearMetaRobots()
		return nil
	}
	return fmt.Errorf("unknown PostTag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostTagMutation) ResetField(name string) error {
	switch name {
	case posttag.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case posttag.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case posttag.FieldAppID:
		m.ResetAppID()
		return nil
	case posttag.FieldName:
		m.ResetName()
		return nil
	case posttag.FieldSlug:
		m.ResetSlug()
		return nil
	case posttag.FieldStatus:
		m.ResetStatus()
		return nil
	case posttag.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case posttag.FieldMetaTitle:
		m.ResetMetaTitle()
		return nil
	case posttag.FieldMetaDescr:
		m.ResetMetaDescr()
		return nil
	case posttag.FieldMetaCanonicalURL:
		m.ResetMetaCanonicalURL()
		return nil
	case posttag.FieldMetaRobots:
		m.ResetMetaRobots()
		return nil
	}
	return fmt.Errorf("unknown PostTag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostTagMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.posts != nil {
		edges = append(edges, posttag.EdgePosts)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostTagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case posttag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostTagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedposts != nil {
		edges = append(edges, posttag.EdgePosts)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostTagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case posttag.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostTagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedposts {
		edges = append(edges, posttag.EdgePosts)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostTagMutation) EdgeCleared(name string) bool {
	switch name {
	case posttag.EdgePosts:
		return m.clearedposts
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostTagMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostTag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostTagMutation) ResetEdge(name string) error {
	switch name {
	case posttag.EdgePosts:
		m.ResetPosts()
		return nil
	}
	return fmt.Errorf("unknown PostTag edge %s", name)
}

// PostTypeMutation represents an operation that mutates the PostType nodes in the graph.
type PostTypeMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	app_id                 *string
	name                   *string
	slug                   *string
	status                 *string
	excerpt                *string
	content                *string
	meta_title             *string
	meta_descr             *string
	meta_canonical_url     *string
	meta_robots            *string
	clearedFields          map[string]struct{}
	posts                  map[string]struct{}
	removedposts           map[string]struct{}
	clearedposts           bool
	post_statuses          map[string]struct{}
	removedpost_statuses   map[string]struct{}
	clearedpost_statuses   bool
	post_type_forms        map[string]struct{}
	removedpost_type_forms map[string]struct{}
	clearedpost_type_forms bool
	done                   bool
	oldValue               func(context.Context) (*PostType, error)
	predicates             []predicate.PostType
}

var _ ent.Mutation = (*PostTypeMutation)(nil)

// posttypeOption allows management of the mutation configuration using functional options.
type posttypeOption func(*PostTypeMutation)

// newPostTypeMutation creates new mutation for the PostType entity.
func newPostTypeMutation(c config, op Op, opts ...posttypeOption) *PostTypeMutation {
	m := &PostTypeMutation{
		config:        c,
		op:            op,
		typ:           TypePostType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostTypeID sets the ID field of the mutation.
func withPostTypeID(id string) posttypeOption {
	return func(m *PostTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *PostType
		)
		m.oldValue = func(ctx context.Context) (*PostType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostType sets the old PostType of the mutation.
func withPostType(node *PostType) posttypeOption {
	return func(m *PostTypeMutation) {
		m.oldValue = func(context.Context) (*PostType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostType entities.
func (m *PostTypeMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostTypeMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostTypeMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostTypeMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostTypeMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PostTypeMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[posttype.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PostTypeMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[posttype.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostTypeMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, posttype.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostTypeMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostTypeMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PostTypeMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[posttype.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PostTypeMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[posttype.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostTypeMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, posttype.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *PostTypeMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PostTypeMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *PostTypeMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[posttype.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *PostTypeMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[posttype.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PostTypeMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, posttype.FieldAppID)
}

// SetName sets the "name" field.
func (m *PostTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PostTypeMutation) ClearName() {
	m.name = nil
	m.clearedFields[posttype.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PostTypeMutation) NameCleared() bool {
	_, ok := m.clearedFields[posttype.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PostTypeMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, posttype.FieldName)
}

// SetSlug sets the "slug" field.
func (m *PostTypeMutation) SetSlug(s string) {
	m.slug = &s
}

// Slug returns the value of the "slug" field in the mutation.
func (m *PostTypeMutation) Slug() (r string, exists bool) {
	v := m.slug
	if v == nil {
		return
	}
	return *v, true
}

// OldSlug returns the old "slug" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldSlug(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSlug is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSlug requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSlug: %w", err)
	}
	return oldValue.Slug, nil
}

// ClearSlug clears the value of the "slug" field.
func (m *PostTypeMutation) ClearSlug() {
	m.slug = nil
	m.clearedFields[posttype.FieldSlug] = struct{}{}
}

// SlugCleared returns if the "slug" field was cleared in this mutation.
func (m *PostTypeMutation) SlugCleared() bool {
	_, ok := m.clearedFields[posttype.FieldSlug]
	return ok
}

// ResetSlug resets all changes to the "slug" field.
func (m *PostTypeMutation) ResetSlug() {
	m.slug = nil
	delete(m.clearedFields, posttype.FieldSlug)
}

// SetStatus sets the "status" field.
func (m *PostTypeMutation) SetStatus(s string) {
	m.status = &s
}

// Status returns the value of the "status" field in the mutation.
func (m *PostTypeMutation) Status() (r string, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldStatus(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PostTypeMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[posttype.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PostTypeMutation) StatusCleared() bool {
	_, ok := m.clearedFields[posttype.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PostTypeMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, posttype.FieldStatus)
}

// SetExcerpt sets the "excerpt" field.
func (m *PostTypeMutation) SetExcerpt(s string) {
	m.excerpt = &s
}

// Excerpt returns the value of the "excerpt" field in the mutation.
func (m *PostTypeMutation) Excerpt() (r string, exists bool) {
	v := m.excerpt
	if v == nil {
		return
	}
	return *v, true
}

// OldExcerpt returns the old "excerpt" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldExcerpt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExcerpt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExcerpt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExcerpt: %w", err)
	}
	return oldValue.Excerpt, nil
}

// ClearExcerpt clears the value of the "excerpt" field.
func (m *PostTypeMutation) ClearExcerpt() {
	m.excerpt = nil
	m.clearedFields[posttype.FieldExcerpt] = struct{}{}
}

// ExcerptCleared returns if the "excerpt" field was cleared in this mutation.
func (m *PostTypeMutation) ExcerptCleared() bool {
	_, ok := m.clearedFields[posttype.FieldExcerpt]
	return ok
}

// ResetExcerpt resets all changes to the "excerpt" field.
func (m *PostTypeMutation) ResetExcerpt() {
	m.excerpt = nil
	delete(m.clearedFields, posttype.FieldExcerpt)
}

// SetContent sets the "content" field.
func (m *PostTypeMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *PostTypeMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ClearContent clears the value of the "content" field.
func (m *PostTypeMutation) ClearContent() {
	m.content = nil
	m.clearedFields[posttype.FieldContent] = struct{}{}
}

// ContentCleared returns if the "content" field was cleared in this mutation.
func (m *PostTypeMutation) ContentCleared() bool {
	_, ok := m.clearedFields[posttype.FieldContent]
	return ok
}

// ResetContent resets all changes to the "content" field.
func (m *PostTypeMutation) ResetContent() {
	m.content = nil
	delete(m.clearedFields, posttype.FieldContent)
}

// SetMetaTitle sets the "meta_title" field.
func (m *PostTypeMutation) SetMetaTitle(s string) {
	m.meta_title = &s
}

// MetaTitle returns the value of the "meta_title" field in the mutation.
func (m *PostTypeMutation) MetaTitle() (r string, exists bool) {
	v := m.meta_title
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaTitle returns the old "meta_title" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldMetaTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaTitle: %w", err)
	}
	return oldValue.MetaTitle, nil
}

// ClearMetaTitle clears the value of the "meta_title" field.
func (m *PostTypeMutation) ClearMetaTitle() {
	m.meta_title = nil
	m.clearedFields[posttype.FieldMetaTitle] = struct{}{}
}

// MetaTitleCleared returns if the "meta_title" field was cleared in this mutation.
func (m *PostTypeMutation) MetaTitleCleared() bool {
	_, ok := m.clearedFields[posttype.FieldMetaTitle]
	return ok
}

// ResetMetaTitle resets all changes to the "meta_title" field.
func (m *PostTypeMutation) ResetMetaTitle() {
	m.meta_title = nil
	delete(m.clearedFields, posttype.FieldMetaTitle)
}

// SetMetaDescr sets the "meta_descr" field.
func (m *PostTypeMutation) SetMetaDescr(s string) {
	m.meta_descr = &s
}

// MetaDescr returns the value of the "meta_descr" field in the mutation.
func (m *PostTypeMutation) MetaDescr() (r string, exists bool) {
	v := m.meta_descr
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaDescr returns the old "meta_descr" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldMetaDescr(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaDescr is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaDescr requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaDescr: %w", err)
	}
	return oldValue.MetaDescr, nil
}

// ClearMetaDescr clears the value of the "meta_descr" field.
func (m *PostTypeMutation) ClearMetaDescr() {
	m.meta_descr = nil
	m.clearedFields[posttype.FieldMetaDescr] = struct{}{}
}

// MetaDescrCleared returns if the "meta_descr" field was cleared in this mutation.
func (m *PostTypeMutation) MetaDescrCleared() bool {
	_, ok := m.clearedFields[posttype.FieldMetaDescr]
	return ok
}

// ResetMetaDescr resets all changes to the "meta_descr" field.
func (m *PostTypeMutation) ResetMetaDescr() {
	m.meta_descr = nil
	delete(m.clearedFields, posttype.FieldMetaDescr)
}

// SetMetaCanonicalURL sets the "meta_canonical_url" field.
func (m *PostTypeMutation) SetMetaCanonicalURL(s string) {
	m.meta_canonical_url = &s
}

// MetaCanonicalURL returns the value of the "meta_canonical_url" field in the mutation.
func (m *PostTypeMutation) MetaCanonicalURL() (r string, exists bool) {
	v := m.meta_canonical_url
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaCanonicalURL returns the old "meta_canonical_url" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldMetaCanonicalURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaCanonicalURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaCanonicalURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaCanonicalURL: %w", err)
	}
	return oldValue.MetaCanonicalURL, nil
}

// ClearMetaCanonicalURL clears the value of the "meta_canonical_url" field.
func (m *PostTypeMutation) ClearMetaCanonicalURL() {
	m.meta_canonical_url = nil
	m.clearedFields[posttype.FieldMetaCanonicalURL] = struct{}{}
}

// MetaCanonicalURLCleared returns if the "meta_canonical_url" field was cleared in this mutation.
func (m *PostTypeMutation) MetaCanonicalURLCleared() bool {
	_, ok := m.clearedFields[posttype.FieldMetaCanonicalURL]
	return ok
}

// ResetMetaCanonicalURL resets all changes to the "meta_canonical_url" field.
func (m *PostTypeMutation) ResetMetaCanonicalURL() {
	m.meta_canonical_url = nil
	delete(m.clearedFields, posttype.FieldMetaCanonicalURL)
}

// SetMetaRobots sets the "meta_robots" field.
func (m *PostTypeMutation) SetMetaRobots(s string) {
	m.meta_robots = &s
}

// MetaRobots returns the value of the "meta_robots" field in the mutation.
func (m *PostTypeMutation) MetaRobots() (r string, exists bool) {
	v := m.meta_robots
	if v == nil {
		return
	}
	return *v, true
}

// OldMetaRobots returns the old "meta_robots" field's value of the PostType entity.
// If the PostType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeMutation) OldMetaRobots(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMetaRobots is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMetaRobots requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMetaRobots: %w", err)
	}
	return oldValue.MetaRobots, nil
}

// ClearMetaRobots clears the value of the "meta_robots" field.
func (m *PostTypeMutation) ClearMetaRobots() {
	m.meta_robots = nil
	m.clearedFields[posttype.FieldMetaRobots] = struct{}{}
}

// MetaRobotsCleared returns if the "meta_robots" field was cleared in this mutation.
func (m *PostTypeMutation) MetaRobotsCleared() bool {
	_, ok := m.clearedFields[posttype.FieldMetaRobots]
	return ok
}

// ResetMetaRobots resets all changes to the "meta_robots" field.
func (m *PostTypeMutation) ResetMetaRobots() {
	m.meta_robots = nil
	delete(m.clearedFields, posttype.FieldMetaRobots)
}

// AddPostIDs adds the "posts" edge to the Post entity by ids.
func (m *PostTypeMutation) AddPostIDs(ids ...string) {
	if m.posts == nil {
		m.posts = make(map[string]struct{})
	}
	for i := range ids {
		m.posts[ids[i]] = struct{}{}
	}
}

// ClearPosts clears the "posts" edge to the Post entity.
func (m *PostTypeMutation) ClearPosts() {
	m.clearedposts = true
}

// PostsCleared reports if the "posts" edge to the Post entity was cleared.
func (m *PostTypeMutation) PostsCleared() bool {
	return m.clearedposts
}

// RemovePostIDs removes the "posts" edge to the Post entity by IDs.
func (m *PostTypeMutation) RemovePostIDs(ids ...string) {
	if m.removedposts == nil {
		m.removedposts = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.posts, ids[i])
		m.removedposts[ids[i]] = struct{}{}
	}
}

// RemovedPosts returns the removed IDs of the "posts" edge to the Post entity.
func (m *PostTypeMutation) RemovedPostsIDs() (ids []string) {
	for id := range m.removedposts {
		ids = append(ids, id)
	}
	return
}

// PostsIDs returns the "posts" edge IDs in the mutation.
func (m *PostTypeMutation) PostsIDs() (ids []string) {
	for id := range m.posts {
		ids = append(ids, id)
	}
	return
}

// ResetPosts resets all changes to the "posts" edge.
func (m *PostTypeMutation) ResetPosts() {
	m.posts = nil
	m.clearedposts = false
	m.removedposts = nil
}

// AddPostStatusIDs adds the "post_statuses" edge to the PostStatus entity by ids.
func (m *PostTypeMutation) AddPostStatusIDs(ids ...string) {
	if m.post_statuses == nil {
		m.post_statuses = make(map[string]struct{})
	}
	for i := range ids {
		m.post_statuses[ids[i]] = struct{}{}
	}
}

// ClearPostStatuses clears the "post_statuses" edge to the PostStatus entity.
func (m *PostTypeMutation) ClearPostStatuses() {
	m.clearedpost_statuses = true
}

// PostStatusesCleared reports if the "post_statuses" edge to the PostStatus entity was cleared.
func (m *PostTypeMutation) PostStatusesCleared() bool {
	return m.clearedpost_statuses
}

// RemovePostStatusIDs removes the "post_statuses" edge to the PostStatus entity by IDs.
func (m *PostTypeMutation) RemovePostStatusIDs(ids ...string) {
	if m.removedpost_statuses == nil {
		m.removedpost_statuses = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_statuses, ids[i])
		m.removedpost_statuses[ids[i]] = struct{}{}
	}
}

// RemovedPostStatuses returns the removed IDs of the "post_statuses" edge to the PostStatus entity.
func (m *PostTypeMutation) RemovedPostStatusesIDs() (ids []string) {
	for id := range m.removedpost_statuses {
		ids = append(ids, id)
	}
	return
}

// PostStatusesIDs returns the "post_statuses" edge IDs in the mutation.
func (m *PostTypeMutation) PostStatusesIDs() (ids []string) {
	for id := range m.post_statuses {
		ids = append(ids, id)
	}
	return
}

// ResetPostStatuses resets all changes to the "post_statuses" edge.
func (m *PostTypeMutation) ResetPostStatuses() {
	m.post_statuses = nil
	m.clearedpost_statuses = false
	m.removedpost_statuses = nil
}

// AddPostTypeFormIDs adds the "post_type_forms" edge to the PostTypeForm entity by ids.
func (m *PostTypeMutation) AddPostTypeFormIDs(ids ...string) {
	if m.post_type_forms == nil {
		m.post_type_forms = make(map[string]struct{})
	}
	for i := range ids {
		m.post_type_forms[ids[i]] = struct{}{}
	}
}

// ClearPostTypeForms clears the "post_type_forms" edge to the PostTypeForm entity.
func (m *PostTypeMutation) ClearPostTypeForms() {
	m.clearedpost_type_forms = true
}

// PostTypeFormsCleared reports if the "post_type_forms" edge to the PostTypeForm entity was cleared.
func (m *PostTypeMutation) PostTypeFormsCleared() bool {
	return m.clearedpost_type_forms
}

// RemovePostTypeFormIDs removes the "post_type_forms" edge to the PostTypeForm entity by IDs.
func (m *PostTypeMutation) RemovePostTypeFormIDs(ids ...string) {
	if m.removedpost_type_forms == nil {
		m.removedpost_type_forms = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.post_type_forms, ids[i])
		m.removedpost_type_forms[ids[i]] = struct{}{}
	}
}

// RemovedPostTypeForms returns the removed IDs of the "post_type_forms" edge to the PostTypeForm entity.
func (m *PostTypeMutation) RemovedPostTypeFormsIDs() (ids []string) {
	for id := range m.removedpost_type_forms {
		ids = append(ids, id)
	}
	return
}

// PostTypeFormsIDs returns the "post_type_forms" edge IDs in the mutation.
func (m *PostTypeMutation) PostTypeFormsIDs() (ids []string) {
	for id := range m.post_type_forms {
		ids = append(ids, id)
	}
	return
}

// ResetPostTypeForms resets all changes to the "post_type_forms" edge.
func (m *PostTypeMutation) ResetPostTypeForms() {
	m.post_type_forms = nil
	m.clearedpost_type_forms = false
	m.removedpost_type_forms = nil
}

// Where appends a list predicates to the PostTypeMutation builder.
func (m *PostTypeMutation) Where(ps ...predicate.PostType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostType).
func (m *PostTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostTypeMutation) Fields() []string {
	fields := make([]string, 0, 12)
	if m.created_at != nil {
		fields = append(fields, posttype.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, posttype.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, posttype.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, posttype.FieldName)
	}
	if m.slug != nil {
		fields = append(fields, posttype.FieldSlug)
	}
	if m.status != nil {
		fields = append(fields, posttype.FieldStatus)
	}
	if m.excerpt != nil {
		fields = append(fields, posttype.FieldExcerpt)
	}
	if m.content != nil {
		fields = append(fields, posttype.FieldContent)
	}
	if m.meta_title != nil {
		fields = append(fields, posttype.FieldMetaTitle)
	}
	if m.meta_descr != nil {
		fields = append(fields, posttype.FieldMetaDescr)
	}
	if m.meta_canonical_url != nil {
		fields = append(fields, posttype.FieldMetaCanonicalURL)
	}
	if m.meta_robots != nil {
		fields = append(fields, posttype.FieldMetaRobots)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case posttype.FieldCreatedAt:
		return m.CreatedAt()
	case posttype.FieldUpdatedAt:
		return m.UpdatedAt()
	case posttype.FieldAppID:
		return m.AppID()
	case posttype.FieldName:
		return m.Name()
	case posttype.FieldSlug:
		return m.Slug()
	case posttype.FieldStatus:
		return m.Status()
	case posttype.FieldExcerpt:
		return m.Excerpt()
	case posttype.FieldContent:
		return m.Content()
	case posttype.FieldMetaTitle:
		return m.MetaTitle()
	case posttype.FieldMetaDescr:
		return m.MetaDescr()
	case posttype.FieldMetaCanonicalURL:
		return m.MetaCanonicalURL()
	case posttype.FieldMetaRobots:
		return m.MetaRobots()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case posttype.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case posttype.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case posttype.FieldAppID:
		return m.OldAppID(ctx)
	case posttype.FieldName:
		return m.OldName(ctx)
	case posttype.FieldSlug:
		return m.OldSlug(ctx)
	case posttype.FieldStatus:
		return m.OldStatus(ctx)
	case posttype.FieldExcerpt:
		return m.OldExcerpt(ctx)
	case posttype.FieldContent:
		return m.OldContent(ctx)
	case posttype.FieldMetaTitle:
		return m.OldMetaTitle(ctx)
	case posttype.FieldMetaDescr:
		return m.OldMetaDescr(ctx)
	case posttype.FieldMetaCanonicalURL:
		return m.OldMetaCanonicalURL(ctx)
	case posttype.FieldMetaRobots:
		return m.OldMetaRobots(ctx)
	}
	return nil, fmt.Errorf("unknown PostType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case posttype.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case posttype.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case posttype.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case posttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case posttype.FieldSlug:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSlug(v)
		return nil
	case posttype.FieldStatus:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case posttype.FieldExcerpt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExcerpt(v)
		return nil
	case posttype.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case posttype.FieldMetaTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaTitle(v)
		return nil
	case posttype.FieldMetaDescr:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaDescr(v)
		return nil
	case posttype.FieldMetaCanonicalURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaCanonicalURL(v)
		return nil
	case posttype.FieldMetaRobots:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMetaRobots(v)
		return nil
	}
	return fmt.Errorf("unknown PostType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(posttype.FieldCreatedAt) {
		fields = append(fields, posttype.FieldCreatedAt)
	}
	if m.FieldCleared(posttype.FieldUpdatedAt) {
		fields = append(fields, posttype.FieldUpdatedAt)
	}
	if m.FieldCleared(posttype.FieldAppID) {
		fields = append(fields, posttype.FieldAppID)
	}
	if m.FieldCleared(posttype.FieldName) {
		fields = append(fields, posttype.FieldName)
	}
	if m.FieldCleared(posttype.FieldSlug) {
		fields = append(fields, posttype.FieldSlug)
	}
	if m.FieldCleared(posttype.FieldStatus) {
		fields = append(fields, posttype.FieldStatus)
	}
	if m.FieldCleared(posttype.FieldExcerpt) {
		fields = append(fields, posttype.FieldExcerpt)
	}
	if m.FieldCleared(posttype.FieldContent) {
		fields = append(fields, posttype.FieldContent)
	}
	if m.FieldCleared(posttype.FieldMetaTitle) {
		fields = append(fields, posttype.FieldMetaTitle)
	}
	if m.FieldCleared(posttype.FieldMetaDescr) {
		fields = append(fields, posttype.FieldMetaDescr)
	}
	if m.FieldCleared(posttype.FieldMetaCanonicalURL) {
		fields = append(fields, posttype.FieldMetaCanonicalURL)
	}
	if m.FieldCleared(posttype.FieldMetaRobots) {
		fields = append(fields, posttype.FieldMetaRobots)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostTypeMutation) ClearField(name string) error {
	switch name {
	case posttype.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case posttype.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case posttype.FieldAppID:
		m.ClearAppID()
		return nil
	case posttype.FieldName:
		m.ClearName()
		return nil
	case posttype.FieldSlug:
		m.ClearSlug()
		return nil
	case posttype.FieldStatus:
		m.ClearStatus()
		return nil
	case posttype.FieldExcerpt:
		m.ClearExcerpt()
		return nil
	case posttype.FieldContent:
		m.ClearContent()
		return nil
	case posttype.FieldMetaTitle:
		m.ClearMetaTitle()
		return nil
	case posttype.FieldMetaDescr:
		m.ClearMetaDescr()
		return nil
	case posttype.FieldMetaCanonicalURL:
		m.ClearMetaCanonicalURL()
		return nil
	case posttype.FieldMetaRobots:
		m.ClearMetaRobots()
		return nil
	}
	return fmt.Errorf("unknown PostType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostTypeMutation) ResetField(name string) error {
	switch name {
	case posttype.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case posttype.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case posttype.FieldAppID:
		m.ResetAppID()
		return nil
	case posttype.FieldName:
		m.ResetName()
		return nil
	case posttype.FieldSlug:
		m.ResetSlug()
		return nil
	case posttype.FieldStatus:
		m.ResetStatus()
		return nil
	case posttype.FieldExcerpt:
		m.ResetExcerpt()
		return nil
	case posttype.FieldContent:
		m.ResetContent()
		return nil
	case posttype.FieldMetaTitle:
		m.ResetMetaTitle()
		return nil
	case posttype.FieldMetaDescr:
		m.ResetMetaDescr()
		return nil
	case posttype.FieldMetaCanonicalURL:
		m.ResetMetaCanonicalURL()
		return nil
	case posttype.FieldMetaRobots:
		m.ResetMetaRobots()
		return nil
	}
	return fmt.Errorf("unknown PostType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.posts != nil {
		edges = append(edges, posttype.EdgePosts)
	}
	if m.post_statuses != nil {
		edges = append(edges, posttype.EdgePostStatuses)
	}
	if m.post_type_forms != nil {
		edges = append(edges, posttype.EdgePostTypeForms)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case posttype.EdgePosts:
		ids := make([]ent.Value, 0, len(m.posts))
		for id := range m.posts {
			ids = append(ids, id)
		}
		return ids
	case posttype.EdgePostStatuses:
		ids := make([]ent.Value, 0, len(m.post_statuses))
		for id := range m.post_statuses {
			ids = append(ids, id)
		}
		return ids
	case posttype.EdgePostTypeForms:
		ids := make([]ent.Value, 0, len(m.post_type_forms))
		for id := range m.post_type_forms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedposts != nil {
		edges = append(edges, posttype.EdgePosts)
	}
	if m.removedpost_statuses != nil {
		edges = append(edges, posttype.EdgePostStatuses)
	}
	if m.removedpost_type_forms != nil {
		edges = append(edges, posttype.EdgePostTypeForms)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case posttype.EdgePosts:
		ids := make([]ent.Value, 0, len(m.removedposts))
		for id := range m.removedposts {
			ids = append(ids, id)
		}
		return ids
	case posttype.EdgePostStatuses:
		ids := make([]ent.Value, 0, len(m.removedpost_statuses))
		for id := range m.removedpost_statuses {
			ids = append(ids, id)
		}
		return ids
	case posttype.EdgePostTypeForms:
		ids := make([]ent.Value, 0, len(m.removedpost_type_forms))
		for id := range m.removedpost_type_forms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedposts {
		edges = append(edges, posttype.EdgePosts)
	}
	if m.clearedpost_statuses {
		edges = append(edges, posttype.EdgePostStatuses)
	}
	if m.clearedpost_type_forms {
		edges = append(edges, posttype.EdgePostTypeForms)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case posttype.EdgePosts:
		return m.clearedposts
	case posttype.EdgePostStatuses:
		return m.clearedpost_statuses
	case posttype.EdgePostTypeForms:
		return m.clearedpost_type_forms
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown PostType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostTypeMutation) ResetEdge(name string) error {
	switch name {
	case posttype.EdgePosts:
		m.ResetPosts()
		return nil
	case posttype.EdgePostStatuses:
		m.ResetPostStatuses()
		return nil
	case posttype.EdgePostTypeForms:
		m.ResetPostTypeForms()
		return nil
	}
	return fmt.Errorf("unknown PostType edge %s", name)
}

// PostTypeFormMutation represents an operation that mutates the PostTypeForm nodes in the graph.
type PostTypeFormMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	app_id           *string
	name             *string
	status           *bool
	body             *jsonslice.JsonSlice
	appendbody       jsonslice.JsonSlice
	clearedFields    map[string]struct{}
	post_type        *string
	clearedpost_type bool
	done             bool
	oldValue         func(context.Context) (*PostTypeForm, error)
	predicates       []predicate.PostTypeForm
}

var _ ent.Mutation = (*PostTypeFormMutation)(nil)

// posttypeformOption allows management of the mutation configuration using functional options.
type posttypeformOption func(*PostTypeFormMutation)

// newPostTypeFormMutation creates new mutation for the PostTypeForm entity.
func newPostTypeFormMutation(c config, op Op, opts ...posttypeformOption) *PostTypeFormMutation {
	m := &PostTypeFormMutation{
		config:        c,
		op:            op,
		typ:           TypePostTypeForm,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPostTypeFormID sets the ID field of the mutation.
func withPostTypeFormID(id string) posttypeformOption {
	return func(m *PostTypeFormMutation) {
		var (
			err   error
			once  sync.Once
			value *PostTypeForm
		)
		m.oldValue = func(ctx context.Context) (*PostTypeForm, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().PostTypeForm.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPostTypeForm sets the old PostTypeForm of the mutation.
func withPostTypeForm(node *PostTypeForm) posttypeformOption {
	return func(m *PostTypeFormMutation) {
		m.oldValue = func(context.Context) (*PostTypeForm, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PostTypeFormMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PostTypeFormMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of PostTypeForm entities.
func (m *PostTypeFormMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PostTypeFormMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PostTypeFormMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().PostTypeForm.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *PostTypeFormMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *PostTypeFormMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the PostTypeForm entity.
// If the PostTypeForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeFormMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *PostTypeFormMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[posttypeform.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *PostTypeFormMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[posttypeform.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *PostTypeFormMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, posttypeform.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *PostTypeFormMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *PostTypeFormMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the PostTypeForm entity.
// If the PostTypeForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeFormMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *PostTypeFormMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[posttypeform.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *PostTypeFormMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[posttypeform.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *PostTypeFormMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, posttypeform.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *PostTypeFormMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *PostTypeFormMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the PostTypeForm entity.
// If the PostTypeForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeFormMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *PostTypeFormMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[posttypeform.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *PostTypeFormMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[posttypeform.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *PostTypeFormMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, posttypeform.FieldAppID)
}

// SetName sets the "name" field.
func (m *PostTypeFormMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PostTypeFormMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the PostTypeForm entity.
// If the PostTypeForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeFormMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *PostTypeFormMutation) ClearName() {
	m.name = nil
	m.clearedFields[posttypeform.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *PostTypeFormMutation) NameCleared() bool {
	_, ok := m.clearedFields[posttypeform.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *PostTypeFormMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, posttypeform.FieldName)
}

// SetStatus sets the "status" field.
func (m *PostTypeFormMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *PostTypeFormMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the PostTypeForm entity.
// If the PostTypeForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeFormMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *PostTypeFormMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[posttypeform.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *PostTypeFormMutation) StatusCleared() bool {
	_, ok := m.clearedFields[posttypeform.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *PostTypeFormMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, posttypeform.FieldStatus)
}

// SetPostTypeID sets the "post_type_id" field.
func (m *PostTypeFormMutation) SetPostTypeID(s string) {
	m.post_type = &s
}

// PostTypeID returns the value of the "post_type_id" field in the mutation.
func (m *PostTypeFormMutation) PostTypeID() (r string, exists bool) {
	v := m.post_type
	if v == nil {
		return
	}
	return *v, true
}

// OldPostTypeID returns the old "post_type_id" field's value of the PostTypeForm entity.
// If the PostTypeForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeFormMutation) OldPostTypeID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostTypeID: %w", err)
	}
	return oldValue.PostTypeID, nil
}

// ClearPostTypeID clears the value of the "post_type_id" field.
func (m *PostTypeFormMutation) ClearPostTypeID() {
	m.post_type = nil
	m.clearedFields[posttypeform.FieldPostTypeID] = struct{}{}
}

// PostTypeIDCleared returns if the "post_type_id" field was cleared in this mutation.
func (m *PostTypeFormMutation) PostTypeIDCleared() bool {
	_, ok := m.clearedFields[posttypeform.FieldPostTypeID]
	return ok
}

// ResetPostTypeID resets all changes to the "post_type_id" field.
func (m *PostTypeFormMutation) ResetPostTypeID() {
	m.post_type = nil
	delete(m.clearedFields, posttypeform.FieldPostTypeID)
}

// SetBody sets the "body" field.
func (m *PostTypeFormMutation) SetBody(js jsonslice.JsonSlice) {
	m.body = &js
	m.appendbody = nil
}

// Body returns the value of the "body" field in the mutation.
func (m *PostTypeFormMutation) Body() (r jsonslice.JsonSlice, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the PostTypeForm entity.
// If the PostTypeForm object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PostTypeFormMutation) OldBody(ctx context.Context) (v jsonslice.JsonSlice, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// AppendBody adds js to the "body" field.
func (m *PostTypeFormMutation) AppendBody(js jsonslice.JsonSlice) {
	m.appendbody = append(m.appendbody, js...)
}

// AppendedBody returns the list of values that were appended to the "body" field in this mutation.
func (m *PostTypeFormMutation) AppendedBody() (jsonslice.JsonSlice, bool) {
	if len(m.appendbody) == 0 {
		return nil, false
	}
	return m.appendbody, true
}

// ClearBody clears the value of the "body" field.
func (m *PostTypeFormMutation) ClearBody() {
	m.body = nil
	m.appendbody = nil
	m.clearedFields[posttypeform.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *PostTypeFormMutation) BodyCleared() bool {
	_, ok := m.clearedFields[posttypeform.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *PostTypeFormMutation) ResetBody() {
	m.body = nil
	m.appendbody = nil
	delete(m.clearedFields, posttypeform.FieldBody)
}

// ClearPostType clears the "post_type" edge to the PostType entity.
func (m *PostTypeFormMutation) ClearPostType() {
	m.clearedpost_type = true
	m.clearedFields[posttypeform.FieldPostTypeID] = struct{}{}
}

// PostTypeCleared reports if the "post_type" edge to the PostType entity was cleared.
func (m *PostTypeFormMutation) PostTypeCleared() bool {
	return m.PostTypeIDCleared() || m.clearedpost_type
}

// PostTypeIDs returns the "post_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PostTypeID instead. It exists only for internal usage by the builders.
func (m *PostTypeFormMutation) PostTypeIDs() (ids []string) {
	if id := m.post_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPostType resets all changes to the "post_type" edge.
func (m *PostTypeFormMutation) ResetPostType() {
	m.post_type = nil
	m.clearedpost_type = false
}

// Where appends a list predicates to the PostTypeFormMutation builder.
func (m *PostTypeFormMutation) Where(ps ...predicate.PostTypeForm) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PostTypeFormMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PostTypeFormMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.PostTypeForm, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PostTypeFormMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PostTypeFormMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (PostTypeForm).
func (m *PostTypeFormMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PostTypeFormMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, posttypeform.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, posttypeform.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, posttypeform.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, posttypeform.FieldName)
	}
	if m.status != nil {
		fields = append(fields, posttypeform.FieldStatus)
	}
	if m.post_type != nil {
		fields = append(fields, posttypeform.FieldPostTypeID)
	}
	if m.body != nil {
		fields = append(fields, posttypeform.FieldBody)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PostTypeFormMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case posttypeform.FieldCreatedAt:
		return m.CreatedAt()
	case posttypeform.FieldUpdatedAt:
		return m.UpdatedAt()
	case posttypeform.FieldAppID:
		return m.AppID()
	case posttypeform.FieldName:
		return m.Name()
	case posttypeform.FieldStatus:
		return m.Status()
	case posttypeform.FieldPostTypeID:
		return m.PostTypeID()
	case posttypeform.FieldBody:
		return m.Body()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PostTypeFormMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case posttypeform.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case posttypeform.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case posttypeform.FieldAppID:
		return m.OldAppID(ctx)
	case posttypeform.FieldName:
		return m.OldName(ctx)
	case posttypeform.FieldStatus:
		return m.OldStatus(ctx)
	case posttypeform.FieldPostTypeID:
		return m.OldPostTypeID(ctx)
	case posttypeform.FieldBody:
		return m.OldBody(ctx)
	}
	return nil, fmt.Errorf("unknown PostTypeForm field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTypeFormMutation) SetField(name string, value ent.Value) error {
	switch name {
	case posttypeform.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case posttypeform.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case posttypeform.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case posttypeform.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case posttypeform.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case posttypeform.FieldPostTypeID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostTypeID(v)
		return nil
	case posttypeform.FieldBody:
		v, ok := value.(jsonslice.JsonSlice)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	}
	return fmt.Errorf("unknown PostTypeForm field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PostTypeFormMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PostTypeFormMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PostTypeFormMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown PostTypeForm numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PostTypeFormMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(posttypeform.FieldCreatedAt) {
		fields = append(fields, posttypeform.FieldCreatedAt)
	}
	if m.FieldCleared(posttypeform.FieldUpdatedAt) {
		fields = append(fields, posttypeform.FieldUpdatedAt)
	}
	if m.FieldCleared(posttypeform.FieldAppID) {
		fields = append(fields, posttypeform.FieldAppID)
	}
	if m.FieldCleared(posttypeform.FieldName) {
		fields = append(fields, posttypeform.FieldName)
	}
	if m.FieldCleared(posttypeform.FieldStatus) {
		fields = append(fields, posttypeform.FieldStatus)
	}
	if m.FieldCleared(posttypeform.FieldPostTypeID) {
		fields = append(fields, posttypeform.FieldPostTypeID)
	}
	if m.FieldCleared(posttypeform.FieldBody) {
		fields = append(fields, posttypeform.FieldBody)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PostTypeFormMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PostTypeFormMutation) ClearField(name string) error {
	switch name {
	case posttypeform.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case posttypeform.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case posttypeform.FieldAppID:
		m.ClearAppID()
		return nil
	case posttypeform.FieldName:
		m.ClearName()
		return nil
	case posttypeform.FieldStatus:
		m.ClearStatus()
		return nil
	case posttypeform.FieldPostTypeID:
		m.ClearPostTypeID()
		return nil
	case posttypeform.FieldBody:
		m.ClearBody()
		return nil
	}
	return fmt.Errorf("unknown PostTypeForm nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PostTypeFormMutation) ResetField(name string) error {
	switch name {
	case posttypeform.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case posttypeform.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case posttypeform.FieldAppID:
		m.ResetAppID()
		return nil
	case posttypeform.FieldName:
		m.ResetName()
		return nil
	case posttypeform.FieldStatus:
		m.ResetStatus()
		return nil
	case posttypeform.FieldPostTypeID:
		m.ResetPostTypeID()
		return nil
	case posttypeform.FieldBody:
		m.ResetBody()
		return nil
	}
	return fmt.Errorf("unknown PostTypeForm field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PostTypeFormMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.post_type != nil {
		edges = append(edges, posttypeform.EdgePostType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PostTypeFormMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case posttypeform.EdgePostType:
		if id := m.post_type; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PostTypeFormMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PostTypeFormMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PostTypeFormMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedpost_type {
		edges = append(edges, posttypeform.EdgePostType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PostTypeFormMutation) EdgeCleared(name string) bool {
	switch name {
	case posttypeform.EdgePostType:
		return m.clearedpost_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PostTypeFormMutation) ClearEdge(name string) error {
	switch name {
	case posttypeform.EdgePostType:
		m.ClearPostType()
		return nil
	}
	return fmt.Errorf("unknown PostTypeForm unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PostTypeFormMutation) ResetEdge(name string) error {
	switch name {
	case posttypeform.EdgePostType:
		m.ResetPostType()
		return nil
	}
	return fmt.Errorf("unknown PostTypeForm edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	app_id        *string
	ip            *string
	user_agent    *string
	payload       *string
	expires_at    *time.Time
	clearedFields map[string]struct{}
	user          *string
	cleareduser   bool
	done          bool
	oldValue      func(context.Context) (*Session, error)
	predicates    []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id string) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *SessionMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[session.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *SessionMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, session.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *SessionMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[session.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *SessionMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[session.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, session.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *SessionMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *SessionMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *SessionMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[session.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *SessionMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[session.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *SessionMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, session.FieldAppID)
}

// SetUserID sets the "user_id" field.
func (m *SessionMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SessionMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *SessionMutation) ClearUserID() {
	m.user = nil
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *SessionMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[session.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SessionMutation) ResetUserID() {
	m.user = nil
	delete(m.clearedFields, session.FieldUserID)
}

// SetIP sets the "ip" field.
func (m *SessionMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *SessionMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *SessionMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[session.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *SessionMutation) IPCleared() bool {
	_, ok := m.clearedFields[session.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *SessionMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, session.FieldIP)
}

// SetUserAgent sets the "user_agent" field.
func (m *SessionMutation) SetUserAgent(s string) {
	m.user_agent = &s
}

// UserAgent returns the value of the "user_agent" field in the mutation.
func (m *SessionMutation) UserAgent() (r string, exists bool) {
	v := m.user_agent
	if v == nil {
		return
	}
	return *v, true
}

// OldUserAgent returns the old "user_agent" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUserAgent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserAgent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserAgent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserAgent: %w", err)
	}
	return oldValue.UserAgent, nil
}

// ClearUserAgent clears the value of the "user_agent" field.
func (m *SessionMutation) ClearUserAgent() {
	m.user_agent = nil
	m.clearedFields[session.FieldUserAgent] = struct{}{}
}

// UserAgentCleared returns if the "user_agent" field was cleared in this mutation.
func (m *SessionMutation) UserAgentCleared() bool {
	_, ok := m.clearedFields[session.FieldUserAgent]
	return ok
}

// ResetUserAgent resets all changes to the "user_agent" field.
func (m *SessionMutation) ResetUserAgent() {
	m.user_agent = nil
	delete(m.clearedFields, session.FieldUserAgent)
}

// SetPayload sets the "payload" field.
func (m *SessionMutation) SetPayload(s string) {
	m.payload = &s
}

// Payload returns the value of the "payload" field in the mutation.
func (m *SessionMutation) Payload() (r string, exists bool) {
	v := m.payload
	if v == nil {
		return
	}
	return *v, true
}

// OldPayload returns the old "payload" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldPayload(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPayload is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPayload requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPayload: %w", err)
	}
	return oldValue.Payload, nil
}

// ClearPayload clears the value of the "payload" field.
func (m *SessionMutation) ClearPayload() {
	m.payload = nil
	m.clearedFields[session.FieldPayload] = struct{}{}
}

// PayloadCleared returns if the "payload" field was cleared in this mutation.
func (m *SessionMutation) PayloadCleared() bool {
	_, ok := m.clearedFields[session.FieldPayload]
	return ok
}

// ResetPayload resets all changes to the "payload" field.
func (m *SessionMutation) ResetPayload() {
	m.payload = nil
	delete(m.clearedFields, session.FieldPayload)
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *SessionMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[session.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *SessionMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[session.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, session.FieldExpiresAt)
}

// ClearUser clears the "user" edge to the User entity.
func (m *SessionMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[session.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SessionMutation) UserCleared() bool {
	return m.UserIDCleared() || m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SessionMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, session.FieldAppID)
	}
	if m.user != nil {
		fields = append(fields, session.FieldUserID)
	}
	if m.ip != nil {
		fields = append(fields, session.FieldIP)
	}
	if m.user_agent != nil {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.payload != nil {
		fields = append(fields, session.FieldPayload)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	case session.FieldAppID:
		return m.AppID()
	case session.FieldUserID:
		return m.UserID()
	case session.FieldIP:
		return m.IP()
	case session.FieldUserAgent:
		return m.UserAgent()
	case session.FieldPayload:
		return m.Payload()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case session.FieldAppID:
		return m.OldAppID(ctx)
	case session.FieldUserID:
		return m.OldUserID(ctx)
	case session.FieldIP:
		return m.OldIP(ctx)
	case session.FieldUserAgent:
		return m.OldUserAgent(ctx)
	case session.FieldPayload:
		return m.OldPayload(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case session.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case session.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case session.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case session.FieldUserAgent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserAgent(v)
		return nil
	case session.FieldPayload:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPayload(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(session.FieldCreatedAt) {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.FieldCleared(session.FieldUpdatedAt) {
		fields = append(fields, session.FieldUpdatedAt)
	}
	if m.FieldCleared(session.FieldAppID) {
		fields = append(fields, session.FieldAppID)
	}
	if m.FieldCleared(session.FieldUserID) {
		fields = append(fields, session.FieldUserID)
	}
	if m.FieldCleared(session.FieldIP) {
		fields = append(fields, session.FieldIP)
	}
	if m.FieldCleared(session.FieldUserAgent) {
		fields = append(fields, session.FieldUserAgent)
	}
	if m.FieldCleared(session.FieldPayload) {
		fields = append(fields, session.FieldPayload)
	}
	if m.FieldCleared(session.FieldExpiresAt) {
		fields = append(fields, session.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case session.FieldAppID:
		m.ClearAppID()
		return nil
	case session.FieldUserID:
		m.ClearUserID()
		return nil
	case session.FieldIP:
		m.ClearIP()
		return nil
	case session.FieldUserAgent:
		m.ClearUserAgent()
		return nil
	case session.FieldPayload:
		m.ClearPayload()
		return nil
	case session.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case session.FieldAppID:
		m.ResetAppID()
		return nil
	case session.FieldUserID:
		m.ResetUserID()
		return nil
	case session.FieldIP:
		m.ResetIP()
		return nil
	case session.FieldUserAgent:
		m.ResetUserAgent()
		return nil
	case session.FieldPayload:
		m.ResetPayload()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, session.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// TempMutation represents an operation that mutates the Temp nodes in the graph.
type TempMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	app_id        *string
	ip            *string
	_type         *string
	body          *jsontype.JSON
	appendbody    jsontype.JSON
	meta          *jsontype.JSON
	appendmeta    jsontype.JSON
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Temp, error)
	predicates    []predicate.Temp
}

var _ ent.Mutation = (*TempMutation)(nil)

// tempOption allows management of the mutation configuration using functional options.
type tempOption func(*TempMutation)

// newTempMutation creates new mutation for the Temp entity.
func newTempMutation(c config, op Op, opts ...tempOption) *TempMutation {
	m := &TempMutation{
		config:        c,
		op:            op,
		typ:           TypeTemp,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTempID sets the ID field of the mutation.
func withTempID(id string) tempOption {
	return func(m *TempMutation) {
		var (
			err   error
			once  sync.Once
			value *Temp
		)
		m.oldValue = func(ctx context.Context) (*Temp, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Temp.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemp sets the old Temp of the mutation.
func withTemp(node *Temp) tempOption {
	return func(m *TempMutation) {
		m.oldValue = func(context.Context) (*Temp, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TempMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TempMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Temp entities.
func (m *TempMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TempMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TempMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Temp.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TempMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TempMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Temp entity.
// If the Temp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TempMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TempMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[temp.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TempMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[temp.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TempMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, temp.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TempMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TempMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Temp entity.
// If the Temp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TempMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TempMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[temp.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TempMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[temp.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TempMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, temp.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *TempMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *TempMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Temp entity.
// If the Temp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TempMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *TempMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[temp.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *TempMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[temp.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *TempMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, temp.FieldAppID)
}

// SetIP sets the "ip" field.
func (m *TempMutation) SetIP(s string) {
	m.ip = &s
}

// IP returns the value of the "ip" field in the mutation.
func (m *TempMutation) IP() (r string, exists bool) {
	v := m.ip
	if v == nil {
		return
	}
	return *v, true
}

// OldIP returns the old "ip" field's value of the Temp entity.
// If the Temp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TempMutation) OldIP(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIP is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIP requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIP: %w", err)
	}
	return oldValue.IP, nil
}

// ClearIP clears the value of the "ip" field.
func (m *TempMutation) ClearIP() {
	m.ip = nil
	m.clearedFields[temp.FieldIP] = struct{}{}
}

// IPCleared returns if the "ip" field was cleared in this mutation.
func (m *TempMutation) IPCleared() bool {
	_, ok := m.clearedFields[temp.FieldIP]
	return ok
}

// ResetIP resets all changes to the "ip" field.
func (m *TempMutation) ResetIP() {
	m.ip = nil
	delete(m.clearedFields, temp.FieldIP)
}

// SetType sets the "type" field.
func (m *TempMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TempMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Temp entity.
// If the Temp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TempMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ClearType clears the value of the "type" field.
func (m *TempMutation) ClearType() {
	m._type = nil
	m.clearedFields[temp.FieldType] = struct{}{}
}

// TypeCleared returns if the "type" field was cleared in this mutation.
func (m *TempMutation) TypeCleared() bool {
	_, ok := m.clearedFields[temp.FieldType]
	return ok
}

// ResetType resets all changes to the "type" field.
func (m *TempMutation) ResetType() {
	m._type = nil
	delete(m.clearedFields, temp.FieldType)
}

// SetBody sets the "body" field.
func (m *TempMutation) SetBody(j jsontype.JSON) {
	m.body = &j
	m.appendbody = nil
}

// Body returns the value of the "body" field in the mutation.
func (m *TempMutation) Body() (r jsontype.JSON, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Temp entity.
// If the Temp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TempMutation) OldBody(ctx context.Context) (v jsontype.JSON, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// AppendBody adds j to the "body" field.
func (m *TempMutation) AppendBody(j jsontype.JSON) {
	m.appendbody = append(m.appendbody, j...)
}

// AppendedBody returns the list of values that were appended to the "body" field in this mutation.
func (m *TempMutation) AppendedBody() (jsontype.JSON, bool) {
	if len(m.appendbody) == 0 {
		return nil, false
	}
	return m.appendbody, true
}

// ClearBody clears the value of the "body" field.
func (m *TempMutation) ClearBody() {
	m.body = nil
	m.appendbody = nil
	m.clearedFields[temp.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *TempMutation) BodyCleared() bool {
	_, ok := m.clearedFields[temp.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *TempMutation) ResetBody() {
	m.body = nil
	m.appendbody = nil
	delete(m.clearedFields, temp.FieldBody)
}

// SetMeta sets the "meta" field.
func (m *TempMutation) SetMeta(j jsontype.JSON) {
	m.meta = &j
	m.appendmeta = nil
}

// Meta returns the value of the "meta" field in the mutation.
func (m *TempMutation) Meta() (r jsontype.JSON, exists bool) {
	v := m.meta
	if v == nil {
		return
	}
	return *v, true
}

// OldMeta returns the old "meta" field's value of the Temp entity.
// If the Temp object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TempMutation) OldMeta(ctx context.Context) (v jsontype.JSON, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMeta is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMeta requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMeta: %w", err)
	}
	return oldValue.Meta, nil
}

// AppendMeta adds j to the "meta" field.
func (m *TempMutation) AppendMeta(j jsontype.JSON) {
	m.appendmeta = append(m.appendmeta, j...)
}

// AppendedMeta returns the list of values that were appended to the "meta" field in this mutation.
func (m *TempMutation) AppendedMeta() (jsontype.JSON, bool) {
	if len(m.appendmeta) == 0 {
		return nil, false
	}
	return m.appendmeta, true
}

// ClearMeta clears the value of the "meta" field.
func (m *TempMutation) ClearMeta() {
	m.meta = nil
	m.appendmeta = nil
	m.clearedFields[temp.FieldMeta] = struct{}{}
}

// MetaCleared returns if the "meta" field was cleared in this mutation.
func (m *TempMutation) MetaCleared() bool {
	_, ok := m.clearedFields[temp.FieldMeta]
	return ok
}

// ResetMeta resets all changes to the "meta" field.
func (m *TempMutation) ResetMeta() {
	m.meta = nil
	m.appendmeta = nil
	delete(m.clearedFields, temp.FieldMeta)
}

// Where appends a list predicates to the TempMutation builder.
func (m *TempMutation) Where(ps ...predicate.Temp) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TempMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TempMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Temp, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TempMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TempMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Temp).
func (m *TempMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TempMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, temp.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, temp.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, temp.FieldAppID)
	}
	if m.ip != nil {
		fields = append(fields, temp.FieldIP)
	}
	if m._type != nil {
		fields = append(fields, temp.FieldType)
	}
	if m.body != nil {
		fields = append(fields, temp.FieldBody)
	}
	if m.meta != nil {
		fields = append(fields, temp.FieldMeta)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TempMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case temp.FieldCreatedAt:
		return m.CreatedAt()
	case temp.FieldUpdatedAt:
		return m.UpdatedAt()
	case temp.FieldAppID:
		return m.AppID()
	case temp.FieldIP:
		return m.IP()
	case temp.FieldType:
		return m.GetType()
	case temp.FieldBody:
		return m.Body()
	case temp.FieldMeta:
		return m.Meta()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TempMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case temp.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case temp.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case temp.FieldAppID:
		return m.OldAppID(ctx)
	case temp.FieldIP:
		return m.OldIP(ctx)
	case temp.FieldType:
		return m.OldType(ctx)
	case temp.FieldBody:
		return m.OldBody(ctx)
	case temp.FieldMeta:
		return m.OldMeta(ctx)
	}
	return nil, fmt.Errorf("unknown Temp field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TempMutation) SetField(name string, value ent.Value) error {
	switch name {
	case temp.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case temp.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case temp.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case temp.FieldIP:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIP(v)
		return nil
	case temp.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case temp.FieldBody:
		v, ok := value.(jsontype.JSON)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case temp.FieldMeta:
		v, ok := value.(jsontype.JSON)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMeta(v)
		return nil
	}
	return fmt.Errorf("unknown Temp field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TempMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TempMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TempMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Temp numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TempMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(temp.FieldCreatedAt) {
		fields = append(fields, temp.FieldCreatedAt)
	}
	if m.FieldCleared(temp.FieldUpdatedAt) {
		fields = append(fields, temp.FieldUpdatedAt)
	}
	if m.FieldCleared(temp.FieldAppID) {
		fields = append(fields, temp.FieldAppID)
	}
	if m.FieldCleared(temp.FieldIP) {
		fields = append(fields, temp.FieldIP)
	}
	if m.FieldCleared(temp.FieldType) {
		fields = append(fields, temp.FieldType)
	}
	if m.FieldCleared(temp.FieldBody) {
		fields = append(fields, temp.FieldBody)
	}
	if m.FieldCleared(temp.FieldMeta) {
		fields = append(fields, temp.FieldMeta)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TempMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TempMutation) ClearField(name string) error {
	switch name {
	case temp.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case temp.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case temp.FieldAppID:
		m.ClearAppID()
		return nil
	case temp.FieldIP:
		m.ClearIP()
		return nil
	case temp.FieldType:
		m.ClearType()
		return nil
	case temp.FieldBody:
		m.ClearBody()
		return nil
	case temp.FieldMeta:
		m.ClearMeta()
		return nil
	}
	return fmt.Errorf("unknown Temp nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TempMutation) ResetField(name string) error {
	switch name {
	case temp.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case temp.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case temp.FieldAppID:
		m.ResetAppID()
		return nil
	case temp.FieldIP:
		m.ResetIP()
		return nil
	case temp.FieldType:
		m.ResetType()
		return nil
	case temp.FieldBody:
		m.ResetBody()
		return nil
	case temp.FieldMeta:
		m.ResetMeta()
		return nil
	}
	return fmt.Errorf("unknown Temp field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TempMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TempMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TempMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TempMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TempMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TempMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TempMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Temp unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TempMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Temp edge %s", name)
}

// TemplMutation represents an operation that mutates the Templ nodes in the graph.
type TemplMutation struct {
	config
	op            Op
	typ           string
	id            *string
	created_at    *time.Time
	updated_at    *time.Time
	app_id        *string
	name          *string
	body          *string
	compiled      *string
	status        *bool
	clearedFields map[string]struct{}
	done          bool
	oldValue      func(context.Context) (*Templ, error)
	predicates    []predicate.Templ
}

var _ ent.Mutation = (*TemplMutation)(nil)

// templOption allows management of the mutation configuration using functional options.
type templOption func(*TemplMutation)

// newTemplMutation creates new mutation for the Templ entity.
func newTemplMutation(c config, op Op, opts ...templOption) *TemplMutation {
	m := &TemplMutation{
		config:        c,
		op:            op,
		typ:           TypeTempl,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemplID sets the ID field of the mutation.
func withTemplID(id string) templOption {
	return func(m *TemplMutation) {
		var (
			err   error
			once  sync.Once
			value *Templ
		)
		m.oldValue = func(ctx context.Context) (*Templ, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Templ.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTempl sets the old Templ of the mutation.
func withTempl(node *Templ) templOption {
	return func(m *TemplMutation) {
		m.oldValue = func(context.Context) (*Templ, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemplMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemplMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Templ entities.
func (m *TemplMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemplMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemplMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Templ.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TemplMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemplMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Templ entity.
// If the Templ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TemplMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[templ.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TemplMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[templ.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemplMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, templ.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TemplMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TemplMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Templ entity.
// If the Templ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TemplMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[templ.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TemplMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[templ.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TemplMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, templ.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *TemplMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *TemplMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Templ entity.
// If the Templ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *TemplMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[templ.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *TemplMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[templ.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *TemplMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, templ.FieldAppID)
}

// SetName sets the "name" field.
func (m *TemplMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TemplMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Templ entity.
// If the Templ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *TemplMutation) ClearName() {
	m.name = nil
	m.clearedFields[templ.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *TemplMutation) NameCleared() bool {
	_, ok := m.clearedFields[templ.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *TemplMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, templ.FieldName)
}

// SetBody sets the "body" field.
func (m *TemplMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *TemplMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Templ entity.
// If the Templ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ClearBody clears the value of the "body" field.
func (m *TemplMutation) ClearBody() {
	m.body = nil
	m.clearedFields[templ.FieldBody] = struct{}{}
}

// BodyCleared returns if the "body" field was cleared in this mutation.
func (m *TemplMutation) BodyCleared() bool {
	_, ok := m.clearedFields[templ.FieldBody]
	return ok
}

// ResetBody resets all changes to the "body" field.
func (m *TemplMutation) ResetBody() {
	m.body = nil
	delete(m.clearedFields, templ.FieldBody)
}

// SetCompiled sets the "compiled" field.
func (m *TemplMutation) SetCompiled(s string) {
	m.compiled = &s
}

// Compiled returns the value of the "compiled" field in the mutation.
func (m *TemplMutation) Compiled() (r string, exists bool) {
	v := m.compiled
	if v == nil {
		return
	}
	return *v, true
}

// OldCompiled returns the old "compiled" field's value of the Templ entity.
// If the Templ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplMutation) OldCompiled(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompiled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompiled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompiled: %w", err)
	}
	return oldValue.Compiled, nil
}

// ClearCompiled clears the value of the "compiled" field.
func (m *TemplMutation) ClearCompiled() {
	m.compiled = nil
	m.clearedFields[templ.FieldCompiled] = struct{}{}
}

// CompiledCleared returns if the "compiled" field was cleared in this mutation.
func (m *TemplMutation) CompiledCleared() bool {
	_, ok := m.clearedFields[templ.FieldCompiled]
	return ok
}

// ResetCompiled resets all changes to the "compiled" field.
func (m *TemplMutation) ResetCompiled() {
	m.compiled = nil
	delete(m.clearedFields, templ.FieldCompiled)
}

// SetStatus sets the "status" field.
func (m *TemplMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *TemplMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Templ entity.
// If the Templ object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemplMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *TemplMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[templ.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *TemplMutation) StatusCleared() bool {
	_, ok := m.clearedFields[templ.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *TemplMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, templ.FieldStatus)
}

// Where appends a list predicates to the TemplMutation builder.
func (m *TemplMutation) Where(ps ...predicate.Templ) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemplMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemplMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Templ, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemplMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemplMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Templ).
func (m *TemplMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemplMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.created_at != nil {
		fields = append(fields, templ.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, templ.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, templ.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, templ.FieldName)
	}
	if m.body != nil {
		fields = append(fields, templ.FieldBody)
	}
	if m.compiled != nil {
		fields = append(fields, templ.FieldCompiled)
	}
	if m.status != nil {
		fields = append(fields, templ.FieldStatus)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemplMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case templ.FieldCreatedAt:
		return m.CreatedAt()
	case templ.FieldUpdatedAt:
		return m.UpdatedAt()
	case templ.FieldAppID:
		return m.AppID()
	case templ.FieldName:
		return m.Name()
	case templ.FieldBody:
		return m.Body()
	case templ.FieldCompiled:
		return m.Compiled()
	case templ.FieldStatus:
		return m.Status()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemplMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case templ.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case templ.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case templ.FieldAppID:
		return m.OldAppID(ctx)
	case templ.FieldName:
		return m.OldName(ctx)
	case templ.FieldBody:
		return m.OldBody(ctx)
	case templ.FieldCompiled:
		return m.OldCompiled(ctx)
	case templ.FieldStatus:
		return m.OldStatus(ctx)
	}
	return nil, fmt.Errorf("unknown Templ field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplMutation) SetField(name string, value ent.Value) error {
	switch name {
	case templ.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case templ.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case templ.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case templ.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case templ.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case templ.FieldCompiled:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompiled(v)
		return nil
	case templ.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	}
	return fmt.Errorf("unknown Templ field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemplMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemplMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemplMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Templ numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemplMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(templ.FieldCreatedAt) {
		fields = append(fields, templ.FieldCreatedAt)
	}
	if m.FieldCleared(templ.FieldUpdatedAt) {
		fields = append(fields, templ.FieldUpdatedAt)
	}
	if m.FieldCleared(templ.FieldAppID) {
		fields = append(fields, templ.FieldAppID)
	}
	if m.FieldCleared(templ.FieldName) {
		fields = append(fields, templ.FieldName)
	}
	if m.FieldCleared(templ.FieldBody) {
		fields = append(fields, templ.FieldBody)
	}
	if m.FieldCleared(templ.FieldCompiled) {
		fields = append(fields, templ.FieldCompiled)
	}
	if m.FieldCleared(templ.FieldStatus) {
		fields = append(fields, templ.FieldStatus)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemplMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemplMutation) ClearField(name string) error {
	switch name {
	case templ.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case templ.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case templ.FieldAppID:
		m.ClearAppID()
		return nil
	case templ.FieldName:
		m.ClearName()
		return nil
	case templ.FieldBody:
		m.ClearBody()
		return nil
	case templ.FieldCompiled:
		m.ClearCompiled()
		return nil
	case templ.FieldStatus:
		m.ClearStatus()
		return nil
	}
	return fmt.Errorf("unknown Templ nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemplMutation) ResetField(name string) error {
	switch name {
	case templ.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case templ.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case templ.FieldAppID:
		m.ResetAppID()
		return nil
	case templ.FieldName:
		m.ResetName()
		return nil
	case templ.FieldBody:
		m.ResetBody()
		return nil
	case templ.FieldCompiled:
		m.ResetCompiled()
		return nil
	case templ.FieldStatus:
		m.ResetStatus()
		return nil
	}
	return fmt.Errorf("unknown Templ field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemplMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemplMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemplMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemplMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemplMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemplMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemplMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Templ unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemplMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Templ edge %s", name)
}

// TodoMutation represents an operation that mutates the Todo nodes in the graph.
type TodoMutation struct {
	config
	op              Op
	typ             string
	id              *string
	created_at      *time.Time
	updated_at      *time.Time
	app_id          *string
	text            *string
	status          *todo.Status
	priority        *int
	addpriority     *int
	clearedFields   map[string]struct{}
	children        map[string]struct{}
	removedchildren map[string]struct{}
	clearedchildren bool
	parent          *string
	clearedparent   bool
	done            bool
	oldValue        func(context.Context) (*Todo, error)
	predicates      []predicate.Todo
}

var _ ent.Mutation = (*TodoMutation)(nil)

// todoOption allows management of the mutation configuration using functional options.
type todoOption func(*TodoMutation)

// newTodoMutation creates new mutation for the Todo entity.
func newTodoMutation(c config, op Op, opts ...todoOption) *TodoMutation {
	m := &TodoMutation{
		config:        c,
		op:            op,
		typ:           TypeTodo,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTodoID sets the ID field of the mutation.
func withTodoID(id string) todoOption {
	return func(m *TodoMutation) {
		var (
			err   error
			once  sync.Once
			value *Todo
		)
		m.oldValue = func(ctx context.Context) (*Todo, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Todo.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTodo sets the old Todo of the mutation.
func withTodo(node *Todo) todoOption {
	return func(m *TodoMutation) {
		m.oldValue = func(context.Context) (*Todo, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TodoMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TodoMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Todo entities.
func (m *TodoMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TodoMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TodoMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Todo.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TodoMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TodoMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *TodoMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[todo.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *TodoMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[todo.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TodoMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, todo.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TodoMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TodoMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *TodoMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[todo.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *TodoMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[todo.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TodoMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, todo.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *TodoMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *TodoMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *TodoMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[todo.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *TodoMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[todo.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *TodoMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, todo.FieldAppID)
}

// SetText sets the "text" field.
func (m *TodoMutation) SetText(s string) {
	m.text = &s
}

// Text returns the value of the "text" field in the mutation.
func (m *TodoMutation) Text() (r string, exists bool) {
	v := m.text
	if v == nil {
		return
	}
	return *v, true
}

// OldText returns the old "text" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldText(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldText is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldText requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldText: %w", err)
	}
	return oldValue.Text, nil
}

// ResetText resets all changes to the "text" field.
func (m *TodoMutation) ResetText() {
	m.text = nil
}

// SetStatus sets the "status" field.
func (m *TodoMutation) SetStatus(t todo.Status) {
	m.status = &t
}

// Status returns the value of the "status" field in the mutation.
func (m *TodoMutation) Status() (r todo.Status, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldStatus(ctx context.Context) (v todo.Status, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ResetStatus resets all changes to the "status" field.
func (m *TodoMutation) ResetStatus() {
	m.status = nil
}

// SetPriority sets the "priority" field.
func (m *TodoMutation) SetPriority(i int) {
	m.priority = &i
	m.addpriority = nil
}

// Priority returns the value of the "priority" field in the mutation.
func (m *TodoMutation) Priority() (r int, exists bool) {
	v := m.priority
	if v == nil {
		return
	}
	return *v, true
}

// OldPriority returns the old "priority" field's value of the Todo entity.
// If the Todo object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TodoMutation) OldPriority(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPriority is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPriority requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPriority: %w", err)
	}
	return oldValue.Priority, nil
}

// AddPriority adds i to the "priority" field.
func (m *TodoMutation) AddPriority(i int) {
	if m.addpriority != nil {
		*m.addpriority += i
	} else {
		m.addpriority = &i
	}
}

// AddedPriority returns the value that was added to the "priority" field in this mutation.
func (m *TodoMutation) AddedPriority() (r int, exists bool) {
	v := m.addpriority
	if v == nil {
		return
	}
	return *v, true
}

// ResetPriority resets all changes to the "priority" field.
func (m *TodoMutation) ResetPriority() {
	m.priority = nil
	m.addpriority = nil
}

// AddChildIDs adds the "children" edge to the Todo entity by ids.
func (m *TodoMutation) AddChildIDs(ids ...string) {
	if m.children == nil {
		m.children = make(map[string]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Todo entity.
func (m *TodoMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Todo entity was cleared.
func (m *TodoMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Todo entity by IDs.
func (m *TodoMutation) RemoveChildIDs(ids ...string) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Todo entity.
func (m *TodoMutation) RemovedChildrenIDs() (ids []string) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TodoMutation) ChildrenIDs() (ids []string) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TodoMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// SetParentID sets the "parent" edge to the Todo entity by id.
func (m *TodoMutation) SetParentID(id string) {
	m.parent = &id
}

// ClearParent clears the "parent" edge to the Todo entity.
func (m *TodoMutation) ClearParent() {
	m.clearedparent = true
}

// ParentCleared reports if the "parent" edge to the Todo entity was cleared.
func (m *TodoMutation) ParentCleared() bool {
	return m.clearedparent
}

// ParentID returns the "parent" edge ID in the mutation.
func (m *TodoMutation) ParentID() (id string, exists bool) {
	if m.parent != nil {
		return *m.parent, true
	}
	return
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *TodoMutation) ParentIDs() (ids []string) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *TodoMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// Where appends a list predicates to the TodoMutation builder.
func (m *TodoMutation) Where(ps ...predicate.Todo) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TodoMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TodoMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Todo, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TodoMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TodoMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Todo).
func (m *TodoMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TodoMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, todo.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, todo.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, todo.FieldAppID)
	}
	if m.text != nil {
		fields = append(fields, todo.FieldText)
	}
	if m.status != nil {
		fields = append(fields, todo.FieldStatus)
	}
	if m.priority != nil {
		fields = append(fields, todo.FieldPriority)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TodoMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case todo.FieldCreatedAt:
		return m.CreatedAt()
	case todo.FieldUpdatedAt:
		return m.UpdatedAt()
	case todo.FieldAppID:
		return m.AppID()
	case todo.FieldText:
		return m.Text()
	case todo.FieldStatus:
		return m.Status()
	case todo.FieldPriority:
		return m.Priority()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TodoMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case todo.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case todo.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case todo.FieldAppID:
		return m.OldAppID(ctx)
	case todo.FieldText:
		return m.OldText(ctx)
	case todo.FieldStatus:
		return m.OldStatus(ctx)
	case todo.FieldPriority:
		return m.OldPriority(ctx)
	}
	return nil, fmt.Errorf("unknown Todo field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TodoMutation) SetField(name string, value ent.Value) error {
	switch name {
	case todo.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case todo.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case todo.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case todo.FieldText:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetText(v)
		return nil
	case todo.FieldStatus:
		v, ok := value.(todo.Status)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case todo.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Todo field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TodoMutation) AddedFields() []string {
	var fields []string
	if m.addpriority != nil {
		fields = append(fields, todo.FieldPriority)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TodoMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case todo.FieldPriority:
		return m.AddedPriority()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TodoMutation) AddField(name string, value ent.Value) error {
	switch name {
	case todo.FieldPriority:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPriority(v)
		return nil
	}
	return fmt.Errorf("unknown Todo numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TodoMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(todo.FieldCreatedAt) {
		fields = append(fields, todo.FieldCreatedAt)
	}
	if m.FieldCleared(todo.FieldUpdatedAt) {
		fields = append(fields, todo.FieldUpdatedAt)
	}
	if m.FieldCleared(todo.FieldAppID) {
		fields = append(fields, todo.FieldAppID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TodoMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TodoMutation) ClearField(name string) error {
	switch name {
	case todo.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case todo.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case todo.FieldAppID:
		m.ClearAppID()
		return nil
	}
	return fmt.Errorf("unknown Todo nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TodoMutation) ResetField(name string) error {
	switch name {
	case todo.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case todo.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case todo.FieldAppID:
		m.ResetAppID()
		return nil
	case todo.FieldText:
		m.ResetText()
		return nil
	case todo.FieldStatus:
		m.ResetStatus()
		return nil
	case todo.FieldPriority:
		m.ResetPriority()
		return nil
	}
	return fmt.Errorf("unknown Todo field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TodoMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.children != nil {
		edges = append(edges, todo.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, todo.EdgeParent)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TodoMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case todo.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case todo.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TodoMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedchildren != nil {
		edges = append(edges, todo.EdgeChildren)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TodoMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case todo.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TodoMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedchildren {
		edges = append(edges, todo.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, todo.EdgeParent)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TodoMutation) EdgeCleared(name string) bool {
	switch name {
	case todo.EdgeChildren:
		return m.clearedchildren
	case todo.EdgeParent:
		return m.clearedparent
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TodoMutation) ClearEdge(name string) error {
	switch name {
	case todo.EdgeParent:
		m.ClearParent()
		return nil
	}
	return fmt.Errorf("unknown Todo unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TodoMutation) ResetEdge(name string) error {
	switch name {
	case todo.EdgeChildren:
		m.ResetChildren()
		return nil
	case todo.EdgeParent:
		m.ResetParent()
		return nil
	}
	return fmt.Errorf("unknown Todo edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                     Op
	typ                    string
	id                     *string
	created_at             *time.Time
	updated_at             *time.Time
	app_id                 *string
	email                  *string
	phone                  *string
	first_name             *string
	last_name              *string
	company                *string
	locale                 *string
	role_id                *string
	status                 *bool
	password               *string
	secret                 *string
	api_key                *string
	welcome_email_sent     *bool
	can_admin              *bool
	clearedFields          map[string]struct{}
	sessions               map[string]struct{}
	removedsessions        map[string]struct{}
	clearedsessions        bool
	workspaces             map[string]struct{}
	removedworkspaces      map[string]struct{}
	clearedworkspaces      bool
	workspace_users        map[string]struct{}
	removedworkspace_users map[string]struct{}
	clearedworkspace_users bool
	done                   bool
	oldValue               func(context.Context) (*User, error)
	predicates             []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id string) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *UserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[user.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *UserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, user.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *UserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[user.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *UserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, user.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *UserMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *UserMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *UserMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[user.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *UserMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[user.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *UserMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, user.FieldAppID)
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPhone sets the "phone" field.
func (m *UserMutation) SetPhone(s string) {
	m.phone = &s
}

// Phone returns the value of the "phone" field in the mutation.
func (m *UserMutation) Phone() (r string, exists bool) {
	v := m.phone
	if v == nil {
		return
	}
	return *v, true
}

// OldPhone returns the old "phone" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPhone(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPhone is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPhone requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPhone: %w", err)
	}
	return oldValue.Phone, nil
}

// ClearPhone clears the value of the "phone" field.
func (m *UserMutation) ClearPhone() {
	m.phone = nil
	m.clearedFields[user.FieldPhone] = struct{}{}
}

// PhoneCleared returns if the "phone" field was cleared in this mutation.
func (m *UserMutation) PhoneCleared() bool {
	_, ok := m.clearedFields[user.FieldPhone]
	return ok
}

// ResetPhone resets all changes to the "phone" field.
func (m *UserMutation) ResetPhone() {
	m.phone = nil
	delete(m.clearedFields, user.FieldPhone)
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ClearFirstName clears the value of the "first_name" field.
func (m *UserMutation) ClearFirstName() {
	m.first_name = nil
	m.clearedFields[user.FieldFirstName] = struct{}{}
}

// FirstNameCleared returns if the "first_name" field was cleared in this mutation.
func (m *UserMutation) FirstNameCleared() bool {
	_, ok := m.clearedFields[user.FieldFirstName]
	return ok
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
	delete(m.clearedFields, user.FieldFirstName)
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetCompany sets the "company" field.
func (m *UserMutation) SetCompany(s string) {
	m.company = &s
}

// Company returns the value of the "company" field in the mutation.
func (m *UserMutation) Company() (r string, exists bool) {
	v := m.company
	if v == nil {
		return
	}
	return *v, true
}

// OldCompany returns the old "company" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCompany(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCompany is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCompany requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCompany: %w", err)
	}
	return oldValue.Company, nil
}

// ClearCompany clears the value of the "company" field.
func (m *UserMutation) ClearCompany() {
	m.company = nil
	m.clearedFields[user.FieldCompany] = struct{}{}
}

// CompanyCleared returns if the "company" field was cleared in this mutation.
func (m *UserMutation) CompanyCleared() bool {
	_, ok := m.clearedFields[user.FieldCompany]
	return ok
}

// ResetCompany resets all changes to the "company" field.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	delete(m.clearedFields, user.FieldCompany)
}

// SetLocale sets the "locale" field.
func (m *UserMutation) SetLocale(s string) {
	m.locale = &s
}

// Locale returns the value of the "locale" field in the mutation.
func (m *UserMutation) Locale() (r string, exists bool) {
	v := m.locale
	if v == nil {
		return
	}
	return *v, true
}

// OldLocale returns the old "locale" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLocale(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLocale is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLocale requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLocale: %w", err)
	}
	return oldValue.Locale, nil
}

// ClearLocale clears the value of the "locale" field.
func (m *UserMutation) ClearLocale() {
	m.locale = nil
	m.clearedFields[user.FieldLocale] = struct{}{}
}

// LocaleCleared returns if the "locale" field was cleared in this mutation.
func (m *UserMutation) LocaleCleared() bool {
	_, ok := m.clearedFields[user.FieldLocale]
	return ok
}

// ResetLocale resets all changes to the "locale" field.
func (m *UserMutation) ResetLocale() {
	m.locale = nil
	delete(m.clearedFields, user.FieldLocale)
}

// SetRoleID sets the "role_id" field.
func (m *UserMutation) SetRoleID(s string) {
	m.role_id = &s
}

// RoleID returns the value of the "role_id" field in the mutation.
func (m *UserMutation) RoleID() (r string, exists bool) {
	v := m.role_id
	if v == nil {
		return
	}
	return *v, true
}

// OldRoleID returns the old "role_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRoleID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRoleID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRoleID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRoleID: %w", err)
	}
	return oldValue.RoleID, nil
}

// ClearRoleID clears the value of the "role_id" field.
func (m *UserMutation) ClearRoleID() {
	m.role_id = nil
	m.clearedFields[user.FieldRoleID] = struct{}{}
}

// RoleIDCleared returns if the "role_id" field was cleared in this mutation.
func (m *UserMutation) RoleIDCleared() bool {
	_, ok := m.clearedFields[user.FieldRoleID]
	return ok
}

// ResetRoleID resets all changes to the "role_id" field.
func (m *UserMutation) ResetRoleID() {
	m.role_id = nil
	delete(m.clearedFields, user.FieldRoleID)
}

// SetStatus sets the "status" field.
func (m *UserMutation) SetStatus(b bool) {
	m.status = &b
}

// Status returns the value of the "status" field in the mutation.
func (m *UserMutation) Status() (r bool, exists bool) {
	v := m.status
	if v == nil {
		return
	}
	return *v, true
}

// OldStatus returns the old "status" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldStatus(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStatus is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStatus requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStatus: %w", err)
	}
	return oldValue.Status, nil
}

// ClearStatus clears the value of the "status" field.
func (m *UserMutation) ClearStatus() {
	m.status = nil
	m.clearedFields[user.FieldStatus] = struct{}{}
}

// StatusCleared returns if the "status" field was cleared in this mutation.
func (m *UserMutation) StatusCleared() bool {
	_, ok := m.clearedFields[user.FieldStatus]
	return ok
}

// ResetStatus resets all changes to the "status" field.
func (m *UserMutation) ResetStatus() {
	m.status = nil
	delete(m.clearedFields, user.FieldStatus)
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ClearPassword clears the value of the "password" field.
func (m *UserMutation) ClearPassword() {
	m.password = nil
	m.clearedFields[user.FieldPassword] = struct{}{}
}

// PasswordCleared returns if the "password" field was cleared in this mutation.
func (m *UserMutation) PasswordCleared() bool {
	_, ok := m.clearedFields[user.FieldPassword]
	return ok
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
	delete(m.clearedFields, user.FieldPassword)
}

// SetSecret sets the "secret" field.
func (m *UserMutation) SetSecret(s string) {
	m.secret = &s
}

// Secret returns the value of the "secret" field in the mutation.
func (m *UserMutation) Secret() (r string, exists bool) {
	v := m.secret
	if v == nil {
		return
	}
	return *v, true
}

// OldSecret returns the old "secret" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldSecret(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSecret is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSecret requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSecret: %w", err)
	}
	return oldValue.Secret, nil
}

// ClearSecret clears the value of the "secret" field.
func (m *UserMutation) ClearSecret() {
	m.secret = nil
	m.clearedFields[user.FieldSecret] = struct{}{}
}

// SecretCleared returns if the "secret" field was cleared in this mutation.
func (m *UserMutation) SecretCleared() bool {
	_, ok := m.clearedFields[user.FieldSecret]
	return ok
}

// ResetSecret resets all changes to the "secret" field.
func (m *UserMutation) ResetSecret() {
	m.secret = nil
	delete(m.clearedFields, user.FieldSecret)
}

// SetAPIKey sets the "api_key" field.
func (m *UserMutation) SetAPIKey(s string) {
	m.api_key = &s
}

// APIKey returns the value of the "api_key" field in the mutation.
func (m *UserMutation) APIKey() (r string, exists bool) {
	v := m.api_key
	if v == nil {
		return
	}
	return *v, true
}

// OldAPIKey returns the old "api_key" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAPIKey(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAPIKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAPIKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAPIKey: %w", err)
	}
	return oldValue.APIKey, nil
}

// ClearAPIKey clears the value of the "api_key" field.
func (m *UserMutation) ClearAPIKey() {
	m.api_key = nil
	m.clearedFields[user.FieldAPIKey] = struct{}{}
}

// APIKeyCleared returns if the "api_key" field was cleared in this mutation.
func (m *UserMutation) APIKeyCleared() bool {
	_, ok := m.clearedFields[user.FieldAPIKey]
	return ok
}

// ResetAPIKey resets all changes to the "api_key" field.
func (m *UserMutation) ResetAPIKey() {
	m.api_key = nil
	delete(m.clearedFields, user.FieldAPIKey)
}

// SetWelcomeEmailSent sets the "welcome_email_sent" field.
func (m *UserMutation) SetWelcomeEmailSent(b bool) {
	m.welcome_email_sent = &b
}

// WelcomeEmailSent returns the value of the "welcome_email_sent" field in the mutation.
func (m *UserMutation) WelcomeEmailSent() (r bool, exists bool) {
	v := m.welcome_email_sent
	if v == nil {
		return
	}
	return *v, true
}

// OldWelcomeEmailSent returns the old "welcome_email_sent" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldWelcomeEmailSent(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWelcomeEmailSent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWelcomeEmailSent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWelcomeEmailSent: %w", err)
	}
	return oldValue.WelcomeEmailSent, nil
}

// ClearWelcomeEmailSent clears the value of the "welcome_email_sent" field.
func (m *UserMutation) ClearWelcomeEmailSent() {
	m.welcome_email_sent = nil
	m.clearedFields[user.FieldWelcomeEmailSent] = struct{}{}
}

// WelcomeEmailSentCleared returns if the "welcome_email_sent" field was cleared in this mutation.
func (m *UserMutation) WelcomeEmailSentCleared() bool {
	_, ok := m.clearedFields[user.FieldWelcomeEmailSent]
	return ok
}

// ResetWelcomeEmailSent resets all changes to the "welcome_email_sent" field.
func (m *UserMutation) ResetWelcomeEmailSent() {
	m.welcome_email_sent = nil
	delete(m.clearedFields, user.FieldWelcomeEmailSent)
}

// SetCanAdmin sets the "can_admin" field.
func (m *UserMutation) SetCanAdmin(b bool) {
	m.can_admin = &b
}

// CanAdmin returns the value of the "can_admin" field in the mutation.
func (m *UserMutation) CanAdmin() (r bool, exists bool) {
	v := m.can_admin
	if v == nil {
		return
	}
	return *v, true
}

// OldCanAdmin returns the old "can_admin" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCanAdmin(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCanAdmin is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCanAdmin requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCanAdmin: %w", err)
	}
	return oldValue.CanAdmin, nil
}

// ClearCanAdmin clears the value of the "can_admin" field.
func (m *UserMutation) ClearCanAdmin() {
	m.can_admin = nil
	m.clearedFields[user.FieldCanAdmin] = struct{}{}
}

// CanAdminCleared returns if the "can_admin" field was cleared in this mutation.
func (m *UserMutation) CanAdminCleared() bool {
	_, ok := m.clearedFields[user.FieldCanAdmin]
	return ok
}

// ResetCanAdmin resets all changes to the "can_admin" field.
func (m *UserMutation) ResetCanAdmin() {
	m.can_admin = nil
	delete(m.clearedFields, user.FieldCanAdmin)
}

// AddSessionIDs adds the "sessions" edge to the Session entity by ids.
func (m *UserMutation) AddSessionIDs(ids ...string) {
	if m.sessions == nil {
		m.sessions = make(map[string]struct{})
	}
	for i := range ids {
		m.sessions[ids[i]] = struct{}{}
	}
}

// ClearSessions clears the "sessions" edge to the Session entity.
func (m *UserMutation) ClearSessions() {
	m.clearedsessions = true
}

// SessionsCleared reports if the "sessions" edge to the Session entity was cleared.
func (m *UserMutation) SessionsCleared() bool {
	return m.clearedsessions
}

// RemoveSessionIDs removes the "sessions" edge to the Session entity by IDs.
func (m *UserMutation) RemoveSessionIDs(ids ...string) {
	if m.removedsessions == nil {
		m.removedsessions = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.sessions, ids[i])
		m.removedsessions[ids[i]] = struct{}{}
	}
}

// RemovedSessions returns the removed IDs of the "sessions" edge to the Session entity.
func (m *UserMutation) RemovedSessionsIDs() (ids []string) {
	for id := range m.removedsessions {
		ids = append(ids, id)
	}
	return
}

// SessionsIDs returns the "sessions" edge IDs in the mutation.
func (m *UserMutation) SessionsIDs() (ids []string) {
	for id := range m.sessions {
		ids = append(ids, id)
	}
	return
}

// ResetSessions resets all changes to the "sessions" edge.
func (m *UserMutation) ResetSessions() {
	m.sessions = nil
	m.clearedsessions = false
	m.removedsessions = nil
}

// AddWorkspaceIDs adds the "workspaces" edge to the Workspace entity by ids.
func (m *UserMutation) AddWorkspaceIDs(ids ...string) {
	if m.workspaces == nil {
		m.workspaces = make(map[string]struct{})
	}
	for i := range ids {
		m.workspaces[ids[i]] = struct{}{}
	}
}

// ClearWorkspaces clears the "workspaces" edge to the Workspace entity.
func (m *UserMutation) ClearWorkspaces() {
	m.clearedworkspaces = true
}

// WorkspacesCleared reports if the "workspaces" edge to the Workspace entity was cleared.
func (m *UserMutation) WorkspacesCleared() bool {
	return m.clearedworkspaces
}

// RemoveWorkspaceIDs removes the "workspaces" edge to the Workspace entity by IDs.
func (m *UserMutation) RemoveWorkspaceIDs(ids ...string) {
	if m.removedworkspaces == nil {
		m.removedworkspaces = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.workspaces, ids[i])
		m.removedworkspaces[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaces returns the removed IDs of the "workspaces" edge to the Workspace entity.
func (m *UserMutation) RemovedWorkspacesIDs() (ids []string) {
	for id := range m.removedworkspaces {
		ids = append(ids, id)
	}
	return
}

// WorkspacesIDs returns the "workspaces" edge IDs in the mutation.
func (m *UserMutation) WorkspacesIDs() (ids []string) {
	for id := range m.workspaces {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaces resets all changes to the "workspaces" edge.
func (m *UserMutation) ResetWorkspaces() {
	m.workspaces = nil
	m.clearedworkspaces = false
	m.removedworkspaces = nil
}

// AddWorkspaceUserIDs adds the "workspace_users" edge to the WorkspaceUser entity by ids.
func (m *UserMutation) AddWorkspaceUserIDs(ids ...string) {
	if m.workspace_users == nil {
		m.workspace_users = make(map[string]struct{})
	}
	for i := range ids {
		m.workspace_users[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceUsers clears the "workspace_users" edge to the WorkspaceUser entity.
func (m *UserMutation) ClearWorkspaceUsers() {
	m.clearedworkspace_users = true
}

// WorkspaceUsersCleared reports if the "workspace_users" edge to the WorkspaceUser entity was cleared.
func (m *UserMutation) WorkspaceUsersCleared() bool {
	return m.clearedworkspace_users
}

// RemoveWorkspaceUserIDs removes the "workspace_users" edge to the WorkspaceUser entity by IDs.
func (m *UserMutation) RemoveWorkspaceUserIDs(ids ...string) {
	if m.removedworkspace_users == nil {
		m.removedworkspace_users = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.workspace_users, ids[i])
		m.removedworkspace_users[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceUsers returns the removed IDs of the "workspace_users" edge to the WorkspaceUser entity.
func (m *UserMutation) RemovedWorkspaceUsersIDs() (ids []string) {
	for id := range m.removedworkspace_users {
		ids = append(ids, id)
	}
	return
}

// WorkspaceUsersIDs returns the "workspace_users" edge IDs in the mutation.
func (m *UserMutation) WorkspaceUsersIDs() (ids []string) {
	for id := range m.workspace_users {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceUsers resets all changes to the "workspace_users" edge.
func (m *UserMutation) ResetWorkspaceUsers() {
	m.workspace_users = nil
	m.clearedworkspace_users = false
	m.removedworkspace_users = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 16)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, user.FieldAppID)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.phone != nil {
		fields = append(fields, user.FieldPhone)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.company != nil {
		fields = append(fields, user.FieldCompany)
	}
	if m.locale != nil {
		fields = append(fields, user.FieldLocale)
	}
	if m.role_id != nil {
		fields = append(fields, user.FieldRoleID)
	}
	if m.status != nil {
		fields = append(fields, user.FieldStatus)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.secret != nil {
		fields = append(fields, user.FieldSecret)
	}
	if m.api_key != nil {
		fields = append(fields, user.FieldAPIKey)
	}
	if m.welcome_email_sent != nil {
		fields = append(fields, user.FieldWelcomeEmailSent)
	}
	if m.can_admin != nil {
		fields = append(fields, user.FieldCanAdmin)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldAppID:
		return m.AppID()
	case user.FieldEmail:
		return m.Email()
	case user.FieldPhone:
		return m.Phone()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldCompany:
		return m.Company()
	case user.FieldLocale:
		return m.Locale()
	case user.FieldRoleID:
		return m.RoleID()
	case user.FieldStatus:
		return m.Status()
	case user.FieldPassword:
		return m.Password()
	case user.FieldSecret:
		return m.Secret()
	case user.FieldAPIKey:
		return m.APIKey()
	case user.FieldWelcomeEmailSent:
		return m.WelcomeEmailSent()
	case user.FieldCanAdmin:
		return m.CanAdmin()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldAppID:
		return m.OldAppID(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPhone:
		return m.OldPhone(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldCompany:
		return m.OldCompany(ctx)
	case user.FieldLocale:
		return m.OldLocale(ctx)
	case user.FieldRoleID:
		return m.OldRoleID(ctx)
	case user.FieldStatus:
		return m.OldStatus(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldSecret:
		return m.OldSecret(ctx)
	case user.FieldAPIKey:
		return m.OldAPIKey(ctx)
	case user.FieldWelcomeEmailSent:
		return m.OldWelcomeEmailSent(ctx)
	case user.FieldCanAdmin:
		return m.OldCanAdmin(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPhone:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPhone(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldCompany:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCompany(v)
		return nil
	case user.FieldLocale:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLocale(v)
		return nil
	case user.FieldRoleID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRoleID(v)
		return nil
	case user.FieldStatus:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStatus(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldSecret:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSecret(v)
		return nil
	case user.FieldAPIKey:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAPIKey(v)
		return nil
	case user.FieldWelcomeEmailSent:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWelcomeEmailSent(v)
		return nil
	case user.FieldCanAdmin:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCanAdmin(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedAt) {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.FieldCleared(user.FieldUpdatedAt) {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.FieldCleared(user.FieldAppID) {
		fields = append(fields, user.FieldAppID)
	}
	if m.FieldCleared(user.FieldPhone) {
		fields = append(fields, user.FieldPhone)
	}
	if m.FieldCleared(user.FieldFirstName) {
		fields = append(fields, user.FieldFirstName)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldCompany) {
		fields = append(fields, user.FieldCompany)
	}
	if m.FieldCleared(user.FieldLocale) {
		fields = append(fields, user.FieldLocale)
	}
	if m.FieldCleared(user.FieldRoleID) {
		fields = append(fields, user.FieldRoleID)
	}
	if m.FieldCleared(user.FieldStatus) {
		fields = append(fields, user.FieldStatus)
	}
	if m.FieldCleared(user.FieldPassword) {
		fields = append(fields, user.FieldPassword)
	}
	if m.FieldCleared(user.FieldSecret) {
		fields = append(fields, user.FieldSecret)
	}
	if m.FieldCleared(user.FieldAPIKey) {
		fields = append(fields, user.FieldAPIKey)
	}
	if m.FieldCleared(user.FieldWelcomeEmailSent) {
		fields = append(fields, user.FieldWelcomeEmailSent)
	}
	if m.FieldCleared(user.FieldCanAdmin) {
		fields = append(fields, user.FieldCanAdmin)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case user.FieldAppID:
		m.ClearAppID()
		return nil
	case user.FieldPhone:
		m.ClearPhone()
		return nil
	case user.FieldFirstName:
		m.ClearFirstName()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldCompany:
		m.ClearCompany()
		return nil
	case user.FieldLocale:
		m.ClearLocale()
		return nil
	case user.FieldRoleID:
		m.ClearRoleID()
		return nil
	case user.FieldStatus:
		m.ClearStatus()
		return nil
	case user.FieldPassword:
		m.ClearPassword()
		return nil
	case user.FieldSecret:
		m.ClearSecret()
		return nil
	case user.FieldAPIKey:
		m.ClearAPIKey()
		return nil
	case user.FieldWelcomeEmailSent:
		m.ClearWelcomeEmailSent()
		return nil
	case user.FieldCanAdmin:
		m.ClearCanAdmin()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldAppID:
		m.ResetAppID()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPhone:
		m.ResetPhone()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldCompany:
		m.ResetCompany()
		return nil
	case user.FieldLocale:
		m.ResetLocale()
		return nil
	case user.FieldRoleID:
		m.ResetRoleID()
		return nil
	case user.FieldStatus:
		m.ResetStatus()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldSecret:
		m.ResetSecret()
		return nil
	case user.FieldAPIKey:
		m.ResetAPIKey()
		return nil
	case user.FieldWelcomeEmailSent:
		m.ResetWelcomeEmailSent()
		return nil
	case user.FieldCanAdmin:
		m.ResetCanAdmin()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.sessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.workspaces != nil {
		edges = append(edges, user.EdgeWorkspaces)
	}
	if m.workspace_users != nil {
		edges = append(edges, user.EdgeWorkspaceUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.sessions))
		for id := range m.sessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkspaces:
		ids := make([]ent.Value, 0, len(m.workspaces))
		for id := range m.workspaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkspaceUsers:
		ids := make([]ent.Value, 0, len(m.workspace_users))
		for id := range m.workspace_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedsessions != nil {
		edges = append(edges, user.EdgeSessions)
	}
	if m.removedworkspaces != nil {
		edges = append(edges, user.EdgeWorkspaces)
	}
	if m.removedworkspace_users != nil {
		edges = append(edges, user.EdgeWorkspaceUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSessions:
		ids := make([]ent.Value, 0, len(m.removedsessions))
		for id := range m.removedsessions {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkspaces:
		ids := make([]ent.Value, 0, len(m.removedworkspaces))
		for id := range m.removedworkspaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeWorkspaceUsers:
		ids := make([]ent.Value, 0, len(m.removedworkspace_users))
		for id := range m.removedworkspace_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedsessions {
		edges = append(edges, user.EdgeSessions)
	}
	if m.clearedworkspaces {
		edges = append(edges, user.EdgeWorkspaces)
	}
	if m.clearedworkspace_users {
		edges = append(edges, user.EdgeWorkspaceUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSessions:
		return m.clearedsessions
	case user.EdgeWorkspaces:
		return m.clearedworkspaces
	case user.EdgeWorkspaceUsers:
		return m.clearedworkspace_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSessions:
		m.ResetSessions()
		return nil
	case user.EdgeWorkspaces:
		m.ResetWorkspaces()
		return nil
	case user.EdgeWorkspaceUsers:
		m.ResetWorkspaceUsers()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}

// WorkspaceMutation represents an operation that mutates the Workspace nodes in the graph.
type WorkspaceMutation struct {
	config
	op                       Op
	typ                      string
	id                       *string
	created_at               *time.Time
	updated_at               *time.Time
	app_id                   *string
	name                     *string
	is_personal              *bool
	user_id                  *string
	clearedFields            map[string]struct{}
	users                    map[string]struct{}
	removedusers             map[string]struct{}
	clearedusers             bool
	workspace_invites        map[string]struct{}
	removedworkspace_invites map[string]struct{}
	clearedworkspace_invites bool
	workspace_users          map[string]struct{}
	removedworkspace_users   map[string]struct{}
	clearedworkspace_users   bool
	done                     bool
	oldValue                 func(context.Context) (*Workspace, error)
	predicates               []predicate.Workspace
}

var _ ent.Mutation = (*WorkspaceMutation)(nil)

// workspaceOption allows management of the mutation configuration using functional options.
type workspaceOption func(*WorkspaceMutation)

// newWorkspaceMutation creates new mutation for the Workspace entity.
func newWorkspaceMutation(c config, op Op, opts ...workspaceOption) *WorkspaceMutation {
	m := &WorkspaceMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceID sets the ID field of the mutation.
func withWorkspaceID(id string) workspaceOption {
	return func(m *WorkspaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Workspace
		)
		m.oldValue = func(ctx context.Context) (*Workspace, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Workspace.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspace sets the old Workspace of the mutation.
func withWorkspace(node *Workspace) workspaceOption {
	return func(m *WorkspaceMutation) {
		m.oldValue = func(context.Context) (*Workspace, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Workspace entities.
func (m *WorkspaceMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Workspace.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkspaceMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workspace.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkspaceMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workspace.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workspace.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkspaceMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workspace.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkspaceMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workspace.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workspace.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *WorkspaceMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *WorkspaceMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *WorkspaceMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[workspace.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *WorkspaceMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[workspace.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *WorkspaceMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, workspace.FieldAppID)
}

// SetName sets the "name" field.
func (m *WorkspaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *WorkspaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ClearName clears the value of the "name" field.
func (m *WorkspaceMutation) ClearName() {
	m.name = nil
	m.clearedFields[workspace.FieldName] = struct{}{}
}

// NameCleared returns if the "name" field was cleared in this mutation.
func (m *WorkspaceMutation) NameCleared() bool {
	_, ok := m.clearedFields[workspace.FieldName]
	return ok
}

// ResetName resets all changes to the "name" field.
func (m *WorkspaceMutation) ResetName() {
	m.name = nil
	delete(m.clearedFields, workspace.FieldName)
}

// SetIsPersonal sets the "is_personal" field.
func (m *WorkspaceMutation) SetIsPersonal(b bool) {
	m.is_personal = &b
}

// IsPersonal returns the value of the "is_personal" field in the mutation.
func (m *WorkspaceMutation) IsPersonal() (r bool, exists bool) {
	v := m.is_personal
	if v == nil {
		return
	}
	return *v, true
}

// OldIsPersonal returns the old "is_personal" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldIsPersonal(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsPersonal is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsPersonal requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsPersonal: %w", err)
	}
	return oldValue.IsPersonal, nil
}

// ClearIsPersonal clears the value of the "is_personal" field.
func (m *WorkspaceMutation) ClearIsPersonal() {
	m.is_personal = nil
	m.clearedFields[workspace.FieldIsPersonal] = struct{}{}
}

// IsPersonalCleared returns if the "is_personal" field was cleared in this mutation.
func (m *WorkspaceMutation) IsPersonalCleared() bool {
	_, ok := m.clearedFields[workspace.FieldIsPersonal]
	return ok
}

// ResetIsPersonal resets all changes to the "is_personal" field.
func (m *WorkspaceMutation) ResetIsPersonal() {
	m.is_personal = nil
	delete(m.clearedFields, workspace.FieldIsPersonal)
}

// SetUserID sets the "user_id" field.
func (m *WorkspaceMutation) SetUserID(s string) {
	m.user_id = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WorkspaceMutation) UserID() (r string, exists bool) {
	v := m.user_id
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the Workspace entity.
// If the Workspace object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ClearUserID clears the value of the "user_id" field.
func (m *WorkspaceMutation) ClearUserID() {
	m.user_id = nil
	m.clearedFields[workspace.FieldUserID] = struct{}{}
}

// UserIDCleared returns if the "user_id" field was cleared in this mutation.
func (m *WorkspaceMutation) UserIDCleared() bool {
	_, ok := m.clearedFields[workspace.FieldUserID]
	return ok
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WorkspaceMutation) ResetUserID() {
	m.user_id = nil
	delete(m.clearedFields, workspace.FieldUserID)
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *WorkspaceMutation) AddUserIDs(ids ...string) {
	if m.users == nil {
		m.users = make(map[string]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *WorkspaceMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *WorkspaceMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *WorkspaceMutation) RemoveUserIDs(ids ...string) {
	if m.removedusers == nil {
		m.removedusers = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *WorkspaceMutation) RemovedUsersIDs() (ids []string) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *WorkspaceMutation) UsersIDs() (ids []string) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *WorkspaceMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddWorkspaceInviteIDs adds the "workspace_invites" edge to the WorkspaceInvite entity by ids.
func (m *WorkspaceMutation) AddWorkspaceInviteIDs(ids ...string) {
	if m.workspace_invites == nil {
		m.workspace_invites = make(map[string]struct{})
	}
	for i := range ids {
		m.workspace_invites[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceInvites clears the "workspace_invites" edge to the WorkspaceInvite entity.
func (m *WorkspaceMutation) ClearWorkspaceInvites() {
	m.clearedworkspace_invites = true
}

// WorkspaceInvitesCleared reports if the "workspace_invites" edge to the WorkspaceInvite entity was cleared.
func (m *WorkspaceMutation) WorkspaceInvitesCleared() bool {
	return m.clearedworkspace_invites
}

// RemoveWorkspaceInviteIDs removes the "workspace_invites" edge to the WorkspaceInvite entity by IDs.
func (m *WorkspaceMutation) RemoveWorkspaceInviteIDs(ids ...string) {
	if m.removedworkspace_invites == nil {
		m.removedworkspace_invites = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.workspace_invites, ids[i])
		m.removedworkspace_invites[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceInvites returns the removed IDs of the "workspace_invites" edge to the WorkspaceInvite entity.
func (m *WorkspaceMutation) RemovedWorkspaceInvitesIDs() (ids []string) {
	for id := range m.removedworkspace_invites {
		ids = append(ids, id)
	}
	return
}

// WorkspaceInvitesIDs returns the "workspace_invites" edge IDs in the mutation.
func (m *WorkspaceMutation) WorkspaceInvitesIDs() (ids []string) {
	for id := range m.workspace_invites {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceInvites resets all changes to the "workspace_invites" edge.
func (m *WorkspaceMutation) ResetWorkspaceInvites() {
	m.workspace_invites = nil
	m.clearedworkspace_invites = false
	m.removedworkspace_invites = nil
}

// AddWorkspaceUserIDs adds the "workspace_users" edge to the WorkspaceUser entity by ids.
func (m *WorkspaceMutation) AddWorkspaceUserIDs(ids ...string) {
	if m.workspace_users == nil {
		m.workspace_users = make(map[string]struct{})
	}
	for i := range ids {
		m.workspace_users[ids[i]] = struct{}{}
	}
}

// ClearWorkspaceUsers clears the "workspace_users" edge to the WorkspaceUser entity.
func (m *WorkspaceMutation) ClearWorkspaceUsers() {
	m.clearedworkspace_users = true
}

// WorkspaceUsersCleared reports if the "workspace_users" edge to the WorkspaceUser entity was cleared.
func (m *WorkspaceMutation) WorkspaceUsersCleared() bool {
	return m.clearedworkspace_users
}

// RemoveWorkspaceUserIDs removes the "workspace_users" edge to the WorkspaceUser entity by IDs.
func (m *WorkspaceMutation) RemoveWorkspaceUserIDs(ids ...string) {
	if m.removedworkspace_users == nil {
		m.removedworkspace_users = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.workspace_users, ids[i])
		m.removedworkspace_users[ids[i]] = struct{}{}
	}
}

// RemovedWorkspaceUsers returns the removed IDs of the "workspace_users" edge to the WorkspaceUser entity.
func (m *WorkspaceMutation) RemovedWorkspaceUsersIDs() (ids []string) {
	for id := range m.removedworkspace_users {
		ids = append(ids, id)
	}
	return
}

// WorkspaceUsersIDs returns the "workspace_users" edge IDs in the mutation.
func (m *WorkspaceMutation) WorkspaceUsersIDs() (ids []string) {
	for id := range m.workspace_users {
		ids = append(ids, id)
	}
	return
}

// ResetWorkspaceUsers resets all changes to the "workspace_users" edge.
func (m *WorkspaceMutation) ResetWorkspaceUsers() {
	m.workspace_users = nil
	m.clearedworkspace_users = false
	m.removedworkspace_users = nil
}

// Where appends a list predicates to the WorkspaceMutation builder.
func (m *WorkspaceMutation) Where(ps ...predicate.Workspace) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkspaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkspaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Workspace, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkspaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkspaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Workspace).
func (m *WorkspaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, workspace.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspace.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, workspace.FieldAppID)
	}
	if m.name != nil {
		fields = append(fields, workspace.FieldName)
	}
	if m.is_personal != nil {
		fields = append(fields, workspace.FieldIsPersonal)
	}
	if m.user_id != nil {
		fields = append(fields, workspace.FieldUserID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspace.FieldCreatedAt:
		return m.CreatedAt()
	case workspace.FieldUpdatedAt:
		return m.UpdatedAt()
	case workspace.FieldAppID:
		return m.AppID()
	case workspace.FieldName:
		return m.Name()
	case workspace.FieldIsPersonal:
		return m.IsPersonal()
	case workspace.FieldUserID:
		return m.UserID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspace.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspace.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workspace.FieldAppID:
		return m.OldAppID(ctx)
	case workspace.FieldName:
		return m.OldName(ctx)
	case workspace.FieldIsPersonal:
		return m.OldIsPersonal(ctx)
	case workspace.FieldUserID:
		return m.OldUserID(ctx)
	}
	return nil, fmt.Errorf("unknown Workspace field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspace.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspace.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workspace.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case workspace.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case workspace.FieldIsPersonal:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsPersonal(v)
		return nil
	case workspace.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	}
	return fmt.Errorf("unknown Workspace field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Workspace numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workspace.FieldCreatedAt) {
		fields = append(fields, workspace.FieldCreatedAt)
	}
	if m.FieldCleared(workspace.FieldUpdatedAt) {
		fields = append(fields, workspace.FieldUpdatedAt)
	}
	if m.FieldCleared(workspace.FieldAppID) {
		fields = append(fields, workspace.FieldAppID)
	}
	if m.FieldCleared(workspace.FieldName) {
		fields = append(fields, workspace.FieldName)
	}
	if m.FieldCleared(workspace.FieldIsPersonal) {
		fields = append(fields, workspace.FieldIsPersonal)
	}
	if m.FieldCleared(workspace.FieldUserID) {
		fields = append(fields, workspace.FieldUserID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceMutation) ClearField(name string) error {
	switch name {
	case workspace.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workspace.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workspace.FieldAppID:
		m.ClearAppID()
		return nil
	case workspace.FieldName:
		m.ClearName()
		return nil
	case workspace.FieldIsPersonal:
		m.ClearIsPersonal()
		return nil
	case workspace.FieldUserID:
		m.ClearUserID()
		return nil
	}
	return fmt.Errorf("unknown Workspace nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceMutation) ResetField(name string) error {
	switch name {
	case workspace.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspace.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workspace.FieldAppID:
		m.ResetAppID()
		return nil
	case workspace.FieldName:
		m.ResetName()
		return nil
	case workspace.FieldIsPersonal:
		m.ResetIsPersonal()
		return nil
	case workspace.FieldUserID:
		m.ResetUserID()
		return nil
	}
	return fmt.Errorf("unknown Workspace field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.users != nil {
		edges = append(edges, workspace.EdgeUsers)
	}
	if m.workspace_invites != nil {
		edges = append(edges, workspace.EdgeWorkspaceInvites)
	}
	if m.workspace_users != nil {
		edges = append(edges, workspace.EdgeWorkspaceUsers)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspace.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeWorkspaceInvites:
		ids := make([]ent.Value, 0, len(m.workspace_invites))
		for id := range m.workspace_invites {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeWorkspaceUsers:
		ids := make([]ent.Value, 0, len(m.workspace_users))
		for id := range m.workspace_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedusers != nil {
		edges = append(edges, workspace.EdgeUsers)
	}
	if m.removedworkspace_invites != nil {
		edges = append(edges, workspace.EdgeWorkspaceInvites)
	}
	if m.removedworkspace_users != nil {
		edges = append(edges, workspace.EdgeWorkspaceUsers)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case workspace.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeWorkspaceInvites:
		ids := make([]ent.Value, 0, len(m.removedworkspace_invites))
		for id := range m.removedworkspace_invites {
			ids = append(ids, id)
		}
		return ids
	case workspace.EdgeWorkspaceUsers:
		ids := make([]ent.Value, 0, len(m.removedworkspace_users))
		for id := range m.removedworkspace_users {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedusers {
		edges = append(edges, workspace.EdgeUsers)
	}
	if m.clearedworkspace_invites {
		edges = append(edges, workspace.EdgeWorkspaceInvites)
	}
	if m.clearedworkspace_users {
		edges = append(edges, workspace.EdgeWorkspaceUsers)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceMutation) EdgeCleared(name string) bool {
	switch name {
	case workspace.EdgeUsers:
		return m.clearedusers
	case workspace.EdgeWorkspaceInvites:
		return m.clearedworkspace_invites
	case workspace.EdgeWorkspaceUsers:
		return m.clearedworkspace_users
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Workspace unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceMutation) ResetEdge(name string) error {
	switch name {
	case workspace.EdgeUsers:
		m.ResetUsers()
		return nil
	case workspace.EdgeWorkspaceInvites:
		m.ResetWorkspaceInvites()
		return nil
	case workspace.EdgeWorkspaceUsers:
		m.ResetWorkspaceUsers()
		return nil
	}
	return fmt.Errorf("unknown Workspace edge %s", name)
}

// WorkspaceInviteMutation represents an operation that mutates the WorkspaceInvite nodes in the graph.
type WorkspaceInviteMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	app_id           *string
	email            *string
	role             *string
	clearedFields    map[string]struct{}
	workspace        *string
	clearedworkspace bool
	done             bool
	oldValue         func(context.Context) (*WorkspaceInvite, error)
	predicates       []predicate.WorkspaceInvite
}

var _ ent.Mutation = (*WorkspaceInviteMutation)(nil)

// workspaceinviteOption allows management of the mutation configuration using functional options.
type workspaceinviteOption func(*WorkspaceInviteMutation)

// newWorkspaceInviteMutation creates new mutation for the WorkspaceInvite entity.
func newWorkspaceInviteMutation(c config, op Op, opts ...workspaceinviteOption) *WorkspaceInviteMutation {
	m := &WorkspaceInviteMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspaceInvite,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceInviteID sets the ID field of the mutation.
func withWorkspaceInviteID(id string) workspaceinviteOption {
	return func(m *WorkspaceInviteMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkspaceInvite
		)
		m.oldValue = func(ctx context.Context) (*WorkspaceInvite, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkspaceInvite.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspaceInvite sets the old WorkspaceInvite of the mutation.
func withWorkspaceInvite(node *WorkspaceInvite) workspaceinviteOption {
	return func(m *WorkspaceInviteMutation) {
		m.oldValue = func(context.Context) (*WorkspaceInvite, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceInviteMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceInviteMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkspaceInvite entities.
func (m *WorkspaceInviteMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceInviteMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceInviteMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkspaceInvite.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceInviteMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceInviteMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkspaceInvite entity.
// If the WorkspaceInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceInviteMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkspaceInviteMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workspaceinvite.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkspaceInviteMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workspaceinvite.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceInviteMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workspaceinvite.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceInviteMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceInviteMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkspaceInvite entity.
// If the WorkspaceInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceInviteMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkspaceInviteMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workspaceinvite.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkspaceInviteMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workspaceinvite.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceInviteMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workspaceinvite.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *WorkspaceInviteMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *WorkspaceInviteMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the WorkspaceInvite entity.
// If the WorkspaceInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceInviteMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *WorkspaceInviteMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[workspaceinvite.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *WorkspaceInviteMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[workspaceinvite.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *WorkspaceInviteMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, workspaceinvite.FieldAppID)
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *WorkspaceInviteMutation) SetWorkspaceID(s string) {
	m.workspace = &s
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *WorkspaceInviteMutation) WorkspaceID() (r string, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the WorkspaceInvite entity.
// If the WorkspaceInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceInviteMutation) OldWorkspaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ClearWorkspaceID clears the value of the "workspace_id" field.
func (m *WorkspaceInviteMutation) ClearWorkspaceID() {
	m.workspace = nil
	m.clearedFields[workspaceinvite.FieldWorkspaceID] = struct{}{}
}

// WorkspaceIDCleared returns if the "workspace_id" field was cleared in this mutation.
func (m *WorkspaceInviteMutation) WorkspaceIDCleared() bool {
	_, ok := m.clearedFields[workspaceinvite.FieldWorkspaceID]
	return ok
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *WorkspaceInviteMutation) ResetWorkspaceID() {
	m.workspace = nil
	delete(m.clearedFields, workspaceinvite.FieldWorkspaceID)
}

// SetEmail sets the "email" field.
func (m *WorkspaceInviteMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *WorkspaceInviteMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the WorkspaceInvite entity.
// If the WorkspaceInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceInviteMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ClearEmail clears the value of the "email" field.
func (m *WorkspaceInviteMutation) ClearEmail() {
	m.email = nil
	m.clearedFields[workspaceinvite.FieldEmail] = struct{}{}
}

// EmailCleared returns if the "email" field was cleared in this mutation.
func (m *WorkspaceInviteMutation) EmailCleared() bool {
	_, ok := m.clearedFields[workspaceinvite.FieldEmail]
	return ok
}

// ResetEmail resets all changes to the "email" field.
func (m *WorkspaceInviteMutation) ResetEmail() {
	m.email = nil
	delete(m.clearedFields, workspaceinvite.FieldEmail)
}

// SetRole sets the "role" field.
func (m *WorkspaceInviteMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *WorkspaceInviteMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the WorkspaceInvite entity.
// If the WorkspaceInvite object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceInviteMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *WorkspaceInviteMutation) ClearRole() {
	m.role = nil
	m.clearedFields[workspaceinvite.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *WorkspaceInviteMutation) RoleCleared() bool {
	_, ok := m.clearedFields[workspaceinvite.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *WorkspaceInviteMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, workspaceinvite.FieldRole)
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *WorkspaceInviteMutation) ClearWorkspace() {
	m.clearedworkspace = true
	m.clearedFields[workspaceinvite.FieldWorkspaceID] = struct{}{}
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *WorkspaceInviteMutation) WorkspaceCleared() bool {
	return m.WorkspaceIDCleared() || m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *WorkspaceInviteMutation) WorkspaceIDs() (ids []string) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *WorkspaceInviteMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// Where appends a list predicates to the WorkspaceInviteMutation builder.
func (m *WorkspaceInviteMutation) Where(ps ...predicate.WorkspaceInvite) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkspaceInviteMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkspaceInviteMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkspaceInvite, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkspaceInviteMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkspaceInviteMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkspaceInvite).
func (m *WorkspaceInviteMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceInviteMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, workspaceinvite.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspaceinvite.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, workspaceinvite.FieldAppID)
	}
	if m.workspace != nil {
		fields = append(fields, workspaceinvite.FieldWorkspaceID)
	}
	if m.email != nil {
		fields = append(fields, workspaceinvite.FieldEmail)
	}
	if m.role != nil {
		fields = append(fields, workspaceinvite.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceInviteMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspaceinvite.FieldCreatedAt:
		return m.CreatedAt()
	case workspaceinvite.FieldUpdatedAt:
		return m.UpdatedAt()
	case workspaceinvite.FieldAppID:
		return m.AppID()
	case workspaceinvite.FieldWorkspaceID:
		return m.WorkspaceID()
	case workspaceinvite.FieldEmail:
		return m.Email()
	case workspaceinvite.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceInviteMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspaceinvite.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspaceinvite.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workspaceinvite.FieldAppID:
		return m.OldAppID(ctx)
	case workspaceinvite.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case workspaceinvite.FieldEmail:
		return m.OldEmail(ctx)
	case workspaceinvite.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown WorkspaceInvite field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceInviteMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspaceinvite.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspaceinvite.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workspaceinvite.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case workspaceinvite.FieldWorkspaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case workspaceinvite.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case workspaceinvite.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown WorkspaceInvite field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceInviteMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceInviteMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceInviteMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkspaceInvite numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceInviteMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workspaceinvite.FieldCreatedAt) {
		fields = append(fields, workspaceinvite.FieldCreatedAt)
	}
	if m.FieldCleared(workspaceinvite.FieldUpdatedAt) {
		fields = append(fields, workspaceinvite.FieldUpdatedAt)
	}
	if m.FieldCleared(workspaceinvite.FieldAppID) {
		fields = append(fields, workspaceinvite.FieldAppID)
	}
	if m.FieldCleared(workspaceinvite.FieldWorkspaceID) {
		fields = append(fields, workspaceinvite.FieldWorkspaceID)
	}
	if m.FieldCleared(workspaceinvite.FieldEmail) {
		fields = append(fields, workspaceinvite.FieldEmail)
	}
	if m.FieldCleared(workspaceinvite.FieldRole) {
		fields = append(fields, workspaceinvite.FieldRole)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceInviteMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceInviteMutation) ClearField(name string) error {
	switch name {
	case workspaceinvite.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workspaceinvite.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workspaceinvite.FieldAppID:
		m.ClearAppID()
		return nil
	case workspaceinvite.FieldWorkspaceID:
		m.ClearWorkspaceID()
		return nil
	case workspaceinvite.FieldEmail:
		m.ClearEmail()
		return nil
	case workspaceinvite.FieldRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceInvite nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceInviteMutation) ResetField(name string) error {
	switch name {
	case workspaceinvite.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspaceinvite.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workspaceinvite.FieldAppID:
		m.ResetAppID()
		return nil
	case workspaceinvite.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case workspaceinvite.FieldEmail:
		m.ResetEmail()
		return nil
	case workspaceinvite.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceInvite field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceInviteMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.workspace != nil {
		edges = append(edges, workspaceinvite.EdgeWorkspace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceInviteMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspaceinvite.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceInviteMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceInviteMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceInviteMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedworkspace {
		edges = append(edges, workspaceinvite.EdgeWorkspace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceInviteMutation) EdgeCleared(name string) bool {
	switch name {
	case workspaceinvite.EdgeWorkspace:
		return m.clearedworkspace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceInviteMutation) ClearEdge(name string) error {
	switch name {
	case workspaceinvite.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceInvite unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceInviteMutation) ResetEdge(name string) error {
	switch name {
	case workspaceinvite.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceInvite edge %s", name)
}

// WorkspaceUserMutation represents an operation that mutates the WorkspaceUser nodes in the graph.
type WorkspaceUserMutation struct {
	config
	op               Op
	typ              string
	id               *string
	created_at       *time.Time
	updated_at       *time.Time
	app_id           *string
	role             *string
	clearedFields    map[string]struct{}
	user             *string
	cleareduser      bool
	workspace        *string
	clearedworkspace bool
	done             bool
	oldValue         func(context.Context) (*WorkspaceUser, error)
	predicates       []predicate.WorkspaceUser
}

var _ ent.Mutation = (*WorkspaceUserMutation)(nil)

// workspaceuserOption allows management of the mutation configuration using functional options.
type workspaceuserOption func(*WorkspaceUserMutation)

// newWorkspaceUserMutation creates new mutation for the WorkspaceUser entity.
func newWorkspaceUserMutation(c config, op Op, opts ...workspaceuserOption) *WorkspaceUserMutation {
	m := &WorkspaceUserMutation{
		config:        c,
		op:            op,
		typ:           TypeWorkspaceUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withWorkspaceUserID sets the ID field of the mutation.
func withWorkspaceUserID(id string) workspaceuserOption {
	return func(m *WorkspaceUserMutation) {
		var (
			err   error
			once  sync.Once
			value *WorkspaceUser
		)
		m.oldValue = func(ctx context.Context) (*WorkspaceUser, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().WorkspaceUser.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withWorkspaceUser sets the old WorkspaceUser of the mutation.
func withWorkspaceUser(node *WorkspaceUser) workspaceuserOption {
	return func(m *WorkspaceUserMutation) {
		m.oldValue = func(context.Context) (*WorkspaceUser, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m WorkspaceUserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m WorkspaceUserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of WorkspaceUser entities.
func (m *WorkspaceUserMutation) SetID(id string) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *WorkspaceUserMutation) ID() (id string, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *WorkspaceUserMutation) IDs(ctx context.Context) ([]string, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []string{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().WorkspaceUser.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *WorkspaceUserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *WorkspaceUserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the WorkspaceUser entity.
// If the WorkspaceUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceUserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *WorkspaceUserMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[workspaceuser.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *WorkspaceUserMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[workspaceuser.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *WorkspaceUserMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, workspaceuser.FieldCreatedAt)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *WorkspaceUserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *WorkspaceUserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the WorkspaceUser entity.
// If the WorkspaceUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceUserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ClearUpdatedAt clears the value of the "updated_at" field.
func (m *WorkspaceUserMutation) ClearUpdatedAt() {
	m.updated_at = nil
	m.clearedFields[workspaceuser.FieldUpdatedAt] = struct{}{}
}

// UpdatedAtCleared returns if the "updated_at" field was cleared in this mutation.
func (m *WorkspaceUserMutation) UpdatedAtCleared() bool {
	_, ok := m.clearedFields[workspaceuser.FieldUpdatedAt]
	return ok
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *WorkspaceUserMutation) ResetUpdatedAt() {
	m.updated_at = nil
	delete(m.clearedFields, workspaceuser.FieldUpdatedAt)
}

// SetAppID sets the "app_id" field.
func (m *WorkspaceUserMutation) SetAppID(s string) {
	m.app_id = &s
}

// AppID returns the value of the "app_id" field in the mutation.
func (m *WorkspaceUserMutation) AppID() (r string, exists bool) {
	v := m.app_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAppID returns the old "app_id" field's value of the WorkspaceUser entity.
// If the WorkspaceUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceUserMutation) OldAppID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAppID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAppID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAppID: %w", err)
	}
	return oldValue.AppID, nil
}

// ClearAppID clears the value of the "app_id" field.
func (m *WorkspaceUserMutation) ClearAppID() {
	m.app_id = nil
	m.clearedFields[workspaceuser.FieldAppID] = struct{}{}
}

// AppIDCleared returns if the "app_id" field was cleared in this mutation.
func (m *WorkspaceUserMutation) AppIDCleared() bool {
	_, ok := m.clearedFields[workspaceuser.FieldAppID]
	return ok
}

// ResetAppID resets all changes to the "app_id" field.
func (m *WorkspaceUserMutation) ResetAppID() {
	m.app_id = nil
	delete(m.clearedFields, workspaceuser.FieldAppID)
}

// SetWorkspaceID sets the "workspace_id" field.
func (m *WorkspaceUserMutation) SetWorkspaceID(s string) {
	m.workspace = &s
}

// WorkspaceID returns the value of the "workspace_id" field in the mutation.
func (m *WorkspaceUserMutation) WorkspaceID() (r string, exists bool) {
	v := m.workspace
	if v == nil {
		return
	}
	return *v, true
}

// OldWorkspaceID returns the old "workspace_id" field's value of the WorkspaceUser entity.
// If the WorkspaceUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceUserMutation) OldWorkspaceID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldWorkspaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldWorkspaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWorkspaceID: %w", err)
	}
	return oldValue.WorkspaceID, nil
}

// ResetWorkspaceID resets all changes to the "workspace_id" field.
func (m *WorkspaceUserMutation) ResetWorkspaceID() {
	m.workspace = nil
}

// SetUserID sets the "user_id" field.
func (m *WorkspaceUserMutation) SetUserID(s string) {
	m.user = &s
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *WorkspaceUserMutation) UserID() (r string, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the WorkspaceUser entity.
// If the WorkspaceUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceUserMutation) OldUserID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *WorkspaceUserMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *WorkspaceUserMutation) SetRole(s string) {
	m.role = &s
}

// Role returns the value of the "role" field in the mutation.
func (m *WorkspaceUserMutation) Role() (r string, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the WorkspaceUser entity.
// If the WorkspaceUser object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *WorkspaceUserMutation) OldRole(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ClearRole clears the value of the "role" field.
func (m *WorkspaceUserMutation) ClearRole() {
	m.role = nil
	m.clearedFields[workspaceuser.FieldRole] = struct{}{}
}

// RoleCleared returns if the "role" field was cleared in this mutation.
func (m *WorkspaceUserMutation) RoleCleared() bool {
	_, ok := m.clearedFields[workspaceuser.FieldRole]
	return ok
}

// ResetRole resets all changes to the "role" field.
func (m *WorkspaceUserMutation) ResetRole() {
	m.role = nil
	delete(m.clearedFields, workspaceuser.FieldRole)
}

// ClearUser clears the "user" edge to the User entity.
func (m *WorkspaceUserMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[workspaceuser.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *WorkspaceUserMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *WorkspaceUserMutation) UserIDs() (ids []string) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *WorkspaceUserMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// ClearWorkspace clears the "workspace" edge to the Workspace entity.
func (m *WorkspaceUserMutation) ClearWorkspace() {
	m.clearedworkspace = true
	m.clearedFields[workspaceuser.FieldWorkspaceID] = struct{}{}
}

// WorkspaceCleared reports if the "workspace" edge to the Workspace entity was cleared.
func (m *WorkspaceUserMutation) WorkspaceCleared() bool {
	return m.clearedworkspace
}

// WorkspaceIDs returns the "workspace" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// WorkspaceID instead. It exists only for internal usage by the builders.
func (m *WorkspaceUserMutation) WorkspaceIDs() (ids []string) {
	if id := m.workspace; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetWorkspace resets all changes to the "workspace" edge.
func (m *WorkspaceUserMutation) ResetWorkspace() {
	m.workspace = nil
	m.clearedworkspace = false
}

// Where appends a list predicates to the WorkspaceUserMutation builder.
func (m *WorkspaceUserMutation) Where(ps ...predicate.WorkspaceUser) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the WorkspaceUserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *WorkspaceUserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.WorkspaceUser, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *WorkspaceUserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *WorkspaceUserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (WorkspaceUser).
func (m *WorkspaceUserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *WorkspaceUserMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.created_at != nil {
		fields = append(fields, workspaceuser.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, workspaceuser.FieldUpdatedAt)
	}
	if m.app_id != nil {
		fields = append(fields, workspaceuser.FieldAppID)
	}
	if m.workspace != nil {
		fields = append(fields, workspaceuser.FieldWorkspaceID)
	}
	if m.user != nil {
		fields = append(fields, workspaceuser.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, workspaceuser.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *WorkspaceUserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case workspaceuser.FieldCreatedAt:
		return m.CreatedAt()
	case workspaceuser.FieldUpdatedAt:
		return m.UpdatedAt()
	case workspaceuser.FieldAppID:
		return m.AppID()
	case workspaceuser.FieldWorkspaceID:
		return m.WorkspaceID()
	case workspaceuser.FieldUserID:
		return m.UserID()
	case workspaceuser.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *WorkspaceUserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case workspaceuser.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case workspaceuser.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case workspaceuser.FieldAppID:
		return m.OldAppID(ctx)
	case workspaceuser.FieldWorkspaceID:
		return m.OldWorkspaceID(ctx)
	case workspaceuser.FieldUserID:
		return m.OldUserID(ctx)
	case workspaceuser.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown WorkspaceUser field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceUserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case workspaceuser.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case workspaceuser.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case workspaceuser.FieldAppID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAppID(v)
		return nil
	case workspaceuser.FieldWorkspaceID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWorkspaceID(v)
		return nil
	case workspaceuser.FieldUserID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case workspaceuser.FieldRole:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown WorkspaceUser field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *WorkspaceUserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *WorkspaceUserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *WorkspaceUserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown WorkspaceUser numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *WorkspaceUserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(workspaceuser.FieldCreatedAt) {
		fields = append(fields, workspaceuser.FieldCreatedAt)
	}
	if m.FieldCleared(workspaceuser.FieldUpdatedAt) {
		fields = append(fields, workspaceuser.FieldUpdatedAt)
	}
	if m.FieldCleared(workspaceuser.FieldAppID) {
		fields = append(fields, workspaceuser.FieldAppID)
	}
	if m.FieldCleared(workspaceuser.FieldRole) {
		fields = append(fields, workspaceuser.FieldRole)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *WorkspaceUserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *WorkspaceUserMutation) ClearField(name string) error {
	switch name {
	case workspaceuser.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	case workspaceuser.FieldUpdatedAt:
		m.ClearUpdatedAt()
		return nil
	case workspaceuser.FieldAppID:
		m.ClearAppID()
		return nil
	case workspaceuser.FieldRole:
		m.ClearRole()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceUser nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *WorkspaceUserMutation) ResetField(name string) error {
	switch name {
	case workspaceuser.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case workspaceuser.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case workspaceuser.FieldAppID:
		m.ResetAppID()
		return nil
	case workspaceuser.FieldWorkspaceID:
		m.ResetWorkspaceID()
		return nil
	case workspaceuser.FieldUserID:
		m.ResetUserID()
		return nil
	case workspaceuser.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceUser field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *WorkspaceUserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.user != nil {
		edges = append(edges, workspaceuser.EdgeUser)
	}
	if m.workspace != nil {
		edges = append(edges, workspaceuser.EdgeWorkspace)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *WorkspaceUserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case workspaceuser.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case workspaceuser.EdgeWorkspace:
		if id := m.workspace; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *WorkspaceUserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *WorkspaceUserMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *WorkspaceUserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, workspaceuser.EdgeUser)
	}
	if m.clearedworkspace {
		edges = append(edges, workspaceuser.EdgeWorkspace)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *WorkspaceUserMutation) EdgeCleared(name string) bool {
	switch name {
	case workspaceuser.EdgeUser:
		return m.cleareduser
	case workspaceuser.EdgeWorkspace:
		return m.clearedworkspace
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *WorkspaceUserMutation) ClearEdge(name string) error {
	switch name {
	case workspaceuser.EdgeUser:
		m.ClearUser()
		return nil
	case workspaceuser.EdgeWorkspace:
		m.ClearWorkspace()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceUser unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *WorkspaceUserMutation) ResetEdge(name string) error {
	switch name {
	case workspaceuser.EdgeUser:
		m.ResetUser()
		return nil
	case workspaceuser.EdgeWorkspace:
		m.ResetWorkspace()
		return nil
	}
	return fmt.Errorf("unknown WorkspaceUser edge %s", name)
}
