// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"saas/gen/ent/post"
	"saas/gen/ent/postcategory"
	"saas/gen/ent/poststatus"
	"saas/gen/ent/posttag"
	"saas/gen/ent/posttype"
	"saas/gen/ent/predicate"
	"saas/gen/ent/todo"
	"time"
)

// PostWhereInput represents a where input for filtering Post queries.
type PostWhereInput struct {
	Predicates []predicate.Post  `json:"-"`
	Not        *PostWhereInput   `json:"not,omitempty"`
	Or         []*PostWhereInput `json:"or,omitempty"`
	And        []*PostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "post_status_id" field predicates.
	PostStatusID             *string  `json:"postStatusID,omitempty"`
	PostStatusIDNEQ          *string  `json:"postStatusIDNEQ,omitempty"`
	PostStatusIDIn           []string `json:"postStatusIDIn,omitempty"`
	PostStatusIDNotIn        []string `json:"postStatusIDNotIn,omitempty"`
	PostStatusIDGT           *string  `json:"postStatusIDGT,omitempty"`
	PostStatusIDGTE          *string  `json:"postStatusIDGTE,omitempty"`
	PostStatusIDLT           *string  `json:"postStatusIDLT,omitempty"`
	PostStatusIDLTE          *string  `json:"postStatusIDLTE,omitempty"`
	PostStatusIDContains     *string  `json:"postStatusIDContains,omitempty"`
	PostStatusIDHasPrefix    *string  `json:"postStatusIDHasPrefix,omitempty"`
	PostStatusIDHasSuffix    *string  `json:"postStatusIDHasSuffix,omitempty"`
	PostStatusIDIsNil        bool     `json:"postStatusIDIsNil,omitempty"`
	PostStatusIDNotNil       bool     `json:"postStatusIDNotNil,omitempty"`
	PostStatusIDEqualFold    *string  `json:"postStatusIDEqualFold,omitempty"`
	PostStatusIDContainsFold *string  `json:"postStatusIDContainsFold,omitempty"`

	// "post_type_id" field predicates.
	PostTypeID             *string  `json:"postTypeID,omitempty"`
	PostTypeIDNEQ          *string  `json:"postTypeIDNEQ,omitempty"`
	PostTypeIDIn           []string `json:"postTypeIDIn,omitempty"`
	PostTypeIDNotIn        []string `json:"postTypeIDNotIn,omitempty"`
	PostTypeIDGT           *string  `json:"postTypeIDGT,omitempty"`
	PostTypeIDGTE          *string  `json:"postTypeIDGTE,omitempty"`
	PostTypeIDLT           *string  `json:"postTypeIDLT,omitempty"`
	PostTypeIDLTE          *string  `json:"postTypeIDLTE,omitempty"`
	PostTypeIDContains     *string  `json:"postTypeIDContains,omitempty"`
	PostTypeIDHasPrefix    *string  `json:"postTypeIDHasPrefix,omitempty"`
	PostTypeIDHasSuffix    *string  `json:"postTypeIDHasSuffix,omitempty"`
	PostTypeIDIsNil        bool     `json:"postTypeIDIsNil,omitempty"`
	PostTypeIDNotNil       bool     `json:"postTypeIDNotNil,omitempty"`
	PostTypeIDEqualFold    *string  `json:"postTypeIDEqualFold,omitempty"`
	PostTypeIDContainsFold *string  `json:"postTypeIDContainsFold,omitempty"`

	// "primary_category_id" field predicates.
	PrimaryCategoryID             *string  `json:"primaryCategoryID,omitempty"`
	PrimaryCategoryIDNEQ          *string  `json:"primaryCategoryIDNEQ,omitempty"`
	PrimaryCategoryIDIn           []string `json:"primaryCategoryIDIn,omitempty"`
	PrimaryCategoryIDNotIn        []string `json:"primaryCategoryIDNotIn,omitempty"`
	PrimaryCategoryIDGT           *string  `json:"primaryCategoryIDGT,omitempty"`
	PrimaryCategoryIDGTE          *string  `json:"primaryCategoryIDGTE,omitempty"`
	PrimaryCategoryIDLT           *string  `json:"primaryCategoryIDLT,omitempty"`
	PrimaryCategoryIDLTE          *string  `json:"primaryCategoryIDLTE,omitempty"`
	PrimaryCategoryIDContains     *string  `json:"primaryCategoryIDContains,omitempty"`
	PrimaryCategoryIDHasPrefix    *string  `json:"primaryCategoryIDHasPrefix,omitempty"`
	PrimaryCategoryIDHasSuffix    *string  `json:"primaryCategoryIDHasSuffix,omitempty"`
	PrimaryCategoryIDIsNil        bool     `json:"primaryCategoryIDIsNil,omitempty"`
	PrimaryCategoryIDNotNil       bool     `json:"primaryCategoryIDNotNil,omitempty"`
	PrimaryCategoryIDEqualFold    *string  `json:"primaryCategoryIDEqualFold,omitempty"`
	PrimaryCategoryIDContainsFold *string  `json:"primaryCategoryIDContainsFold,omitempty"`

	// "headline" field predicates.
	Headline             *string  `json:"headline,omitempty"`
	HeadlineNEQ          *string  `json:"headlineNEQ,omitempty"`
	HeadlineIn           []string `json:"headlineIn,omitempty"`
	HeadlineNotIn        []string `json:"headlineNotIn,omitempty"`
	HeadlineGT           *string  `json:"headlineGT,omitempty"`
	HeadlineGTE          *string  `json:"headlineGTE,omitempty"`
	HeadlineLT           *string  `json:"headlineLT,omitempty"`
	HeadlineLTE          *string  `json:"headlineLTE,omitempty"`
	HeadlineContains     *string  `json:"headlineContains,omitempty"`
	HeadlineHasPrefix    *string  `json:"headlineHasPrefix,omitempty"`
	HeadlineHasSuffix    *string  `json:"headlineHasSuffix,omitempty"`
	HeadlineIsNil        bool     `json:"headlineIsNil,omitempty"`
	HeadlineNotNil       bool     `json:"headlineNotNil,omitempty"`
	HeadlineEqualFold    *string  `json:"headlineEqualFold,omitempty"`
	HeadlineContainsFold *string  `json:"headlineContainsFold,omitempty"`

	// "excerpt" field predicates.
	Excerpt             *string  `json:"excerpt,omitempty"`
	ExcerptNEQ          *string  `json:"excerptNEQ,omitempty"`
	ExcerptIn           []string `json:"excerptIn,omitempty"`
	ExcerptNotIn        []string `json:"excerptNotIn,omitempty"`
	ExcerptGT           *string  `json:"excerptGT,omitempty"`
	ExcerptGTE          *string  `json:"excerptGTE,omitempty"`
	ExcerptLT           *string  `json:"excerptLT,omitempty"`
	ExcerptLTE          *string  `json:"excerptLTE,omitempty"`
	ExcerptContains     *string  `json:"excerptContains,omitempty"`
	ExcerptHasPrefix    *string  `json:"excerptHasPrefix,omitempty"`
	ExcerptHasSuffix    *string  `json:"excerptHasSuffix,omitempty"`
	ExcerptIsNil        bool     `json:"excerptIsNil,omitempty"`
	ExcerptNotNil       bool     `json:"excerptNotNil,omitempty"`
	ExcerptEqualFold    *string  `json:"excerptEqualFold,omitempty"`
	ExcerptContainsFold *string  `json:"excerptContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "meta_title" field predicates.
	MetaTitle             *string  `json:"metaTitle,omitempty"`
	MetaTitleNEQ          *string  `json:"metaTitleNEQ,omitempty"`
	MetaTitleIn           []string `json:"metaTitleIn,omitempty"`
	MetaTitleNotIn        []string `json:"metaTitleNotIn,omitempty"`
	MetaTitleGT           *string  `json:"metaTitleGT,omitempty"`
	MetaTitleGTE          *string  `json:"metaTitleGTE,omitempty"`
	MetaTitleLT           *string  `json:"metaTitleLT,omitempty"`
	MetaTitleLTE          *string  `json:"metaTitleLTE,omitempty"`
	MetaTitleContains     *string  `json:"metaTitleContains,omitempty"`
	MetaTitleHasPrefix    *string  `json:"metaTitleHasPrefix,omitempty"`
	MetaTitleHasSuffix    *string  `json:"metaTitleHasSuffix,omitempty"`
	MetaTitleIsNil        bool     `json:"metaTitleIsNil,omitempty"`
	MetaTitleNotNil       bool     `json:"metaTitleNotNil,omitempty"`
	MetaTitleEqualFold    *string  `json:"metaTitleEqualFold,omitempty"`
	MetaTitleContainsFold *string  `json:"metaTitleContainsFold,omitempty"`

	// "meta_descr" field predicates.
	MetaDescr             *string  `json:"metaDescr,omitempty"`
	MetaDescrNEQ          *string  `json:"metaDescrNEQ,omitempty"`
	MetaDescrIn           []string `json:"metaDescrIn,omitempty"`
	MetaDescrNotIn        []string `json:"metaDescrNotIn,omitempty"`
	MetaDescrGT           *string  `json:"metaDescrGT,omitempty"`
	MetaDescrGTE          *string  `json:"metaDescrGTE,omitempty"`
	MetaDescrLT           *string  `json:"metaDescrLT,omitempty"`
	MetaDescrLTE          *string  `json:"metaDescrLTE,omitempty"`
	MetaDescrContains     *string  `json:"metaDescrContains,omitempty"`
	MetaDescrHasPrefix    *string  `json:"metaDescrHasPrefix,omitempty"`
	MetaDescrHasSuffix    *string  `json:"metaDescrHasSuffix,omitempty"`
	MetaDescrIsNil        bool     `json:"metaDescrIsNil,omitempty"`
	MetaDescrNotNil       bool     `json:"metaDescrNotNil,omitempty"`
	MetaDescrEqualFold    *string  `json:"metaDescrEqualFold,omitempty"`
	MetaDescrContainsFold *string  `json:"metaDescrContainsFold,omitempty"`

	// "meta_canonical_url" field predicates.
	MetaCanonicalURL             *string  `json:"metaCanonicalURL,omitempty"`
	MetaCanonicalURLNEQ          *string  `json:"metaCanonicalURLNEQ,omitempty"`
	MetaCanonicalURLIn           []string `json:"metaCanonicalURLIn,omitempty"`
	MetaCanonicalURLNotIn        []string `json:"metaCanonicalURLNotIn,omitempty"`
	MetaCanonicalURLGT           *string  `json:"metaCanonicalURLGT,omitempty"`
	MetaCanonicalURLGTE          *string  `json:"metaCanonicalURLGTE,omitempty"`
	MetaCanonicalURLLT           *string  `json:"metaCanonicalURLLT,omitempty"`
	MetaCanonicalURLLTE          *string  `json:"metaCanonicalURLLTE,omitempty"`
	MetaCanonicalURLContains     *string  `json:"metaCanonicalURLContains,omitempty"`
	MetaCanonicalURLHasPrefix    *string  `json:"metaCanonicalURLHasPrefix,omitempty"`
	MetaCanonicalURLHasSuffix    *string  `json:"metaCanonicalURLHasSuffix,omitempty"`
	MetaCanonicalURLIsNil        bool     `json:"metaCanonicalURLIsNil,omitempty"`
	MetaCanonicalURLNotNil       bool     `json:"metaCanonicalURLNotNil,omitempty"`
	MetaCanonicalURLEqualFold    *string  `json:"metaCanonicalURLEqualFold,omitempty"`
	MetaCanonicalURLContainsFold *string  `json:"metaCanonicalURLContainsFold,omitempty"`

	// "meta_robots" field predicates.
	MetaRobots             *string  `json:"metaRobots,omitempty"`
	MetaRobotsNEQ          *string  `json:"metaRobotsNEQ,omitempty"`
	MetaRobotsIn           []string `json:"metaRobotsIn,omitempty"`
	MetaRobotsNotIn        []string `json:"metaRobotsNotIn,omitempty"`
	MetaRobotsGT           *string  `json:"metaRobotsGT,omitempty"`
	MetaRobotsGTE          *string  `json:"metaRobotsGTE,omitempty"`
	MetaRobotsLT           *string  `json:"metaRobotsLT,omitempty"`
	MetaRobotsLTE          *string  `json:"metaRobotsLTE,omitempty"`
	MetaRobotsContains     *string  `json:"metaRobotsContains,omitempty"`
	MetaRobotsHasPrefix    *string  `json:"metaRobotsHasPrefix,omitempty"`
	MetaRobotsHasSuffix    *string  `json:"metaRobotsHasSuffix,omitempty"`
	MetaRobotsIsNil        bool     `json:"metaRobotsIsNil,omitempty"`
	MetaRobotsNotNil       bool     `json:"metaRobotsNotNil,omitempty"`
	MetaRobotsEqualFold    *string  `json:"metaRobotsEqualFold,omitempty"`
	MetaRobotsContainsFold *string  `json:"metaRobotsContainsFold,omitempty"`

	// "post_status" edge predicates.
	HasPostStatus     *bool                   `json:"hasPostStatus,omitempty"`
	HasPostStatusWith []*PostStatusWhereInput `json:"hasPostStatusWith,omitempty"`

	// "post_type" edge predicates.
	HasPostType     *bool                 `json:"hasPostType,omitempty"`
	HasPostTypeWith []*PostTypeWhereInput `json:"hasPostTypeWith,omitempty"`

	// "primary_category" edge predicates.
	HasPrimaryCategory     *bool                     `json:"hasPrimaryCategory,omitempty"`
	HasPrimaryCategoryWith []*PostCategoryWhereInput `json:"hasPrimaryCategoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostWhereInput) AddPredicates(predicates ...predicate.Post) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostWhereInput filter on the PostQuery builder.
func (i *PostWhereInput) Filter(q *PostQuery) (*PostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostWhereInput is returned in case the PostWhereInput is empty.
var ErrEmptyPostWhereInput = errors.New("ent: empty predicate PostWhereInput")

// P returns a predicate for filtering posts.
// An error is returned if the input is empty or invalid.
func (i *PostWhereInput) P() (predicate.Post, error) {
	var predicates []predicate.Post
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, post.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Post, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, post.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Post, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, post.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, post.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, post.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, post.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, post.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, post.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, post.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, post.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, post.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, post.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, post.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, post.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, post.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, post.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, post.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, post.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, post.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, post.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, post.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, post.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, post.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, post.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, post.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, post.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, post.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, post.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, post.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, post.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, post.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, post.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, post.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, post.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, post.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, post.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, post.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, post.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, post.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, post.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, post.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, post.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, post.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, post.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, post.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, post.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, post.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, post.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, post.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, post.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, post.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, post.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, post.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, post.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, post.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, post.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, post.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, post.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, post.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, post.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, post.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, post.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, post.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.PostStatusID != nil {
		predicates = append(predicates, post.PostStatusIDEQ(*i.PostStatusID))
	}
	if i.PostStatusIDNEQ != nil {
		predicates = append(predicates, post.PostStatusIDNEQ(*i.PostStatusIDNEQ))
	}
	if len(i.PostStatusIDIn) > 0 {
		predicates = append(predicates, post.PostStatusIDIn(i.PostStatusIDIn...))
	}
	if len(i.PostStatusIDNotIn) > 0 {
		predicates = append(predicates, post.PostStatusIDNotIn(i.PostStatusIDNotIn...))
	}
	if i.PostStatusIDGT != nil {
		predicates = append(predicates, post.PostStatusIDGT(*i.PostStatusIDGT))
	}
	if i.PostStatusIDGTE != nil {
		predicates = append(predicates, post.PostStatusIDGTE(*i.PostStatusIDGTE))
	}
	if i.PostStatusIDLT != nil {
		predicates = append(predicates, post.PostStatusIDLT(*i.PostStatusIDLT))
	}
	if i.PostStatusIDLTE != nil {
		predicates = append(predicates, post.PostStatusIDLTE(*i.PostStatusIDLTE))
	}
	if i.PostStatusIDContains != nil {
		predicates = append(predicates, post.PostStatusIDContains(*i.PostStatusIDContains))
	}
	if i.PostStatusIDHasPrefix != nil {
		predicates = append(predicates, post.PostStatusIDHasPrefix(*i.PostStatusIDHasPrefix))
	}
	if i.PostStatusIDHasSuffix != nil {
		predicates = append(predicates, post.PostStatusIDHasSuffix(*i.PostStatusIDHasSuffix))
	}
	if i.PostStatusIDIsNil {
		predicates = append(predicates, post.PostStatusIDIsNil())
	}
	if i.PostStatusIDNotNil {
		predicates = append(predicates, post.PostStatusIDNotNil())
	}
	if i.PostStatusIDEqualFold != nil {
		predicates = append(predicates, post.PostStatusIDEqualFold(*i.PostStatusIDEqualFold))
	}
	if i.PostStatusIDContainsFold != nil {
		predicates = append(predicates, post.PostStatusIDContainsFold(*i.PostStatusIDContainsFold))
	}
	if i.PostTypeID != nil {
		predicates = append(predicates, post.PostTypeIDEQ(*i.PostTypeID))
	}
	if i.PostTypeIDNEQ != nil {
		predicates = append(predicates, post.PostTypeIDNEQ(*i.PostTypeIDNEQ))
	}
	if len(i.PostTypeIDIn) > 0 {
		predicates = append(predicates, post.PostTypeIDIn(i.PostTypeIDIn...))
	}
	if len(i.PostTypeIDNotIn) > 0 {
		predicates = append(predicates, post.PostTypeIDNotIn(i.PostTypeIDNotIn...))
	}
	if i.PostTypeIDGT != nil {
		predicates = append(predicates, post.PostTypeIDGT(*i.PostTypeIDGT))
	}
	if i.PostTypeIDGTE != nil {
		predicates = append(predicates, post.PostTypeIDGTE(*i.PostTypeIDGTE))
	}
	if i.PostTypeIDLT != nil {
		predicates = append(predicates, post.PostTypeIDLT(*i.PostTypeIDLT))
	}
	if i.PostTypeIDLTE != nil {
		predicates = append(predicates, post.PostTypeIDLTE(*i.PostTypeIDLTE))
	}
	if i.PostTypeIDContains != nil {
		predicates = append(predicates, post.PostTypeIDContains(*i.PostTypeIDContains))
	}
	if i.PostTypeIDHasPrefix != nil {
		predicates = append(predicates, post.PostTypeIDHasPrefix(*i.PostTypeIDHasPrefix))
	}
	if i.PostTypeIDHasSuffix != nil {
		predicates = append(predicates, post.PostTypeIDHasSuffix(*i.PostTypeIDHasSuffix))
	}
	if i.PostTypeIDIsNil {
		predicates = append(predicates, post.PostTypeIDIsNil())
	}
	if i.PostTypeIDNotNil {
		predicates = append(predicates, post.PostTypeIDNotNil())
	}
	if i.PostTypeIDEqualFold != nil {
		predicates = append(predicates, post.PostTypeIDEqualFold(*i.PostTypeIDEqualFold))
	}
	if i.PostTypeIDContainsFold != nil {
		predicates = append(predicates, post.PostTypeIDContainsFold(*i.PostTypeIDContainsFold))
	}
	if i.PrimaryCategoryID != nil {
		predicates = append(predicates, post.PrimaryCategoryIDEQ(*i.PrimaryCategoryID))
	}
	if i.PrimaryCategoryIDNEQ != nil {
		predicates = append(predicates, post.PrimaryCategoryIDNEQ(*i.PrimaryCategoryIDNEQ))
	}
	if len(i.PrimaryCategoryIDIn) > 0 {
		predicates = append(predicates, post.PrimaryCategoryIDIn(i.PrimaryCategoryIDIn...))
	}
	if len(i.PrimaryCategoryIDNotIn) > 0 {
		predicates = append(predicates, post.PrimaryCategoryIDNotIn(i.PrimaryCategoryIDNotIn...))
	}
	if i.PrimaryCategoryIDGT != nil {
		predicates = append(predicates, post.PrimaryCategoryIDGT(*i.PrimaryCategoryIDGT))
	}
	if i.PrimaryCategoryIDGTE != nil {
		predicates = append(predicates, post.PrimaryCategoryIDGTE(*i.PrimaryCategoryIDGTE))
	}
	if i.PrimaryCategoryIDLT != nil {
		predicates = append(predicates, post.PrimaryCategoryIDLT(*i.PrimaryCategoryIDLT))
	}
	if i.PrimaryCategoryIDLTE != nil {
		predicates = append(predicates, post.PrimaryCategoryIDLTE(*i.PrimaryCategoryIDLTE))
	}
	if i.PrimaryCategoryIDContains != nil {
		predicates = append(predicates, post.PrimaryCategoryIDContains(*i.PrimaryCategoryIDContains))
	}
	if i.PrimaryCategoryIDHasPrefix != nil {
		predicates = append(predicates, post.PrimaryCategoryIDHasPrefix(*i.PrimaryCategoryIDHasPrefix))
	}
	if i.PrimaryCategoryIDHasSuffix != nil {
		predicates = append(predicates, post.PrimaryCategoryIDHasSuffix(*i.PrimaryCategoryIDHasSuffix))
	}
	if i.PrimaryCategoryIDIsNil {
		predicates = append(predicates, post.PrimaryCategoryIDIsNil())
	}
	if i.PrimaryCategoryIDNotNil {
		predicates = append(predicates, post.PrimaryCategoryIDNotNil())
	}
	if i.PrimaryCategoryIDEqualFold != nil {
		predicates = append(predicates, post.PrimaryCategoryIDEqualFold(*i.PrimaryCategoryIDEqualFold))
	}
	if i.PrimaryCategoryIDContainsFold != nil {
		predicates = append(predicates, post.PrimaryCategoryIDContainsFold(*i.PrimaryCategoryIDContainsFold))
	}
	if i.Headline != nil {
		predicates = append(predicates, post.HeadlineEQ(*i.Headline))
	}
	if i.HeadlineNEQ != nil {
		predicates = append(predicates, post.HeadlineNEQ(*i.HeadlineNEQ))
	}
	if len(i.HeadlineIn) > 0 {
		predicates = append(predicates, post.HeadlineIn(i.HeadlineIn...))
	}
	if len(i.HeadlineNotIn) > 0 {
		predicates = append(predicates, post.HeadlineNotIn(i.HeadlineNotIn...))
	}
	if i.HeadlineGT != nil {
		predicates = append(predicates, post.HeadlineGT(*i.HeadlineGT))
	}
	if i.HeadlineGTE != nil {
		predicates = append(predicates, post.HeadlineGTE(*i.HeadlineGTE))
	}
	if i.HeadlineLT != nil {
		predicates = append(predicates, post.HeadlineLT(*i.HeadlineLT))
	}
	if i.HeadlineLTE != nil {
		predicates = append(predicates, post.HeadlineLTE(*i.HeadlineLTE))
	}
	if i.HeadlineContains != nil {
		predicates = append(predicates, post.HeadlineContains(*i.HeadlineContains))
	}
	if i.HeadlineHasPrefix != nil {
		predicates = append(predicates, post.HeadlineHasPrefix(*i.HeadlineHasPrefix))
	}
	if i.HeadlineHasSuffix != nil {
		predicates = append(predicates, post.HeadlineHasSuffix(*i.HeadlineHasSuffix))
	}
	if i.HeadlineIsNil {
		predicates = append(predicates, post.HeadlineIsNil())
	}
	if i.HeadlineNotNil {
		predicates = append(predicates, post.HeadlineNotNil())
	}
	if i.HeadlineEqualFold != nil {
		predicates = append(predicates, post.HeadlineEqualFold(*i.HeadlineEqualFold))
	}
	if i.HeadlineContainsFold != nil {
		predicates = append(predicates, post.HeadlineContainsFold(*i.HeadlineContainsFold))
	}
	if i.Excerpt != nil {
		predicates = append(predicates, post.ExcerptEQ(*i.Excerpt))
	}
	if i.ExcerptNEQ != nil {
		predicates = append(predicates, post.ExcerptNEQ(*i.ExcerptNEQ))
	}
	if len(i.ExcerptIn) > 0 {
		predicates = append(predicates, post.ExcerptIn(i.ExcerptIn...))
	}
	if len(i.ExcerptNotIn) > 0 {
		predicates = append(predicates, post.ExcerptNotIn(i.ExcerptNotIn...))
	}
	if i.ExcerptGT != nil {
		predicates = append(predicates, post.ExcerptGT(*i.ExcerptGT))
	}
	if i.ExcerptGTE != nil {
		predicates = append(predicates, post.ExcerptGTE(*i.ExcerptGTE))
	}
	if i.ExcerptLT != nil {
		predicates = append(predicates, post.ExcerptLT(*i.ExcerptLT))
	}
	if i.ExcerptLTE != nil {
		predicates = append(predicates, post.ExcerptLTE(*i.ExcerptLTE))
	}
	if i.ExcerptContains != nil {
		predicates = append(predicates, post.ExcerptContains(*i.ExcerptContains))
	}
	if i.ExcerptHasPrefix != nil {
		predicates = append(predicates, post.ExcerptHasPrefix(*i.ExcerptHasPrefix))
	}
	if i.ExcerptHasSuffix != nil {
		predicates = append(predicates, post.ExcerptHasSuffix(*i.ExcerptHasSuffix))
	}
	if i.ExcerptIsNil {
		predicates = append(predicates, post.ExcerptIsNil())
	}
	if i.ExcerptNotNil {
		predicates = append(predicates, post.ExcerptNotNil())
	}
	if i.ExcerptEqualFold != nil {
		predicates = append(predicates, post.ExcerptEqualFold(*i.ExcerptEqualFold))
	}
	if i.ExcerptContainsFold != nil {
		predicates = append(predicates, post.ExcerptContainsFold(*i.ExcerptContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, post.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, post.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, post.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, post.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, post.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, post.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, post.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, post.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, post.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, post.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, post.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, post.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, post.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, post.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, post.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.MetaTitle != nil {
		predicates = append(predicates, post.MetaTitleEQ(*i.MetaTitle))
	}
	if i.MetaTitleNEQ != nil {
		predicates = append(predicates, post.MetaTitleNEQ(*i.MetaTitleNEQ))
	}
	if len(i.MetaTitleIn) > 0 {
		predicates = append(predicates, post.MetaTitleIn(i.MetaTitleIn...))
	}
	if len(i.MetaTitleNotIn) > 0 {
		predicates = append(predicates, post.MetaTitleNotIn(i.MetaTitleNotIn...))
	}
	if i.MetaTitleGT != nil {
		predicates = append(predicates, post.MetaTitleGT(*i.MetaTitleGT))
	}
	if i.MetaTitleGTE != nil {
		predicates = append(predicates, post.MetaTitleGTE(*i.MetaTitleGTE))
	}
	if i.MetaTitleLT != nil {
		predicates = append(predicates, post.MetaTitleLT(*i.MetaTitleLT))
	}
	if i.MetaTitleLTE != nil {
		predicates = append(predicates, post.MetaTitleLTE(*i.MetaTitleLTE))
	}
	if i.MetaTitleContains != nil {
		predicates = append(predicates, post.MetaTitleContains(*i.MetaTitleContains))
	}
	if i.MetaTitleHasPrefix != nil {
		predicates = append(predicates, post.MetaTitleHasPrefix(*i.MetaTitleHasPrefix))
	}
	if i.MetaTitleHasSuffix != nil {
		predicates = append(predicates, post.MetaTitleHasSuffix(*i.MetaTitleHasSuffix))
	}
	if i.MetaTitleIsNil {
		predicates = append(predicates, post.MetaTitleIsNil())
	}
	if i.MetaTitleNotNil {
		predicates = append(predicates, post.MetaTitleNotNil())
	}
	if i.MetaTitleEqualFold != nil {
		predicates = append(predicates, post.MetaTitleEqualFold(*i.MetaTitleEqualFold))
	}
	if i.MetaTitleContainsFold != nil {
		predicates = append(predicates, post.MetaTitleContainsFold(*i.MetaTitleContainsFold))
	}
	if i.MetaDescr != nil {
		predicates = append(predicates, post.MetaDescrEQ(*i.MetaDescr))
	}
	if i.MetaDescrNEQ != nil {
		predicates = append(predicates, post.MetaDescrNEQ(*i.MetaDescrNEQ))
	}
	if len(i.MetaDescrIn) > 0 {
		predicates = append(predicates, post.MetaDescrIn(i.MetaDescrIn...))
	}
	if len(i.MetaDescrNotIn) > 0 {
		predicates = append(predicates, post.MetaDescrNotIn(i.MetaDescrNotIn...))
	}
	if i.MetaDescrGT != nil {
		predicates = append(predicates, post.MetaDescrGT(*i.MetaDescrGT))
	}
	if i.MetaDescrGTE != nil {
		predicates = append(predicates, post.MetaDescrGTE(*i.MetaDescrGTE))
	}
	if i.MetaDescrLT != nil {
		predicates = append(predicates, post.MetaDescrLT(*i.MetaDescrLT))
	}
	if i.MetaDescrLTE != nil {
		predicates = append(predicates, post.MetaDescrLTE(*i.MetaDescrLTE))
	}
	if i.MetaDescrContains != nil {
		predicates = append(predicates, post.MetaDescrContains(*i.MetaDescrContains))
	}
	if i.MetaDescrHasPrefix != nil {
		predicates = append(predicates, post.MetaDescrHasPrefix(*i.MetaDescrHasPrefix))
	}
	if i.MetaDescrHasSuffix != nil {
		predicates = append(predicates, post.MetaDescrHasSuffix(*i.MetaDescrHasSuffix))
	}
	if i.MetaDescrIsNil {
		predicates = append(predicates, post.MetaDescrIsNil())
	}
	if i.MetaDescrNotNil {
		predicates = append(predicates, post.MetaDescrNotNil())
	}
	if i.MetaDescrEqualFold != nil {
		predicates = append(predicates, post.MetaDescrEqualFold(*i.MetaDescrEqualFold))
	}
	if i.MetaDescrContainsFold != nil {
		predicates = append(predicates, post.MetaDescrContainsFold(*i.MetaDescrContainsFold))
	}
	if i.MetaCanonicalURL != nil {
		predicates = append(predicates, post.MetaCanonicalURLEQ(*i.MetaCanonicalURL))
	}
	if i.MetaCanonicalURLNEQ != nil {
		predicates = append(predicates, post.MetaCanonicalURLNEQ(*i.MetaCanonicalURLNEQ))
	}
	if len(i.MetaCanonicalURLIn) > 0 {
		predicates = append(predicates, post.MetaCanonicalURLIn(i.MetaCanonicalURLIn...))
	}
	if len(i.MetaCanonicalURLNotIn) > 0 {
		predicates = append(predicates, post.MetaCanonicalURLNotIn(i.MetaCanonicalURLNotIn...))
	}
	if i.MetaCanonicalURLGT != nil {
		predicates = append(predicates, post.MetaCanonicalURLGT(*i.MetaCanonicalURLGT))
	}
	if i.MetaCanonicalURLGTE != nil {
		predicates = append(predicates, post.MetaCanonicalURLGTE(*i.MetaCanonicalURLGTE))
	}
	if i.MetaCanonicalURLLT != nil {
		predicates = append(predicates, post.MetaCanonicalURLLT(*i.MetaCanonicalURLLT))
	}
	if i.MetaCanonicalURLLTE != nil {
		predicates = append(predicates, post.MetaCanonicalURLLTE(*i.MetaCanonicalURLLTE))
	}
	if i.MetaCanonicalURLContains != nil {
		predicates = append(predicates, post.MetaCanonicalURLContains(*i.MetaCanonicalURLContains))
	}
	if i.MetaCanonicalURLHasPrefix != nil {
		predicates = append(predicates, post.MetaCanonicalURLHasPrefix(*i.MetaCanonicalURLHasPrefix))
	}
	if i.MetaCanonicalURLHasSuffix != nil {
		predicates = append(predicates, post.MetaCanonicalURLHasSuffix(*i.MetaCanonicalURLHasSuffix))
	}
	if i.MetaCanonicalURLIsNil {
		predicates = append(predicates, post.MetaCanonicalURLIsNil())
	}
	if i.MetaCanonicalURLNotNil {
		predicates = append(predicates, post.MetaCanonicalURLNotNil())
	}
	if i.MetaCanonicalURLEqualFold != nil {
		predicates = append(predicates, post.MetaCanonicalURLEqualFold(*i.MetaCanonicalURLEqualFold))
	}
	if i.MetaCanonicalURLContainsFold != nil {
		predicates = append(predicates, post.MetaCanonicalURLContainsFold(*i.MetaCanonicalURLContainsFold))
	}
	if i.MetaRobots != nil {
		predicates = append(predicates, post.MetaRobotsEQ(*i.MetaRobots))
	}
	if i.MetaRobotsNEQ != nil {
		predicates = append(predicates, post.MetaRobotsNEQ(*i.MetaRobotsNEQ))
	}
	if len(i.MetaRobotsIn) > 0 {
		predicates = append(predicates, post.MetaRobotsIn(i.MetaRobotsIn...))
	}
	if len(i.MetaRobotsNotIn) > 0 {
		predicates = append(predicates, post.MetaRobotsNotIn(i.MetaRobotsNotIn...))
	}
	if i.MetaRobotsGT != nil {
		predicates = append(predicates, post.MetaRobotsGT(*i.MetaRobotsGT))
	}
	if i.MetaRobotsGTE != nil {
		predicates = append(predicates, post.MetaRobotsGTE(*i.MetaRobotsGTE))
	}
	if i.MetaRobotsLT != nil {
		predicates = append(predicates, post.MetaRobotsLT(*i.MetaRobotsLT))
	}
	if i.MetaRobotsLTE != nil {
		predicates = append(predicates, post.MetaRobotsLTE(*i.MetaRobotsLTE))
	}
	if i.MetaRobotsContains != nil {
		predicates = append(predicates, post.MetaRobotsContains(*i.MetaRobotsContains))
	}
	if i.MetaRobotsHasPrefix != nil {
		predicates = append(predicates, post.MetaRobotsHasPrefix(*i.MetaRobotsHasPrefix))
	}
	if i.MetaRobotsHasSuffix != nil {
		predicates = append(predicates, post.MetaRobotsHasSuffix(*i.MetaRobotsHasSuffix))
	}
	if i.MetaRobotsIsNil {
		predicates = append(predicates, post.MetaRobotsIsNil())
	}
	if i.MetaRobotsNotNil {
		predicates = append(predicates, post.MetaRobotsNotNil())
	}
	if i.MetaRobotsEqualFold != nil {
		predicates = append(predicates, post.MetaRobotsEqualFold(*i.MetaRobotsEqualFold))
	}
	if i.MetaRobotsContainsFold != nil {
		predicates = append(predicates, post.MetaRobotsContainsFold(*i.MetaRobotsContainsFold))
	}

	if i.HasPostStatus != nil {
		p := post.HasPostStatus()
		if !*i.HasPostStatus {
			p = post.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostStatusWith) > 0 {
		with := make([]predicate.PostStatus, 0, len(i.HasPostStatusWith))
		for _, w := range i.HasPostStatusWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostStatusWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, post.HasPostStatusWith(with...))
	}
	if i.HasPostType != nil {
		p := post.HasPostType()
		if !*i.HasPostType {
			p = post.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostTypeWith) > 0 {
		with := make([]predicate.PostType, 0, len(i.HasPostTypeWith))
		for _, w := range i.HasPostTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, post.HasPostTypeWith(with...))
	}
	if i.HasPrimaryCategory != nil {
		p := post.HasPrimaryCategory()
		if !*i.HasPrimaryCategory {
			p = post.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPrimaryCategoryWith) > 0 {
		with := make([]predicate.PostCategory, 0, len(i.HasPrimaryCategoryWith))
		for _, w := range i.HasPrimaryCategoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPrimaryCategoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, post.HasPrimaryCategoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return post.And(predicates...), nil
	}
}

// PostCategoryWhereInput represents a where input for filtering PostCategory queries.
type PostCategoryWhereInput struct {
	Predicates []predicate.PostCategory  `json:"-"`
	Not        *PostCategoryWhereInput   `json:"not,omitempty"`
	Or         []*PostCategoryWhereInput `json:"or,omitempty"`
	And        []*PostCategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "excerpt" field predicates.
	Excerpt             *string  `json:"excerpt,omitempty"`
	ExcerptNEQ          *string  `json:"excerptNEQ,omitempty"`
	ExcerptIn           []string `json:"excerptIn,omitempty"`
	ExcerptNotIn        []string `json:"excerptNotIn,omitempty"`
	ExcerptGT           *string  `json:"excerptGT,omitempty"`
	ExcerptGTE          *string  `json:"excerptGTE,omitempty"`
	ExcerptLT           *string  `json:"excerptLT,omitempty"`
	ExcerptLTE          *string  `json:"excerptLTE,omitempty"`
	ExcerptContains     *string  `json:"excerptContains,omitempty"`
	ExcerptHasPrefix    *string  `json:"excerptHasPrefix,omitempty"`
	ExcerptHasSuffix    *string  `json:"excerptHasSuffix,omitempty"`
	ExcerptIsNil        bool     `json:"excerptIsNil,omitempty"`
	ExcerptNotNil       bool     `json:"excerptNotNil,omitempty"`
	ExcerptEqualFold    *string  `json:"excerptEqualFold,omitempty"`
	ExcerptContainsFold *string  `json:"excerptContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "meta_title" field predicates.
	MetaTitle             *string  `json:"metaTitle,omitempty"`
	MetaTitleNEQ          *string  `json:"metaTitleNEQ,omitempty"`
	MetaTitleIn           []string `json:"metaTitleIn,omitempty"`
	MetaTitleNotIn        []string `json:"metaTitleNotIn,omitempty"`
	MetaTitleGT           *string  `json:"metaTitleGT,omitempty"`
	MetaTitleGTE          *string  `json:"metaTitleGTE,omitempty"`
	MetaTitleLT           *string  `json:"metaTitleLT,omitempty"`
	MetaTitleLTE          *string  `json:"metaTitleLTE,omitempty"`
	MetaTitleContains     *string  `json:"metaTitleContains,omitempty"`
	MetaTitleHasPrefix    *string  `json:"metaTitleHasPrefix,omitempty"`
	MetaTitleHasSuffix    *string  `json:"metaTitleHasSuffix,omitempty"`
	MetaTitleIsNil        bool     `json:"metaTitleIsNil,omitempty"`
	MetaTitleNotNil       bool     `json:"metaTitleNotNil,omitempty"`
	MetaTitleEqualFold    *string  `json:"metaTitleEqualFold,omitempty"`
	MetaTitleContainsFold *string  `json:"metaTitleContainsFold,omitempty"`

	// "meta_descr" field predicates.
	MetaDescr             *string  `json:"metaDescr,omitempty"`
	MetaDescrNEQ          *string  `json:"metaDescrNEQ,omitempty"`
	MetaDescrIn           []string `json:"metaDescrIn,omitempty"`
	MetaDescrNotIn        []string `json:"metaDescrNotIn,omitempty"`
	MetaDescrGT           *string  `json:"metaDescrGT,omitempty"`
	MetaDescrGTE          *string  `json:"metaDescrGTE,omitempty"`
	MetaDescrLT           *string  `json:"metaDescrLT,omitempty"`
	MetaDescrLTE          *string  `json:"metaDescrLTE,omitempty"`
	MetaDescrContains     *string  `json:"metaDescrContains,omitempty"`
	MetaDescrHasPrefix    *string  `json:"metaDescrHasPrefix,omitempty"`
	MetaDescrHasSuffix    *string  `json:"metaDescrHasSuffix,omitempty"`
	MetaDescrIsNil        bool     `json:"metaDescrIsNil,omitempty"`
	MetaDescrNotNil       bool     `json:"metaDescrNotNil,omitempty"`
	MetaDescrEqualFold    *string  `json:"metaDescrEqualFold,omitempty"`
	MetaDescrContainsFold *string  `json:"metaDescrContainsFold,omitempty"`

	// "meta_canonical_url" field predicates.
	MetaCanonicalURL             *string  `json:"metaCanonicalURL,omitempty"`
	MetaCanonicalURLNEQ          *string  `json:"metaCanonicalURLNEQ,omitempty"`
	MetaCanonicalURLIn           []string `json:"metaCanonicalURLIn,omitempty"`
	MetaCanonicalURLNotIn        []string `json:"metaCanonicalURLNotIn,omitempty"`
	MetaCanonicalURLGT           *string  `json:"metaCanonicalURLGT,omitempty"`
	MetaCanonicalURLGTE          *string  `json:"metaCanonicalURLGTE,omitempty"`
	MetaCanonicalURLLT           *string  `json:"metaCanonicalURLLT,omitempty"`
	MetaCanonicalURLLTE          *string  `json:"metaCanonicalURLLTE,omitempty"`
	MetaCanonicalURLContains     *string  `json:"metaCanonicalURLContains,omitempty"`
	MetaCanonicalURLHasPrefix    *string  `json:"metaCanonicalURLHasPrefix,omitempty"`
	MetaCanonicalURLHasSuffix    *string  `json:"metaCanonicalURLHasSuffix,omitempty"`
	MetaCanonicalURLIsNil        bool     `json:"metaCanonicalURLIsNil,omitempty"`
	MetaCanonicalURLNotNil       bool     `json:"metaCanonicalURLNotNil,omitempty"`
	MetaCanonicalURLEqualFold    *string  `json:"metaCanonicalURLEqualFold,omitempty"`
	MetaCanonicalURLContainsFold *string  `json:"metaCanonicalURLContainsFold,omitempty"`

	// "meta_robots" field predicates.
	MetaRobots             *string  `json:"metaRobots,omitempty"`
	MetaRobotsNEQ          *string  `json:"metaRobotsNEQ,omitempty"`
	MetaRobotsIn           []string `json:"metaRobotsIn,omitempty"`
	MetaRobotsNotIn        []string `json:"metaRobotsNotIn,omitempty"`
	MetaRobotsGT           *string  `json:"metaRobotsGT,omitempty"`
	MetaRobotsGTE          *string  `json:"metaRobotsGTE,omitempty"`
	MetaRobotsLT           *string  `json:"metaRobotsLT,omitempty"`
	MetaRobotsLTE          *string  `json:"metaRobotsLTE,omitempty"`
	MetaRobotsContains     *string  `json:"metaRobotsContains,omitempty"`
	MetaRobotsHasPrefix    *string  `json:"metaRobotsHasPrefix,omitempty"`
	MetaRobotsHasSuffix    *string  `json:"metaRobotsHasSuffix,omitempty"`
	MetaRobotsIsNil        bool     `json:"metaRobotsIsNil,omitempty"`
	MetaRobotsNotNil       bool     `json:"metaRobotsNotNil,omitempty"`
	MetaRobotsEqualFold    *string  `json:"metaRobotsEqualFold,omitempty"`
	MetaRobotsContainsFold *string  `json:"metaRobotsContainsFold,omitempty"`

	// "posts" edge predicates.
	HasPosts     *bool             `json:"hasPosts,omitempty"`
	HasPostsWith []*PostWhereInput `json:"hasPostsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostCategoryWhereInput) AddPredicates(predicates ...predicate.PostCategory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostCategoryWhereInput filter on the PostCategoryQuery builder.
func (i *PostCategoryWhereInput) Filter(q *PostCategoryQuery) (*PostCategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostCategoryWhereInput is returned in case the PostCategoryWhereInput is empty.
var ErrEmptyPostCategoryWhereInput = errors.New("ent: empty predicate PostCategoryWhereInput")

// P returns a predicate for filtering postcategories.
// An error is returned if the input is empty or invalid.
func (i *PostCategoryWhereInput) P() (predicate.PostCategory, error) {
	var predicates []predicate.PostCategory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, postcategory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostCategory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, postcategory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostCategory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, postcategory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, postcategory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, postcategory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, postcategory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, postcategory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, postcategory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, postcategory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, postcategory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, postcategory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, postcategory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, postcategory.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, postcategory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, postcategory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, postcategory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, postcategory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, postcategory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, postcategory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, postcategory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, postcategory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, postcategory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, postcategory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, postcategory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, postcategory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, postcategory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, postcategory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, postcategory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, postcategory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, postcategory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, postcategory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, postcategory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, postcategory.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, postcategory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, postcategory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, postcategory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, postcategory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, postcategory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, postcategory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, postcategory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, postcategory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, postcategory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, postcategory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, postcategory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, postcategory.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, postcategory.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, postcategory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, postcategory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, postcategory.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, postcategory.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, postcategory.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, postcategory.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, postcategory.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, postcategory.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, postcategory.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, postcategory.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, postcategory.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, postcategory.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, postcategory.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, postcategory.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, postcategory.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, postcategory.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, postcategory.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, postcategory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, postcategory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, postcategory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, postcategory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, postcategory.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, postcategory.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, postcategory.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, postcategory.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, postcategory.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, postcategory.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, postcategory.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, postcategory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, postcategory.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, postcategory.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, postcategory.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.Excerpt != nil {
		predicates = append(predicates, postcategory.ExcerptEQ(*i.Excerpt))
	}
	if i.ExcerptNEQ != nil {
		predicates = append(predicates, postcategory.ExcerptNEQ(*i.ExcerptNEQ))
	}
	if len(i.ExcerptIn) > 0 {
		predicates = append(predicates, postcategory.ExcerptIn(i.ExcerptIn...))
	}
	if len(i.ExcerptNotIn) > 0 {
		predicates = append(predicates, postcategory.ExcerptNotIn(i.ExcerptNotIn...))
	}
	if i.ExcerptGT != nil {
		predicates = append(predicates, postcategory.ExcerptGT(*i.ExcerptGT))
	}
	if i.ExcerptGTE != nil {
		predicates = append(predicates, postcategory.ExcerptGTE(*i.ExcerptGTE))
	}
	if i.ExcerptLT != nil {
		predicates = append(predicates, postcategory.ExcerptLT(*i.ExcerptLT))
	}
	if i.ExcerptLTE != nil {
		predicates = append(predicates, postcategory.ExcerptLTE(*i.ExcerptLTE))
	}
	if i.ExcerptContains != nil {
		predicates = append(predicates, postcategory.ExcerptContains(*i.ExcerptContains))
	}
	if i.ExcerptHasPrefix != nil {
		predicates = append(predicates, postcategory.ExcerptHasPrefix(*i.ExcerptHasPrefix))
	}
	if i.ExcerptHasSuffix != nil {
		predicates = append(predicates, postcategory.ExcerptHasSuffix(*i.ExcerptHasSuffix))
	}
	if i.ExcerptIsNil {
		predicates = append(predicates, postcategory.ExcerptIsNil())
	}
	if i.ExcerptNotNil {
		predicates = append(predicates, postcategory.ExcerptNotNil())
	}
	if i.ExcerptEqualFold != nil {
		predicates = append(predicates, postcategory.ExcerptEqualFold(*i.ExcerptEqualFold))
	}
	if i.ExcerptContainsFold != nil {
		predicates = append(predicates, postcategory.ExcerptContainsFold(*i.ExcerptContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, postcategory.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, postcategory.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, postcategory.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, postcategory.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, postcategory.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, postcategory.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, postcategory.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, postcategory.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, postcategory.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, postcategory.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, postcategory.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, postcategory.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, postcategory.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, postcategory.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, postcategory.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.MetaTitle != nil {
		predicates = append(predicates, postcategory.MetaTitleEQ(*i.MetaTitle))
	}
	if i.MetaTitleNEQ != nil {
		predicates = append(predicates, postcategory.MetaTitleNEQ(*i.MetaTitleNEQ))
	}
	if len(i.MetaTitleIn) > 0 {
		predicates = append(predicates, postcategory.MetaTitleIn(i.MetaTitleIn...))
	}
	if len(i.MetaTitleNotIn) > 0 {
		predicates = append(predicates, postcategory.MetaTitleNotIn(i.MetaTitleNotIn...))
	}
	if i.MetaTitleGT != nil {
		predicates = append(predicates, postcategory.MetaTitleGT(*i.MetaTitleGT))
	}
	if i.MetaTitleGTE != nil {
		predicates = append(predicates, postcategory.MetaTitleGTE(*i.MetaTitleGTE))
	}
	if i.MetaTitleLT != nil {
		predicates = append(predicates, postcategory.MetaTitleLT(*i.MetaTitleLT))
	}
	if i.MetaTitleLTE != nil {
		predicates = append(predicates, postcategory.MetaTitleLTE(*i.MetaTitleLTE))
	}
	if i.MetaTitleContains != nil {
		predicates = append(predicates, postcategory.MetaTitleContains(*i.MetaTitleContains))
	}
	if i.MetaTitleHasPrefix != nil {
		predicates = append(predicates, postcategory.MetaTitleHasPrefix(*i.MetaTitleHasPrefix))
	}
	if i.MetaTitleHasSuffix != nil {
		predicates = append(predicates, postcategory.MetaTitleHasSuffix(*i.MetaTitleHasSuffix))
	}
	if i.MetaTitleIsNil {
		predicates = append(predicates, postcategory.MetaTitleIsNil())
	}
	if i.MetaTitleNotNil {
		predicates = append(predicates, postcategory.MetaTitleNotNil())
	}
	if i.MetaTitleEqualFold != nil {
		predicates = append(predicates, postcategory.MetaTitleEqualFold(*i.MetaTitleEqualFold))
	}
	if i.MetaTitleContainsFold != nil {
		predicates = append(predicates, postcategory.MetaTitleContainsFold(*i.MetaTitleContainsFold))
	}
	if i.MetaDescr != nil {
		predicates = append(predicates, postcategory.MetaDescrEQ(*i.MetaDescr))
	}
	if i.MetaDescrNEQ != nil {
		predicates = append(predicates, postcategory.MetaDescrNEQ(*i.MetaDescrNEQ))
	}
	if len(i.MetaDescrIn) > 0 {
		predicates = append(predicates, postcategory.MetaDescrIn(i.MetaDescrIn...))
	}
	if len(i.MetaDescrNotIn) > 0 {
		predicates = append(predicates, postcategory.MetaDescrNotIn(i.MetaDescrNotIn...))
	}
	if i.MetaDescrGT != nil {
		predicates = append(predicates, postcategory.MetaDescrGT(*i.MetaDescrGT))
	}
	if i.MetaDescrGTE != nil {
		predicates = append(predicates, postcategory.MetaDescrGTE(*i.MetaDescrGTE))
	}
	if i.MetaDescrLT != nil {
		predicates = append(predicates, postcategory.MetaDescrLT(*i.MetaDescrLT))
	}
	if i.MetaDescrLTE != nil {
		predicates = append(predicates, postcategory.MetaDescrLTE(*i.MetaDescrLTE))
	}
	if i.MetaDescrContains != nil {
		predicates = append(predicates, postcategory.MetaDescrContains(*i.MetaDescrContains))
	}
	if i.MetaDescrHasPrefix != nil {
		predicates = append(predicates, postcategory.MetaDescrHasPrefix(*i.MetaDescrHasPrefix))
	}
	if i.MetaDescrHasSuffix != nil {
		predicates = append(predicates, postcategory.MetaDescrHasSuffix(*i.MetaDescrHasSuffix))
	}
	if i.MetaDescrIsNil {
		predicates = append(predicates, postcategory.MetaDescrIsNil())
	}
	if i.MetaDescrNotNil {
		predicates = append(predicates, postcategory.MetaDescrNotNil())
	}
	if i.MetaDescrEqualFold != nil {
		predicates = append(predicates, postcategory.MetaDescrEqualFold(*i.MetaDescrEqualFold))
	}
	if i.MetaDescrContainsFold != nil {
		predicates = append(predicates, postcategory.MetaDescrContainsFold(*i.MetaDescrContainsFold))
	}
	if i.MetaCanonicalURL != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLEQ(*i.MetaCanonicalURL))
	}
	if i.MetaCanonicalURLNEQ != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLNEQ(*i.MetaCanonicalURLNEQ))
	}
	if len(i.MetaCanonicalURLIn) > 0 {
		predicates = append(predicates, postcategory.MetaCanonicalURLIn(i.MetaCanonicalURLIn...))
	}
	if len(i.MetaCanonicalURLNotIn) > 0 {
		predicates = append(predicates, postcategory.MetaCanonicalURLNotIn(i.MetaCanonicalURLNotIn...))
	}
	if i.MetaCanonicalURLGT != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLGT(*i.MetaCanonicalURLGT))
	}
	if i.MetaCanonicalURLGTE != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLGTE(*i.MetaCanonicalURLGTE))
	}
	if i.MetaCanonicalURLLT != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLLT(*i.MetaCanonicalURLLT))
	}
	if i.MetaCanonicalURLLTE != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLLTE(*i.MetaCanonicalURLLTE))
	}
	if i.MetaCanonicalURLContains != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLContains(*i.MetaCanonicalURLContains))
	}
	if i.MetaCanonicalURLHasPrefix != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLHasPrefix(*i.MetaCanonicalURLHasPrefix))
	}
	if i.MetaCanonicalURLHasSuffix != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLHasSuffix(*i.MetaCanonicalURLHasSuffix))
	}
	if i.MetaCanonicalURLIsNil {
		predicates = append(predicates, postcategory.MetaCanonicalURLIsNil())
	}
	if i.MetaCanonicalURLNotNil {
		predicates = append(predicates, postcategory.MetaCanonicalURLNotNil())
	}
	if i.MetaCanonicalURLEqualFold != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLEqualFold(*i.MetaCanonicalURLEqualFold))
	}
	if i.MetaCanonicalURLContainsFold != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLContainsFold(*i.MetaCanonicalURLContainsFold))
	}
	if i.MetaRobots != nil {
		predicates = append(predicates, postcategory.MetaRobotsEQ(*i.MetaRobots))
	}
	if i.MetaRobotsNEQ != nil {
		predicates = append(predicates, postcategory.MetaRobotsNEQ(*i.MetaRobotsNEQ))
	}
	if len(i.MetaRobotsIn) > 0 {
		predicates = append(predicates, postcategory.MetaRobotsIn(i.MetaRobotsIn...))
	}
	if len(i.MetaRobotsNotIn) > 0 {
		predicates = append(predicates, postcategory.MetaRobotsNotIn(i.MetaRobotsNotIn...))
	}
	if i.MetaRobotsGT != nil {
		predicates = append(predicates, postcategory.MetaRobotsGT(*i.MetaRobotsGT))
	}
	if i.MetaRobotsGTE != nil {
		predicates = append(predicates, postcategory.MetaRobotsGTE(*i.MetaRobotsGTE))
	}
	if i.MetaRobotsLT != nil {
		predicates = append(predicates, postcategory.MetaRobotsLT(*i.MetaRobotsLT))
	}
	if i.MetaRobotsLTE != nil {
		predicates = append(predicates, postcategory.MetaRobotsLTE(*i.MetaRobotsLTE))
	}
	if i.MetaRobotsContains != nil {
		predicates = append(predicates, postcategory.MetaRobotsContains(*i.MetaRobotsContains))
	}
	if i.MetaRobotsHasPrefix != nil {
		predicates = append(predicates, postcategory.MetaRobotsHasPrefix(*i.MetaRobotsHasPrefix))
	}
	if i.MetaRobotsHasSuffix != nil {
		predicates = append(predicates, postcategory.MetaRobotsHasSuffix(*i.MetaRobotsHasSuffix))
	}
	if i.MetaRobotsIsNil {
		predicates = append(predicates, postcategory.MetaRobotsIsNil())
	}
	if i.MetaRobotsNotNil {
		predicates = append(predicates, postcategory.MetaRobotsNotNil())
	}
	if i.MetaRobotsEqualFold != nil {
		predicates = append(predicates, postcategory.MetaRobotsEqualFold(*i.MetaRobotsEqualFold))
	}
	if i.MetaRobotsContainsFold != nil {
		predicates = append(predicates, postcategory.MetaRobotsContainsFold(*i.MetaRobotsContainsFold))
	}

	if i.HasPosts != nil {
		p := postcategory.HasPosts()
		if !*i.HasPosts {
			p = postcategory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostsWith) > 0 {
		with := make([]predicate.Post, 0, len(i.HasPostsWith))
		for _, w := range i.HasPostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, postcategory.HasPostsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return postcategory.And(predicates...), nil
	}
}

// PostStatusWhereInput represents a where input for filtering PostStatus queries.
type PostStatusWhereInput struct {
	Predicates []predicate.PostStatus  `json:"-"`
	Not        *PostStatusWhereInput   `json:"not,omitempty"`
	Or         []*PostStatusWhereInput `json:"or,omitempty"`
	And        []*PostStatusWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status       *bool `json:"status,omitempty"`
	StatusNEQ    *bool `json:"statusNEQ,omitempty"`
	StatusIsNil  bool  `json:"statusIsNil,omitempty"`
	StatusNotNil bool  `json:"statusNotNil,omitempty"`

	// "post_type_id" field predicates.
	PostTypeID             *string  `json:"postTypeID,omitempty"`
	PostTypeIDNEQ          *string  `json:"postTypeIDNEQ,omitempty"`
	PostTypeIDIn           []string `json:"postTypeIDIn,omitempty"`
	PostTypeIDNotIn        []string `json:"postTypeIDNotIn,omitempty"`
	PostTypeIDGT           *string  `json:"postTypeIDGT,omitempty"`
	PostTypeIDGTE          *string  `json:"postTypeIDGTE,omitempty"`
	PostTypeIDLT           *string  `json:"postTypeIDLT,omitempty"`
	PostTypeIDLTE          *string  `json:"postTypeIDLTE,omitempty"`
	PostTypeIDContains     *string  `json:"postTypeIDContains,omitempty"`
	PostTypeIDHasPrefix    *string  `json:"postTypeIDHasPrefix,omitempty"`
	PostTypeIDHasSuffix    *string  `json:"postTypeIDHasSuffix,omitempty"`
	PostTypeIDIsNil        bool     `json:"postTypeIDIsNil,omitempty"`
	PostTypeIDNotNil       bool     `json:"postTypeIDNotNil,omitempty"`
	PostTypeIDEqualFold    *string  `json:"postTypeIDEqualFold,omitempty"`
	PostTypeIDContainsFold *string  `json:"postTypeIDContainsFold,omitempty"`

	// "post_type" edge predicates.
	HasPostType     *bool                 `json:"hasPostType,omitempty"`
	HasPostTypeWith []*PostTypeWhereInput `json:"hasPostTypeWith,omitempty"`

	// "posts" edge predicates.
	HasPosts     *bool             `json:"hasPosts,omitempty"`
	HasPostsWith []*PostWhereInput `json:"hasPostsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostStatusWhereInput) AddPredicates(predicates ...predicate.PostStatus) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostStatusWhereInput filter on the PostStatusQuery builder.
func (i *PostStatusWhereInput) Filter(q *PostStatusQuery) (*PostStatusQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostStatusWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostStatusWhereInput is returned in case the PostStatusWhereInput is empty.
var ErrEmptyPostStatusWhereInput = errors.New("ent: empty predicate PostStatusWhereInput")

// P returns a predicate for filtering poststatusslice.
// An error is returned if the input is empty or invalid.
func (i *PostStatusWhereInput) P() (predicate.PostStatus, error) {
	var predicates []predicate.PostStatus
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, poststatus.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostStatus, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, poststatus.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostStatus, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, poststatus.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, poststatus.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, poststatus.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, poststatus.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, poststatus.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, poststatus.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, poststatus.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, poststatus.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, poststatus.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, poststatus.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, poststatus.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, poststatus.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, poststatus.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, poststatus.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, poststatus.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, poststatus.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, poststatus.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, poststatus.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, poststatus.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, poststatus.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, poststatus.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, poststatus.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, poststatus.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, poststatus.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, poststatus.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, poststatus.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, poststatus.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, poststatus.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, poststatus.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, poststatus.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, poststatus.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, poststatus.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, poststatus.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, poststatus.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, poststatus.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, poststatus.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, poststatus.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, poststatus.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, poststatus.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, poststatus.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, poststatus.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, poststatus.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, poststatus.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, poststatus.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, poststatus.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, poststatus.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, poststatus.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, poststatus.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, poststatus.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, poststatus.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, poststatus.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, poststatus.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, poststatus.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, poststatus.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, poststatus.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, poststatus.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, poststatus.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, poststatus.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, poststatus.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, poststatus.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, poststatus.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, poststatus.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, poststatus.StatusNEQ(*i.StatusNEQ))
	}
	if i.StatusIsNil {
		predicates = append(predicates, poststatus.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, poststatus.StatusNotNil())
	}
	if i.PostTypeID != nil {
		predicates = append(predicates, poststatus.PostTypeIDEQ(*i.PostTypeID))
	}
	if i.PostTypeIDNEQ != nil {
		predicates = append(predicates, poststatus.PostTypeIDNEQ(*i.PostTypeIDNEQ))
	}
	if len(i.PostTypeIDIn) > 0 {
		predicates = append(predicates, poststatus.PostTypeIDIn(i.PostTypeIDIn...))
	}
	if len(i.PostTypeIDNotIn) > 0 {
		predicates = append(predicates, poststatus.PostTypeIDNotIn(i.PostTypeIDNotIn...))
	}
	if i.PostTypeIDGT != nil {
		predicates = append(predicates, poststatus.PostTypeIDGT(*i.PostTypeIDGT))
	}
	if i.PostTypeIDGTE != nil {
		predicates = append(predicates, poststatus.PostTypeIDGTE(*i.PostTypeIDGTE))
	}
	if i.PostTypeIDLT != nil {
		predicates = append(predicates, poststatus.PostTypeIDLT(*i.PostTypeIDLT))
	}
	if i.PostTypeIDLTE != nil {
		predicates = append(predicates, poststatus.PostTypeIDLTE(*i.PostTypeIDLTE))
	}
	if i.PostTypeIDContains != nil {
		predicates = append(predicates, poststatus.PostTypeIDContains(*i.PostTypeIDContains))
	}
	if i.PostTypeIDHasPrefix != nil {
		predicates = append(predicates, poststatus.PostTypeIDHasPrefix(*i.PostTypeIDHasPrefix))
	}
	if i.PostTypeIDHasSuffix != nil {
		predicates = append(predicates, poststatus.PostTypeIDHasSuffix(*i.PostTypeIDHasSuffix))
	}
	if i.PostTypeIDIsNil {
		predicates = append(predicates, poststatus.PostTypeIDIsNil())
	}
	if i.PostTypeIDNotNil {
		predicates = append(predicates, poststatus.PostTypeIDNotNil())
	}
	if i.PostTypeIDEqualFold != nil {
		predicates = append(predicates, poststatus.PostTypeIDEqualFold(*i.PostTypeIDEqualFold))
	}
	if i.PostTypeIDContainsFold != nil {
		predicates = append(predicates, poststatus.PostTypeIDContainsFold(*i.PostTypeIDContainsFold))
	}

	if i.HasPostType != nil {
		p := poststatus.HasPostType()
		if !*i.HasPostType {
			p = poststatus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostTypeWith) > 0 {
		with := make([]predicate.PostType, 0, len(i.HasPostTypeWith))
		for _, w := range i.HasPostTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, poststatus.HasPostTypeWith(with...))
	}
	if i.HasPosts != nil {
		p := poststatus.HasPosts()
		if !*i.HasPosts {
			p = poststatus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostsWith) > 0 {
		with := make([]predicate.Post, 0, len(i.HasPostsWith))
		for _, w := range i.HasPostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, poststatus.HasPostsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostStatusWhereInput
	case 1:
		return predicates[0], nil
	default:
		return poststatus.And(predicates...), nil
	}
}

// PostTagWhereInput represents a where input for filtering PostTag queries.
type PostTagWhereInput struct {
	Predicates []predicate.PostTag  `json:"-"`
	Not        *PostTagWhereInput   `json:"not,omitempty"`
	Or         []*PostTagWhereInput `json:"or,omitempty"`
	And        []*PostTagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "excerpt" field predicates.
	Excerpt             *string  `json:"excerpt,omitempty"`
	ExcerptNEQ          *string  `json:"excerptNEQ,omitempty"`
	ExcerptIn           []string `json:"excerptIn,omitempty"`
	ExcerptNotIn        []string `json:"excerptNotIn,omitempty"`
	ExcerptGT           *string  `json:"excerptGT,omitempty"`
	ExcerptGTE          *string  `json:"excerptGTE,omitempty"`
	ExcerptLT           *string  `json:"excerptLT,omitempty"`
	ExcerptLTE          *string  `json:"excerptLTE,omitempty"`
	ExcerptContains     *string  `json:"excerptContains,omitempty"`
	ExcerptHasPrefix    *string  `json:"excerptHasPrefix,omitempty"`
	ExcerptHasSuffix    *string  `json:"excerptHasSuffix,omitempty"`
	ExcerptIsNil        bool     `json:"excerptIsNil,omitempty"`
	ExcerptNotNil       bool     `json:"excerptNotNil,omitempty"`
	ExcerptEqualFold    *string  `json:"excerptEqualFold,omitempty"`
	ExcerptContainsFold *string  `json:"excerptContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "meta_title" field predicates.
	MetaTitle             *string  `json:"metaTitle,omitempty"`
	MetaTitleNEQ          *string  `json:"metaTitleNEQ,omitempty"`
	MetaTitleIn           []string `json:"metaTitleIn,omitempty"`
	MetaTitleNotIn        []string `json:"metaTitleNotIn,omitempty"`
	MetaTitleGT           *string  `json:"metaTitleGT,omitempty"`
	MetaTitleGTE          *string  `json:"metaTitleGTE,omitempty"`
	MetaTitleLT           *string  `json:"metaTitleLT,omitempty"`
	MetaTitleLTE          *string  `json:"metaTitleLTE,omitempty"`
	MetaTitleContains     *string  `json:"metaTitleContains,omitempty"`
	MetaTitleHasPrefix    *string  `json:"metaTitleHasPrefix,omitempty"`
	MetaTitleHasSuffix    *string  `json:"metaTitleHasSuffix,omitempty"`
	MetaTitleIsNil        bool     `json:"metaTitleIsNil,omitempty"`
	MetaTitleNotNil       bool     `json:"metaTitleNotNil,omitempty"`
	MetaTitleEqualFold    *string  `json:"metaTitleEqualFold,omitempty"`
	MetaTitleContainsFold *string  `json:"metaTitleContainsFold,omitempty"`

	// "meta_descr" field predicates.
	MetaDescr             *string  `json:"metaDescr,omitempty"`
	MetaDescrNEQ          *string  `json:"metaDescrNEQ,omitempty"`
	MetaDescrIn           []string `json:"metaDescrIn,omitempty"`
	MetaDescrNotIn        []string `json:"metaDescrNotIn,omitempty"`
	MetaDescrGT           *string  `json:"metaDescrGT,omitempty"`
	MetaDescrGTE          *string  `json:"metaDescrGTE,omitempty"`
	MetaDescrLT           *string  `json:"metaDescrLT,omitempty"`
	MetaDescrLTE          *string  `json:"metaDescrLTE,omitempty"`
	MetaDescrContains     *string  `json:"metaDescrContains,omitempty"`
	MetaDescrHasPrefix    *string  `json:"metaDescrHasPrefix,omitempty"`
	MetaDescrHasSuffix    *string  `json:"metaDescrHasSuffix,omitempty"`
	MetaDescrIsNil        bool     `json:"metaDescrIsNil,omitempty"`
	MetaDescrNotNil       bool     `json:"metaDescrNotNil,omitempty"`
	MetaDescrEqualFold    *string  `json:"metaDescrEqualFold,omitempty"`
	MetaDescrContainsFold *string  `json:"metaDescrContainsFold,omitempty"`

	// "meta_canonical_url" field predicates.
	MetaCanonicalURL             *string  `json:"metaCanonicalURL,omitempty"`
	MetaCanonicalURLNEQ          *string  `json:"metaCanonicalURLNEQ,omitempty"`
	MetaCanonicalURLIn           []string `json:"metaCanonicalURLIn,omitempty"`
	MetaCanonicalURLNotIn        []string `json:"metaCanonicalURLNotIn,omitempty"`
	MetaCanonicalURLGT           *string  `json:"metaCanonicalURLGT,omitempty"`
	MetaCanonicalURLGTE          *string  `json:"metaCanonicalURLGTE,omitempty"`
	MetaCanonicalURLLT           *string  `json:"metaCanonicalURLLT,omitempty"`
	MetaCanonicalURLLTE          *string  `json:"metaCanonicalURLLTE,omitempty"`
	MetaCanonicalURLContains     *string  `json:"metaCanonicalURLContains,omitempty"`
	MetaCanonicalURLHasPrefix    *string  `json:"metaCanonicalURLHasPrefix,omitempty"`
	MetaCanonicalURLHasSuffix    *string  `json:"metaCanonicalURLHasSuffix,omitempty"`
	MetaCanonicalURLIsNil        bool     `json:"metaCanonicalURLIsNil,omitempty"`
	MetaCanonicalURLNotNil       bool     `json:"metaCanonicalURLNotNil,omitempty"`
	MetaCanonicalURLEqualFold    *string  `json:"metaCanonicalURLEqualFold,omitempty"`
	MetaCanonicalURLContainsFold *string  `json:"metaCanonicalURLContainsFold,omitempty"`

	// "meta_robots" field predicates.
	MetaRobots             *string  `json:"metaRobots,omitempty"`
	MetaRobotsNEQ          *string  `json:"metaRobotsNEQ,omitempty"`
	MetaRobotsIn           []string `json:"metaRobotsIn,omitempty"`
	MetaRobotsNotIn        []string `json:"metaRobotsNotIn,omitempty"`
	MetaRobotsGT           *string  `json:"metaRobotsGT,omitempty"`
	MetaRobotsGTE          *string  `json:"metaRobotsGTE,omitempty"`
	MetaRobotsLT           *string  `json:"metaRobotsLT,omitempty"`
	MetaRobotsLTE          *string  `json:"metaRobotsLTE,omitempty"`
	MetaRobotsContains     *string  `json:"metaRobotsContains,omitempty"`
	MetaRobotsHasPrefix    *string  `json:"metaRobotsHasPrefix,omitempty"`
	MetaRobotsHasSuffix    *string  `json:"metaRobotsHasSuffix,omitempty"`
	MetaRobotsIsNil        bool     `json:"metaRobotsIsNil,omitempty"`
	MetaRobotsNotNil       bool     `json:"metaRobotsNotNil,omitempty"`
	MetaRobotsEqualFold    *string  `json:"metaRobotsEqualFold,omitempty"`
	MetaRobotsContainsFold *string  `json:"metaRobotsContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostTagWhereInput) AddPredicates(predicates ...predicate.PostTag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostTagWhereInput filter on the PostTagQuery builder.
func (i *PostTagWhereInput) Filter(q *PostTagQuery) (*PostTagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostTagWhereInput is returned in case the PostTagWhereInput is empty.
var ErrEmptyPostTagWhereInput = errors.New("ent: empty predicate PostTagWhereInput")

// P returns a predicate for filtering posttags.
// An error is returned if the input is empty or invalid.
func (i *PostTagWhereInput) P() (predicate.PostTag, error) {
	var predicates []predicate.PostTag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, posttag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostTag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, posttag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostTag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, posttag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, posttag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, posttag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, posttag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, posttag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, posttag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, posttag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, posttag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, posttag.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, posttag.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, posttag.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, posttag.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, posttag.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, posttag.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, posttag.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, posttag.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, posttag.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, posttag.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, posttag.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, posttag.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, posttag.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, posttag.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, posttag.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, posttag.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, posttag.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, posttag.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, posttag.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, posttag.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, posttag.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, posttag.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, posttag.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, posttag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, posttag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, posttag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, posttag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, posttag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, posttag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, posttag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, posttag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, posttag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, posttag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, posttag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, posttag.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, posttag.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, posttag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, posttag.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, posttag.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, posttag.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, posttag.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, posttag.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, posttag.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, posttag.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, posttag.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, posttag.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, posttag.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, posttag.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, posttag.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, posttag.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, posttag.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, posttag.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, posttag.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, posttag.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, posttag.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, posttag.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, posttag.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, posttag.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, posttag.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, posttag.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, posttag.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, posttag.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, posttag.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, posttag.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, posttag.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, posttag.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, posttag.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, posttag.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.Excerpt != nil {
		predicates = append(predicates, posttag.ExcerptEQ(*i.Excerpt))
	}
	if i.ExcerptNEQ != nil {
		predicates = append(predicates, posttag.ExcerptNEQ(*i.ExcerptNEQ))
	}
	if len(i.ExcerptIn) > 0 {
		predicates = append(predicates, posttag.ExcerptIn(i.ExcerptIn...))
	}
	if len(i.ExcerptNotIn) > 0 {
		predicates = append(predicates, posttag.ExcerptNotIn(i.ExcerptNotIn...))
	}
	if i.ExcerptGT != nil {
		predicates = append(predicates, posttag.ExcerptGT(*i.ExcerptGT))
	}
	if i.ExcerptGTE != nil {
		predicates = append(predicates, posttag.ExcerptGTE(*i.ExcerptGTE))
	}
	if i.ExcerptLT != nil {
		predicates = append(predicates, posttag.ExcerptLT(*i.ExcerptLT))
	}
	if i.ExcerptLTE != nil {
		predicates = append(predicates, posttag.ExcerptLTE(*i.ExcerptLTE))
	}
	if i.ExcerptContains != nil {
		predicates = append(predicates, posttag.ExcerptContains(*i.ExcerptContains))
	}
	if i.ExcerptHasPrefix != nil {
		predicates = append(predicates, posttag.ExcerptHasPrefix(*i.ExcerptHasPrefix))
	}
	if i.ExcerptHasSuffix != nil {
		predicates = append(predicates, posttag.ExcerptHasSuffix(*i.ExcerptHasSuffix))
	}
	if i.ExcerptIsNil {
		predicates = append(predicates, posttag.ExcerptIsNil())
	}
	if i.ExcerptNotNil {
		predicates = append(predicates, posttag.ExcerptNotNil())
	}
	if i.ExcerptEqualFold != nil {
		predicates = append(predicates, posttag.ExcerptEqualFold(*i.ExcerptEqualFold))
	}
	if i.ExcerptContainsFold != nil {
		predicates = append(predicates, posttag.ExcerptContainsFold(*i.ExcerptContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, posttag.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, posttag.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, posttag.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, posttag.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, posttag.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, posttag.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, posttag.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, posttag.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, posttag.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, posttag.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, posttag.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, posttag.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, posttag.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, posttag.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, posttag.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.MetaTitle != nil {
		predicates = append(predicates, posttag.MetaTitleEQ(*i.MetaTitle))
	}
	if i.MetaTitleNEQ != nil {
		predicates = append(predicates, posttag.MetaTitleNEQ(*i.MetaTitleNEQ))
	}
	if len(i.MetaTitleIn) > 0 {
		predicates = append(predicates, posttag.MetaTitleIn(i.MetaTitleIn...))
	}
	if len(i.MetaTitleNotIn) > 0 {
		predicates = append(predicates, posttag.MetaTitleNotIn(i.MetaTitleNotIn...))
	}
	if i.MetaTitleGT != nil {
		predicates = append(predicates, posttag.MetaTitleGT(*i.MetaTitleGT))
	}
	if i.MetaTitleGTE != nil {
		predicates = append(predicates, posttag.MetaTitleGTE(*i.MetaTitleGTE))
	}
	if i.MetaTitleLT != nil {
		predicates = append(predicates, posttag.MetaTitleLT(*i.MetaTitleLT))
	}
	if i.MetaTitleLTE != nil {
		predicates = append(predicates, posttag.MetaTitleLTE(*i.MetaTitleLTE))
	}
	if i.MetaTitleContains != nil {
		predicates = append(predicates, posttag.MetaTitleContains(*i.MetaTitleContains))
	}
	if i.MetaTitleHasPrefix != nil {
		predicates = append(predicates, posttag.MetaTitleHasPrefix(*i.MetaTitleHasPrefix))
	}
	if i.MetaTitleHasSuffix != nil {
		predicates = append(predicates, posttag.MetaTitleHasSuffix(*i.MetaTitleHasSuffix))
	}
	if i.MetaTitleIsNil {
		predicates = append(predicates, posttag.MetaTitleIsNil())
	}
	if i.MetaTitleNotNil {
		predicates = append(predicates, posttag.MetaTitleNotNil())
	}
	if i.MetaTitleEqualFold != nil {
		predicates = append(predicates, posttag.MetaTitleEqualFold(*i.MetaTitleEqualFold))
	}
	if i.MetaTitleContainsFold != nil {
		predicates = append(predicates, posttag.MetaTitleContainsFold(*i.MetaTitleContainsFold))
	}
	if i.MetaDescr != nil {
		predicates = append(predicates, posttag.MetaDescrEQ(*i.MetaDescr))
	}
	if i.MetaDescrNEQ != nil {
		predicates = append(predicates, posttag.MetaDescrNEQ(*i.MetaDescrNEQ))
	}
	if len(i.MetaDescrIn) > 0 {
		predicates = append(predicates, posttag.MetaDescrIn(i.MetaDescrIn...))
	}
	if len(i.MetaDescrNotIn) > 0 {
		predicates = append(predicates, posttag.MetaDescrNotIn(i.MetaDescrNotIn...))
	}
	if i.MetaDescrGT != nil {
		predicates = append(predicates, posttag.MetaDescrGT(*i.MetaDescrGT))
	}
	if i.MetaDescrGTE != nil {
		predicates = append(predicates, posttag.MetaDescrGTE(*i.MetaDescrGTE))
	}
	if i.MetaDescrLT != nil {
		predicates = append(predicates, posttag.MetaDescrLT(*i.MetaDescrLT))
	}
	if i.MetaDescrLTE != nil {
		predicates = append(predicates, posttag.MetaDescrLTE(*i.MetaDescrLTE))
	}
	if i.MetaDescrContains != nil {
		predicates = append(predicates, posttag.MetaDescrContains(*i.MetaDescrContains))
	}
	if i.MetaDescrHasPrefix != nil {
		predicates = append(predicates, posttag.MetaDescrHasPrefix(*i.MetaDescrHasPrefix))
	}
	if i.MetaDescrHasSuffix != nil {
		predicates = append(predicates, posttag.MetaDescrHasSuffix(*i.MetaDescrHasSuffix))
	}
	if i.MetaDescrIsNil {
		predicates = append(predicates, posttag.MetaDescrIsNil())
	}
	if i.MetaDescrNotNil {
		predicates = append(predicates, posttag.MetaDescrNotNil())
	}
	if i.MetaDescrEqualFold != nil {
		predicates = append(predicates, posttag.MetaDescrEqualFold(*i.MetaDescrEqualFold))
	}
	if i.MetaDescrContainsFold != nil {
		predicates = append(predicates, posttag.MetaDescrContainsFold(*i.MetaDescrContainsFold))
	}
	if i.MetaCanonicalURL != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLEQ(*i.MetaCanonicalURL))
	}
	if i.MetaCanonicalURLNEQ != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLNEQ(*i.MetaCanonicalURLNEQ))
	}
	if len(i.MetaCanonicalURLIn) > 0 {
		predicates = append(predicates, posttag.MetaCanonicalURLIn(i.MetaCanonicalURLIn...))
	}
	if len(i.MetaCanonicalURLNotIn) > 0 {
		predicates = append(predicates, posttag.MetaCanonicalURLNotIn(i.MetaCanonicalURLNotIn...))
	}
	if i.MetaCanonicalURLGT != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLGT(*i.MetaCanonicalURLGT))
	}
	if i.MetaCanonicalURLGTE != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLGTE(*i.MetaCanonicalURLGTE))
	}
	if i.MetaCanonicalURLLT != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLLT(*i.MetaCanonicalURLLT))
	}
	if i.MetaCanonicalURLLTE != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLLTE(*i.MetaCanonicalURLLTE))
	}
	if i.MetaCanonicalURLContains != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLContains(*i.MetaCanonicalURLContains))
	}
	if i.MetaCanonicalURLHasPrefix != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLHasPrefix(*i.MetaCanonicalURLHasPrefix))
	}
	if i.MetaCanonicalURLHasSuffix != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLHasSuffix(*i.MetaCanonicalURLHasSuffix))
	}
	if i.MetaCanonicalURLIsNil {
		predicates = append(predicates, posttag.MetaCanonicalURLIsNil())
	}
	if i.MetaCanonicalURLNotNil {
		predicates = append(predicates, posttag.MetaCanonicalURLNotNil())
	}
	if i.MetaCanonicalURLEqualFold != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLEqualFold(*i.MetaCanonicalURLEqualFold))
	}
	if i.MetaCanonicalURLContainsFold != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLContainsFold(*i.MetaCanonicalURLContainsFold))
	}
	if i.MetaRobots != nil {
		predicates = append(predicates, posttag.MetaRobotsEQ(*i.MetaRobots))
	}
	if i.MetaRobotsNEQ != nil {
		predicates = append(predicates, posttag.MetaRobotsNEQ(*i.MetaRobotsNEQ))
	}
	if len(i.MetaRobotsIn) > 0 {
		predicates = append(predicates, posttag.MetaRobotsIn(i.MetaRobotsIn...))
	}
	if len(i.MetaRobotsNotIn) > 0 {
		predicates = append(predicates, posttag.MetaRobotsNotIn(i.MetaRobotsNotIn...))
	}
	if i.MetaRobotsGT != nil {
		predicates = append(predicates, posttag.MetaRobotsGT(*i.MetaRobotsGT))
	}
	if i.MetaRobotsGTE != nil {
		predicates = append(predicates, posttag.MetaRobotsGTE(*i.MetaRobotsGTE))
	}
	if i.MetaRobotsLT != nil {
		predicates = append(predicates, posttag.MetaRobotsLT(*i.MetaRobotsLT))
	}
	if i.MetaRobotsLTE != nil {
		predicates = append(predicates, posttag.MetaRobotsLTE(*i.MetaRobotsLTE))
	}
	if i.MetaRobotsContains != nil {
		predicates = append(predicates, posttag.MetaRobotsContains(*i.MetaRobotsContains))
	}
	if i.MetaRobotsHasPrefix != nil {
		predicates = append(predicates, posttag.MetaRobotsHasPrefix(*i.MetaRobotsHasPrefix))
	}
	if i.MetaRobotsHasSuffix != nil {
		predicates = append(predicates, posttag.MetaRobotsHasSuffix(*i.MetaRobotsHasSuffix))
	}
	if i.MetaRobotsIsNil {
		predicates = append(predicates, posttag.MetaRobotsIsNil())
	}
	if i.MetaRobotsNotNil {
		predicates = append(predicates, posttag.MetaRobotsNotNil())
	}
	if i.MetaRobotsEqualFold != nil {
		predicates = append(predicates, posttag.MetaRobotsEqualFold(*i.MetaRobotsEqualFold))
	}
	if i.MetaRobotsContainsFold != nil {
		predicates = append(predicates, posttag.MetaRobotsContainsFold(*i.MetaRobotsContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return posttag.And(predicates...), nil
	}
}

// PostTypeWhereInput represents a where input for filtering PostType queries.
type PostTypeWhereInput struct {
	Predicates []predicate.PostType  `json:"-"`
	Not        *PostTypeWhereInput   `json:"not,omitempty"`
	Or         []*PostTypeWhereInput `json:"or,omitempty"`
	And        []*PostTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status      *posttype.Status  `json:"status,omitempty"`
	StatusNEQ   *posttype.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []posttype.Status `json:"statusIn,omitempty"`
	StatusNotIn []posttype.Status `json:"statusNotIn,omitempty"`

	// "excerpt" field predicates.
	Excerpt             *string  `json:"excerpt,omitempty"`
	ExcerptNEQ          *string  `json:"excerptNEQ,omitempty"`
	ExcerptIn           []string `json:"excerptIn,omitempty"`
	ExcerptNotIn        []string `json:"excerptNotIn,omitempty"`
	ExcerptGT           *string  `json:"excerptGT,omitempty"`
	ExcerptGTE          *string  `json:"excerptGTE,omitempty"`
	ExcerptLT           *string  `json:"excerptLT,omitempty"`
	ExcerptLTE          *string  `json:"excerptLTE,omitempty"`
	ExcerptContains     *string  `json:"excerptContains,omitempty"`
	ExcerptHasPrefix    *string  `json:"excerptHasPrefix,omitempty"`
	ExcerptHasSuffix    *string  `json:"excerptHasSuffix,omitempty"`
	ExcerptIsNil        bool     `json:"excerptIsNil,omitempty"`
	ExcerptNotNil       bool     `json:"excerptNotNil,omitempty"`
	ExcerptEqualFold    *string  `json:"excerptEqualFold,omitempty"`
	ExcerptContainsFold *string  `json:"excerptContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "meta_title" field predicates.
	MetaTitle             *string  `json:"metaTitle,omitempty"`
	MetaTitleNEQ          *string  `json:"metaTitleNEQ,omitempty"`
	MetaTitleIn           []string `json:"metaTitleIn,omitempty"`
	MetaTitleNotIn        []string `json:"metaTitleNotIn,omitempty"`
	MetaTitleGT           *string  `json:"metaTitleGT,omitempty"`
	MetaTitleGTE          *string  `json:"metaTitleGTE,omitempty"`
	MetaTitleLT           *string  `json:"metaTitleLT,omitempty"`
	MetaTitleLTE          *string  `json:"metaTitleLTE,omitempty"`
	MetaTitleContains     *string  `json:"metaTitleContains,omitempty"`
	MetaTitleHasPrefix    *string  `json:"metaTitleHasPrefix,omitempty"`
	MetaTitleHasSuffix    *string  `json:"metaTitleHasSuffix,omitempty"`
	MetaTitleIsNil        bool     `json:"metaTitleIsNil,omitempty"`
	MetaTitleNotNil       bool     `json:"metaTitleNotNil,omitempty"`
	MetaTitleEqualFold    *string  `json:"metaTitleEqualFold,omitempty"`
	MetaTitleContainsFold *string  `json:"metaTitleContainsFold,omitempty"`

	// "meta_descr" field predicates.
	MetaDescr             *string  `json:"metaDescr,omitempty"`
	MetaDescrNEQ          *string  `json:"metaDescrNEQ,omitempty"`
	MetaDescrIn           []string `json:"metaDescrIn,omitempty"`
	MetaDescrNotIn        []string `json:"metaDescrNotIn,omitempty"`
	MetaDescrGT           *string  `json:"metaDescrGT,omitempty"`
	MetaDescrGTE          *string  `json:"metaDescrGTE,omitempty"`
	MetaDescrLT           *string  `json:"metaDescrLT,omitempty"`
	MetaDescrLTE          *string  `json:"metaDescrLTE,omitempty"`
	MetaDescrContains     *string  `json:"metaDescrContains,omitempty"`
	MetaDescrHasPrefix    *string  `json:"metaDescrHasPrefix,omitempty"`
	MetaDescrHasSuffix    *string  `json:"metaDescrHasSuffix,omitempty"`
	MetaDescrIsNil        bool     `json:"metaDescrIsNil,omitempty"`
	MetaDescrNotNil       bool     `json:"metaDescrNotNil,omitempty"`
	MetaDescrEqualFold    *string  `json:"metaDescrEqualFold,omitempty"`
	MetaDescrContainsFold *string  `json:"metaDescrContainsFold,omitempty"`

	// "meta_canonical_url" field predicates.
	MetaCanonicalURL             *string  `json:"metaCanonicalURL,omitempty"`
	MetaCanonicalURLNEQ          *string  `json:"metaCanonicalURLNEQ,omitempty"`
	MetaCanonicalURLIn           []string `json:"metaCanonicalURLIn,omitempty"`
	MetaCanonicalURLNotIn        []string `json:"metaCanonicalURLNotIn,omitempty"`
	MetaCanonicalURLGT           *string  `json:"metaCanonicalURLGT,omitempty"`
	MetaCanonicalURLGTE          *string  `json:"metaCanonicalURLGTE,omitempty"`
	MetaCanonicalURLLT           *string  `json:"metaCanonicalURLLT,omitempty"`
	MetaCanonicalURLLTE          *string  `json:"metaCanonicalURLLTE,omitempty"`
	MetaCanonicalURLContains     *string  `json:"metaCanonicalURLContains,omitempty"`
	MetaCanonicalURLHasPrefix    *string  `json:"metaCanonicalURLHasPrefix,omitempty"`
	MetaCanonicalURLHasSuffix    *string  `json:"metaCanonicalURLHasSuffix,omitempty"`
	MetaCanonicalURLIsNil        bool     `json:"metaCanonicalURLIsNil,omitempty"`
	MetaCanonicalURLNotNil       bool     `json:"metaCanonicalURLNotNil,omitempty"`
	MetaCanonicalURLEqualFold    *string  `json:"metaCanonicalURLEqualFold,omitempty"`
	MetaCanonicalURLContainsFold *string  `json:"metaCanonicalURLContainsFold,omitempty"`

	// "meta_robots" field predicates.
	MetaRobots             *string  `json:"metaRobots,omitempty"`
	MetaRobotsNEQ          *string  `json:"metaRobotsNEQ,omitempty"`
	MetaRobotsIn           []string `json:"metaRobotsIn,omitempty"`
	MetaRobotsNotIn        []string `json:"metaRobotsNotIn,omitempty"`
	MetaRobotsGT           *string  `json:"metaRobotsGT,omitempty"`
	MetaRobotsGTE          *string  `json:"metaRobotsGTE,omitempty"`
	MetaRobotsLT           *string  `json:"metaRobotsLT,omitempty"`
	MetaRobotsLTE          *string  `json:"metaRobotsLTE,omitempty"`
	MetaRobotsContains     *string  `json:"metaRobotsContains,omitempty"`
	MetaRobotsHasPrefix    *string  `json:"metaRobotsHasPrefix,omitempty"`
	MetaRobotsHasSuffix    *string  `json:"metaRobotsHasSuffix,omitempty"`
	MetaRobotsIsNil        bool     `json:"metaRobotsIsNil,omitempty"`
	MetaRobotsNotNil       bool     `json:"metaRobotsNotNil,omitempty"`
	MetaRobotsEqualFold    *string  `json:"metaRobotsEqualFold,omitempty"`
	MetaRobotsContainsFold *string  `json:"metaRobotsContainsFold,omitempty"`

	// "posts" edge predicates.
	HasPosts     *bool             `json:"hasPosts,omitempty"`
	HasPostsWith []*PostWhereInput `json:"hasPostsWith,omitempty"`

	// "post_statuses" edge predicates.
	HasPostStatuses     *bool                   `json:"hasPostStatuses,omitempty"`
	HasPostStatusesWith []*PostStatusWhereInput `json:"hasPostStatusesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostTypeWhereInput) AddPredicates(predicates ...predicate.PostType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostTypeWhereInput filter on the PostTypeQuery builder.
func (i *PostTypeWhereInput) Filter(q *PostTypeQuery) (*PostTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostTypeWhereInput is returned in case the PostTypeWhereInput is empty.
var ErrEmptyPostTypeWhereInput = errors.New("ent: empty predicate PostTypeWhereInput")

// P returns a predicate for filtering posttypes.
// An error is returned if the input is empty or invalid.
func (i *PostTypeWhereInput) P() (predicate.PostType, error) {
	var predicates []predicate.PostType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, posttype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, posttype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, posttype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, posttype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, posttype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, posttype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, posttype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, posttype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, posttype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, posttype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, posttype.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, posttype.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, posttype.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, posttype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, posttype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, posttype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, posttype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, posttype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, posttype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, posttype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, posttype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, posttype.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, posttype.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, posttype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, posttype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, posttype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, posttype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, posttype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, posttype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, posttype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, posttype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, posttype.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, posttype.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, posttype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, posttype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, posttype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, posttype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, posttype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, posttype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, posttype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, posttype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, posttype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, posttype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, posttype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, posttype.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, posttype.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, posttype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, posttype.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, posttype.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, posttype.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, posttype.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, posttype.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, posttype.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, posttype.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, posttype.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, posttype.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, posttype.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, posttype.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, posttype.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, posttype.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, posttype.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, posttype.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, posttype.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, posttype.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, posttype.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, posttype.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, posttype.StatusNotIn(i.StatusNotIn...))
	}
	if i.Excerpt != nil {
		predicates = append(predicates, posttype.ExcerptEQ(*i.Excerpt))
	}
	if i.ExcerptNEQ != nil {
		predicates = append(predicates, posttype.ExcerptNEQ(*i.ExcerptNEQ))
	}
	if len(i.ExcerptIn) > 0 {
		predicates = append(predicates, posttype.ExcerptIn(i.ExcerptIn...))
	}
	if len(i.ExcerptNotIn) > 0 {
		predicates = append(predicates, posttype.ExcerptNotIn(i.ExcerptNotIn...))
	}
	if i.ExcerptGT != nil {
		predicates = append(predicates, posttype.ExcerptGT(*i.ExcerptGT))
	}
	if i.ExcerptGTE != nil {
		predicates = append(predicates, posttype.ExcerptGTE(*i.ExcerptGTE))
	}
	if i.ExcerptLT != nil {
		predicates = append(predicates, posttype.ExcerptLT(*i.ExcerptLT))
	}
	if i.ExcerptLTE != nil {
		predicates = append(predicates, posttype.ExcerptLTE(*i.ExcerptLTE))
	}
	if i.ExcerptContains != nil {
		predicates = append(predicates, posttype.ExcerptContains(*i.ExcerptContains))
	}
	if i.ExcerptHasPrefix != nil {
		predicates = append(predicates, posttype.ExcerptHasPrefix(*i.ExcerptHasPrefix))
	}
	if i.ExcerptHasSuffix != nil {
		predicates = append(predicates, posttype.ExcerptHasSuffix(*i.ExcerptHasSuffix))
	}
	if i.ExcerptIsNil {
		predicates = append(predicates, posttype.ExcerptIsNil())
	}
	if i.ExcerptNotNil {
		predicates = append(predicates, posttype.ExcerptNotNil())
	}
	if i.ExcerptEqualFold != nil {
		predicates = append(predicates, posttype.ExcerptEqualFold(*i.ExcerptEqualFold))
	}
	if i.ExcerptContainsFold != nil {
		predicates = append(predicates, posttype.ExcerptContainsFold(*i.ExcerptContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, posttype.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, posttype.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, posttype.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, posttype.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, posttype.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, posttype.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, posttype.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, posttype.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, posttype.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, posttype.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, posttype.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, posttype.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, posttype.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, posttype.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, posttype.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.MetaTitle != nil {
		predicates = append(predicates, posttype.MetaTitleEQ(*i.MetaTitle))
	}
	if i.MetaTitleNEQ != nil {
		predicates = append(predicates, posttype.MetaTitleNEQ(*i.MetaTitleNEQ))
	}
	if len(i.MetaTitleIn) > 0 {
		predicates = append(predicates, posttype.MetaTitleIn(i.MetaTitleIn...))
	}
	if len(i.MetaTitleNotIn) > 0 {
		predicates = append(predicates, posttype.MetaTitleNotIn(i.MetaTitleNotIn...))
	}
	if i.MetaTitleGT != nil {
		predicates = append(predicates, posttype.MetaTitleGT(*i.MetaTitleGT))
	}
	if i.MetaTitleGTE != nil {
		predicates = append(predicates, posttype.MetaTitleGTE(*i.MetaTitleGTE))
	}
	if i.MetaTitleLT != nil {
		predicates = append(predicates, posttype.MetaTitleLT(*i.MetaTitleLT))
	}
	if i.MetaTitleLTE != nil {
		predicates = append(predicates, posttype.MetaTitleLTE(*i.MetaTitleLTE))
	}
	if i.MetaTitleContains != nil {
		predicates = append(predicates, posttype.MetaTitleContains(*i.MetaTitleContains))
	}
	if i.MetaTitleHasPrefix != nil {
		predicates = append(predicates, posttype.MetaTitleHasPrefix(*i.MetaTitleHasPrefix))
	}
	if i.MetaTitleHasSuffix != nil {
		predicates = append(predicates, posttype.MetaTitleHasSuffix(*i.MetaTitleHasSuffix))
	}
	if i.MetaTitleIsNil {
		predicates = append(predicates, posttype.MetaTitleIsNil())
	}
	if i.MetaTitleNotNil {
		predicates = append(predicates, posttype.MetaTitleNotNil())
	}
	if i.MetaTitleEqualFold != nil {
		predicates = append(predicates, posttype.MetaTitleEqualFold(*i.MetaTitleEqualFold))
	}
	if i.MetaTitleContainsFold != nil {
		predicates = append(predicates, posttype.MetaTitleContainsFold(*i.MetaTitleContainsFold))
	}
	if i.MetaDescr != nil {
		predicates = append(predicates, posttype.MetaDescrEQ(*i.MetaDescr))
	}
	if i.MetaDescrNEQ != nil {
		predicates = append(predicates, posttype.MetaDescrNEQ(*i.MetaDescrNEQ))
	}
	if len(i.MetaDescrIn) > 0 {
		predicates = append(predicates, posttype.MetaDescrIn(i.MetaDescrIn...))
	}
	if len(i.MetaDescrNotIn) > 0 {
		predicates = append(predicates, posttype.MetaDescrNotIn(i.MetaDescrNotIn...))
	}
	if i.MetaDescrGT != nil {
		predicates = append(predicates, posttype.MetaDescrGT(*i.MetaDescrGT))
	}
	if i.MetaDescrGTE != nil {
		predicates = append(predicates, posttype.MetaDescrGTE(*i.MetaDescrGTE))
	}
	if i.MetaDescrLT != nil {
		predicates = append(predicates, posttype.MetaDescrLT(*i.MetaDescrLT))
	}
	if i.MetaDescrLTE != nil {
		predicates = append(predicates, posttype.MetaDescrLTE(*i.MetaDescrLTE))
	}
	if i.MetaDescrContains != nil {
		predicates = append(predicates, posttype.MetaDescrContains(*i.MetaDescrContains))
	}
	if i.MetaDescrHasPrefix != nil {
		predicates = append(predicates, posttype.MetaDescrHasPrefix(*i.MetaDescrHasPrefix))
	}
	if i.MetaDescrHasSuffix != nil {
		predicates = append(predicates, posttype.MetaDescrHasSuffix(*i.MetaDescrHasSuffix))
	}
	if i.MetaDescrIsNil {
		predicates = append(predicates, posttype.MetaDescrIsNil())
	}
	if i.MetaDescrNotNil {
		predicates = append(predicates, posttype.MetaDescrNotNil())
	}
	if i.MetaDescrEqualFold != nil {
		predicates = append(predicates, posttype.MetaDescrEqualFold(*i.MetaDescrEqualFold))
	}
	if i.MetaDescrContainsFold != nil {
		predicates = append(predicates, posttype.MetaDescrContainsFold(*i.MetaDescrContainsFold))
	}
	if i.MetaCanonicalURL != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLEQ(*i.MetaCanonicalURL))
	}
	if i.MetaCanonicalURLNEQ != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLNEQ(*i.MetaCanonicalURLNEQ))
	}
	if len(i.MetaCanonicalURLIn) > 0 {
		predicates = append(predicates, posttype.MetaCanonicalURLIn(i.MetaCanonicalURLIn...))
	}
	if len(i.MetaCanonicalURLNotIn) > 0 {
		predicates = append(predicates, posttype.MetaCanonicalURLNotIn(i.MetaCanonicalURLNotIn...))
	}
	if i.MetaCanonicalURLGT != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLGT(*i.MetaCanonicalURLGT))
	}
	if i.MetaCanonicalURLGTE != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLGTE(*i.MetaCanonicalURLGTE))
	}
	if i.MetaCanonicalURLLT != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLLT(*i.MetaCanonicalURLLT))
	}
	if i.MetaCanonicalURLLTE != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLLTE(*i.MetaCanonicalURLLTE))
	}
	if i.MetaCanonicalURLContains != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLContains(*i.MetaCanonicalURLContains))
	}
	if i.MetaCanonicalURLHasPrefix != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLHasPrefix(*i.MetaCanonicalURLHasPrefix))
	}
	if i.MetaCanonicalURLHasSuffix != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLHasSuffix(*i.MetaCanonicalURLHasSuffix))
	}
	if i.MetaCanonicalURLIsNil {
		predicates = append(predicates, posttype.MetaCanonicalURLIsNil())
	}
	if i.MetaCanonicalURLNotNil {
		predicates = append(predicates, posttype.MetaCanonicalURLNotNil())
	}
	if i.MetaCanonicalURLEqualFold != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLEqualFold(*i.MetaCanonicalURLEqualFold))
	}
	if i.MetaCanonicalURLContainsFold != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLContainsFold(*i.MetaCanonicalURLContainsFold))
	}
	if i.MetaRobots != nil {
		predicates = append(predicates, posttype.MetaRobotsEQ(*i.MetaRobots))
	}
	if i.MetaRobotsNEQ != nil {
		predicates = append(predicates, posttype.MetaRobotsNEQ(*i.MetaRobotsNEQ))
	}
	if len(i.MetaRobotsIn) > 0 {
		predicates = append(predicates, posttype.MetaRobotsIn(i.MetaRobotsIn...))
	}
	if len(i.MetaRobotsNotIn) > 0 {
		predicates = append(predicates, posttype.MetaRobotsNotIn(i.MetaRobotsNotIn...))
	}
	if i.MetaRobotsGT != nil {
		predicates = append(predicates, posttype.MetaRobotsGT(*i.MetaRobotsGT))
	}
	if i.MetaRobotsGTE != nil {
		predicates = append(predicates, posttype.MetaRobotsGTE(*i.MetaRobotsGTE))
	}
	if i.MetaRobotsLT != nil {
		predicates = append(predicates, posttype.MetaRobotsLT(*i.MetaRobotsLT))
	}
	if i.MetaRobotsLTE != nil {
		predicates = append(predicates, posttype.MetaRobotsLTE(*i.MetaRobotsLTE))
	}
	if i.MetaRobotsContains != nil {
		predicates = append(predicates, posttype.MetaRobotsContains(*i.MetaRobotsContains))
	}
	if i.MetaRobotsHasPrefix != nil {
		predicates = append(predicates, posttype.MetaRobotsHasPrefix(*i.MetaRobotsHasPrefix))
	}
	if i.MetaRobotsHasSuffix != nil {
		predicates = append(predicates, posttype.MetaRobotsHasSuffix(*i.MetaRobotsHasSuffix))
	}
	if i.MetaRobotsIsNil {
		predicates = append(predicates, posttype.MetaRobotsIsNil())
	}
	if i.MetaRobotsNotNil {
		predicates = append(predicates, posttype.MetaRobotsNotNil())
	}
	if i.MetaRobotsEqualFold != nil {
		predicates = append(predicates, posttype.MetaRobotsEqualFold(*i.MetaRobotsEqualFold))
	}
	if i.MetaRobotsContainsFold != nil {
		predicates = append(predicates, posttype.MetaRobotsContainsFold(*i.MetaRobotsContainsFold))
	}

	if i.HasPosts != nil {
		p := posttype.HasPosts()
		if !*i.HasPosts {
			p = posttype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostsWith) > 0 {
		with := make([]predicate.Post, 0, len(i.HasPostsWith))
		for _, w := range i.HasPostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, posttype.HasPostsWith(with...))
	}
	if i.HasPostStatuses != nil {
		p := posttype.HasPostStatuses()
		if !*i.HasPostStatuses {
			p = posttype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostStatusesWith) > 0 {
		with := make([]predicate.PostStatus, 0, len(i.HasPostStatusesWith))
		for _, w := range i.HasPostStatusesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostStatusesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, posttype.HasPostStatusesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return posttype.And(predicates...), nil
	}
}

// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Predicates []predicate.Todo  `json:"-"`
	Not        *TodoWhereInput   `json:"not,omitempty"`
	Or         []*TodoWhereInput `json:"or,omitempty"`
	And        []*TodoWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "text" field predicates.
	Text             *string  `json:"text,omitempty"`
	TextNEQ          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGT           *string  `json:"textGT,omitempty"`
	TextGTE          *string  `json:"textGTE,omitempty"`
	TextLT           *string  `json:"textLT,omitempty"`
	TextLTE          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`

	// "status" field predicates.
	Status      *todo.Status  `json:"status,omitempty"`
	StatusNEQ   *todo.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []todo.Status `json:"statusIn,omitempty"`
	StatusNotIn []todo.Status `json:"statusNotIn,omitempty"`

	// "priority" field predicates.
	Priority      *int  `json:"priority,omitempty"`
	PriorityNEQ   *int  `json:"priorityNEQ,omitempty"`
	PriorityIn    []int `json:"priorityIn,omitempty"`
	PriorityNotIn []int `json:"priorityNotIn,omitempty"`
	PriorityGT    *int  `json:"priorityGT,omitempty"`
	PriorityGTE   *int  `json:"priorityGTE,omitempty"`
	PriorityLT    *int  `json:"priorityLT,omitempty"`
	PriorityLTE   *int  `json:"priorityLTE,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool             `json:"hasChildren,omitempty"`
	HasChildrenWith []*TodoWhereInput `json:"hasChildrenWith,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool             `json:"hasParent,omitempty"`
	HasParentWith []*TodoWhereInput `json:"hasParentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TodoWhereInput) AddPredicates(predicates ...predicate.Todo) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TodoWhereInput filter on the TodoQuery builder.
func (i *TodoWhereInput) Filter(q *TodoQuery) (*TodoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTodoWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTodoWhereInput is returned in case the TodoWhereInput is empty.
var ErrEmptyTodoWhereInput = errors.New("ent: empty predicate TodoWhereInput")

// P returns a predicate for filtering todos.
// An error is returned if the input is empty or invalid.
func (i *TodoWhereInput) P() (predicate.Todo, error) {
	var predicates []predicate.Todo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, todo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Todo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, todo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Todo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, todo.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, todo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, todo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, todo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, todo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, todo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, todo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, todo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, todo.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, todo.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, todo.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, todo.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, todo.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, todo.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, todo.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, todo.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, todo.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, todo.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, todo.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, todo.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, todo.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, todo.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, todo.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, todo.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, todo.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, todo.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, todo.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, todo.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, todo.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, todo.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, todo.UpdatedAtNotNil())
	}
	if i.Text != nil {
		predicates = append(predicates, todo.TextEQ(*i.Text))
	}
	if i.TextNEQ != nil {
		predicates = append(predicates, todo.TextNEQ(*i.TextNEQ))
	}
	if len(i.TextIn) > 0 {
		predicates = append(predicates, todo.TextIn(i.TextIn...))
	}
	if len(i.TextNotIn) > 0 {
		predicates = append(predicates, todo.TextNotIn(i.TextNotIn...))
	}
	if i.TextGT != nil {
		predicates = append(predicates, todo.TextGT(*i.TextGT))
	}
	if i.TextGTE != nil {
		predicates = append(predicates, todo.TextGTE(*i.TextGTE))
	}
	if i.TextLT != nil {
		predicates = append(predicates, todo.TextLT(*i.TextLT))
	}
	if i.TextLTE != nil {
		predicates = append(predicates, todo.TextLTE(*i.TextLTE))
	}
	if i.TextContains != nil {
		predicates = append(predicates, todo.TextContains(*i.TextContains))
	}
	if i.TextHasPrefix != nil {
		predicates = append(predicates, todo.TextHasPrefix(*i.TextHasPrefix))
	}
	if i.TextHasSuffix != nil {
		predicates = append(predicates, todo.TextHasSuffix(*i.TextHasSuffix))
	}
	if i.TextEqualFold != nil {
		predicates = append(predicates, todo.TextEqualFold(*i.TextEqualFold))
	}
	if i.TextContainsFold != nil {
		predicates = append(predicates, todo.TextContainsFold(*i.TextContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, todo.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, todo.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, todo.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, todo.StatusNotIn(i.StatusNotIn...))
	}
	if i.Priority != nil {
		predicates = append(predicates, todo.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, todo.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, todo.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, todo.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityGT != nil {
		predicates = append(predicates, todo.PriorityGT(*i.PriorityGT))
	}
	if i.PriorityGTE != nil {
		predicates = append(predicates, todo.PriorityGTE(*i.PriorityGTE))
	}
	if i.PriorityLT != nil {
		predicates = append(predicates, todo.PriorityLT(*i.PriorityLT))
	}
	if i.PriorityLTE != nil {
		predicates = append(predicates, todo.PriorityLTE(*i.PriorityLTE))
	}

	if i.HasChildren != nil {
		p := todo.HasChildren()
		if !*i.HasChildren {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasChildrenWith(with...))
	}
	if i.HasParent != nil {
		p := todo.HasParent()
		if !*i.HasParent {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasParentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTodoWhereInput
	case 1:
		return predicates[0], nil
	default:
		return todo.And(predicates...), nil
	}
}
