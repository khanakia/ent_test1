// Code generated by ent, DO NOT EDIT.

package ent

import (
	"errors"
	"fmt"
	"saas/gen/ent/oauthconnection"
	"saas/gen/ent/post"
	"saas/gen/ent/postcategory"
	"saas/gen/ent/poststatus"
	"saas/gen/ent/posttag"
	"saas/gen/ent/posttype"
	"saas/gen/ent/predicate"
	"saas/gen/ent/todo"
	"saas/gen/ent/user"
	"saas/gen/ent/workspace"
	"saas/gen/ent/workspaceinvite"
	"saas/gen/ent/workspaceuser"
	"time"
)

// OauthConnectionWhereInput represents a where input for filtering OauthConnection queries.
type OauthConnectionWhereInput struct {
	Predicates []predicate.OauthConnection  `json:"-"`
	Not        *OauthConnectionWhereInput   `json:"not,omitempty"`
	Or         []*OauthConnectionWhereInput `json:"or,omitempty"`
	And        []*OauthConnectionWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "provider" field predicates.
	Provider             *string  `json:"provider,omitempty"`
	ProviderNEQ          *string  `json:"providerNEQ,omitempty"`
	ProviderIn           []string `json:"providerIn,omitempty"`
	ProviderNotIn        []string `json:"providerNotIn,omitempty"`
	ProviderGT           *string  `json:"providerGT,omitempty"`
	ProviderGTE          *string  `json:"providerGTE,omitempty"`
	ProviderLT           *string  `json:"providerLT,omitempty"`
	ProviderLTE          *string  `json:"providerLTE,omitempty"`
	ProviderContains     *string  `json:"providerContains,omitempty"`
	ProviderHasPrefix    *string  `json:"providerHasPrefix,omitempty"`
	ProviderHasSuffix    *string  `json:"providerHasSuffix,omitempty"`
	ProviderIsNil        bool     `json:"providerIsNil,omitempty"`
	ProviderNotNil       bool     `json:"providerNotNil,omitempty"`
	ProviderEqualFold    *string  `json:"providerEqualFold,omitempty"`
	ProviderContainsFold *string  `json:"providerContainsFold,omitempty"`

	// "client_id" field predicates.
	ClientID             *string  `json:"clientID,omitempty"`
	ClientIDNEQ          *string  `json:"clientIDNEQ,omitempty"`
	ClientIDIn           []string `json:"clientIDIn,omitempty"`
	ClientIDNotIn        []string `json:"clientIDNotIn,omitempty"`
	ClientIDGT           *string  `json:"clientIDGT,omitempty"`
	ClientIDGTE          *string  `json:"clientIDGTE,omitempty"`
	ClientIDLT           *string  `json:"clientIDLT,omitempty"`
	ClientIDLTE          *string  `json:"clientIDLTE,omitempty"`
	ClientIDContains     *string  `json:"clientIDContains,omitempty"`
	ClientIDHasPrefix    *string  `json:"clientIDHasPrefix,omitempty"`
	ClientIDHasSuffix    *string  `json:"clientIDHasSuffix,omitempty"`
	ClientIDIsNil        bool     `json:"clientIDIsNil,omitempty"`
	ClientIDNotNil       bool     `json:"clientIDNotNil,omitempty"`
	ClientIDEqualFold    *string  `json:"clientIDEqualFold,omitempty"`
	ClientIDContainsFold *string  `json:"clientIDContainsFold,omitempty"`

	// "client_secret" field predicates.
	ClientSecret             *string  `json:"clientSecret,omitempty"`
	ClientSecretNEQ          *string  `json:"clientSecretNEQ,omitempty"`
	ClientSecretIn           []string `json:"clientSecretIn,omitempty"`
	ClientSecretNotIn        []string `json:"clientSecretNotIn,omitempty"`
	ClientSecretGT           *string  `json:"clientSecretGT,omitempty"`
	ClientSecretGTE          *string  `json:"clientSecretGTE,omitempty"`
	ClientSecretLT           *string  `json:"clientSecretLT,omitempty"`
	ClientSecretLTE          *string  `json:"clientSecretLTE,omitempty"`
	ClientSecretContains     *string  `json:"clientSecretContains,omitempty"`
	ClientSecretHasPrefix    *string  `json:"clientSecretHasPrefix,omitempty"`
	ClientSecretHasSuffix    *string  `json:"clientSecretHasSuffix,omitempty"`
	ClientSecretIsNil        bool     `json:"clientSecretIsNil,omitempty"`
	ClientSecretNotNil       bool     `json:"clientSecretNotNil,omitempty"`
	ClientSecretEqualFold    *string  `json:"clientSecretEqualFold,omitempty"`
	ClientSecretContainsFold *string  `json:"clientSecretContainsFold,omitempty"`

	// "scopes" field predicates.
	Scopes             *string  `json:"scopes,omitempty"`
	ScopesNEQ          *string  `json:"scopesNEQ,omitempty"`
	ScopesIn           []string `json:"scopesIn,omitempty"`
	ScopesNotIn        []string `json:"scopesNotIn,omitempty"`
	ScopesGT           *string  `json:"scopesGT,omitempty"`
	ScopesGTE          *string  `json:"scopesGTE,omitempty"`
	ScopesLT           *string  `json:"scopesLT,omitempty"`
	ScopesLTE          *string  `json:"scopesLTE,omitempty"`
	ScopesContains     *string  `json:"scopesContains,omitempty"`
	ScopesHasPrefix    *string  `json:"scopesHasPrefix,omitempty"`
	ScopesHasSuffix    *string  `json:"scopesHasSuffix,omitempty"`
	ScopesIsNil        bool     `json:"scopesIsNil,omitempty"`
	ScopesNotNil       bool     `json:"scopesNotNil,omitempty"`
	ScopesEqualFold    *string  `json:"scopesEqualFold,omitempty"`
	ScopesContainsFold *string  `json:"scopesContainsFold,omitempty"`

	// "redirect_url" field predicates.
	RedirectURL             *string  `json:"redirectURL,omitempty"`
	RedirectURLNEQ          *string  `json:"redirectURLNEQ,omitempty"`
	RedirectURLIn           []string `json:"redirectURLIn,omitempty"`
	RedirectURLNotIn        []string `json:"redirectURLNotIn,omitempty"`
	RedirectURLGT           *string  `json:"redirectURLGT,omitempty"`
	RedirectURLGTE          *string  `json:"redirectURLGTE,omitempty"`
	RedirectURLLT           *string  `json:"redirectURLLT,omitempty"`
	RedirectURLLTE          *string  `json:"redirectURLLTE,omitempty"`
	RedirectURLContains     *string  `json:"redirectURLContains,omitempty"`
	RedirectURLHasPrefix    *string  `json:"redirectURLHasPrefix,omitempty"`
	RedirectURLHasSuffix    *string  `json:"redirectURLHasSuffix,omitempty"`
	RedirectURLIsNil        bool     `json:"redirectURLIsNil,omitempty"`
	RedirectURLNotNil       bool     `json:"redirectURLNotNil,omitempty"`
	RedirectURLEqualFold    *string  `json:"redirectURLEqualFold,omitempty"`
	RedirectURLContainsFold *string  `json:"redirectURLContainsFold,omitempty"`

	// "dashboard_link" field predicates.
	DashboardLink             *string  `json:"dashboardLink,omitempty"`
	DashboardLinkNEQ          *string  `json:"dashboardLinkNEQ,omitempty"`
	DashboardLinkIn           []string `json:"dashboardLinkIn,omitempty"`
	DashboardLinkNotIn        []string `json:"dashboardLinkNotIn,omitempty"`
	DashboardLinkGT           *string  `json:"dashboardLinkGT,omitempty"`
	DashboardLinkGTE          *string  `json:"dashboardLinkGTE,omitempty"`
	DashboardLinkLT           *string  `json:"dashboardLinkLT,omitempty"`
	DashboardLinkLTE          *string  `json:"dashboardLinkLTE,omitempty"`
	DashboardLinkContains     *string  `json:"dashboardLinkContains,omitempty"`
	DashboardLinkHasPrefix    *string  `json:"dashboardLinkHasPrefix,omitempty"`
	DashboardLinkHasSuffix    *string  `json:"dashboardLinkHasSuffix,omitempty"`
	DashboardLinkIsNil        bool     `json:"dashboardLinkIsNil,omitempty"`
	DashboardLinkNotNil       bool     `json:"dashboardLinkNotNil,omitempty"`
	DashboardLinkEqualFold    *string  `json:"dashboardLinkEqualFold,omitempty"`
	DashboardLinkContainsFold *string  `json:"dashboardLinkContainsFold,omitempty"`

	// "note" field predicates.
	Note             *string  `json:"note,omitempty"`
	NoteNEQ          *string  `json:"noteNEQ,omitempty"`
	NoteIn           []string `json:"noteIn,omitempty"`
	NoteNotIn        []string `json:"noteNotIn,omitempty"`
	NoteGT           *string  `json:"noteGT,omitempty"`
	NoteGTE          *string  `json:"noteGTE,omitempty"`
	NoteLT           *string  `json:"noteLT,omitempty"`
	NoteLTE          *string  `json:"noteLTE,omitempty"`
	NoteContains     *string  `json:"noteContains,omitempty"`
	NoteHasPrefix    *string  `json:"noteHasPrefix,omitempty"`
	NoteHasSuffix    *string  `json:"noteHasSuffix,omitempty"`
	NoteIsNil        bool     `json:"noteIsNil,omitempty"`
	NoteNotNil       bool     `json:"noteNotNil,omitempty"`
	NoteEqualFold    *string  `json:"noteEqualFold,omitempty"`
	NoteContainsFold *string  `json:"noteContainsFold,omitempty"`

	// "status" field predicates.
	Status       *bool `json:"status,omitempty"`
	StatusNEQ    *bool `json:"statusNEQ,omitempty"`
	StatusIsNil  bool  `json:"statusIsNil,omitempty"`
	StatusNotNil bool  `json:"statusNotNil,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *OauthConnectionWhereInput) AddPredicates(predicates ...predicate.OauthConnection) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the OauthConnectionWhereInput filter on the OauthConnectionQuery builder.
func (i *OauthConnectionWhereInput) Filter(q *OauthConnectionQuery) (*OauthConnectionQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyOauthConnectionWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyOauthConnectionWhereInput is returned in case the OauthConnectionWhereInput is empty.
var ErrEmptyOauthConnectionWhereInput = errors.New("ent: empty predicate OauthConnectionWhereInput")

// P returns a predicate for filtering oauthconnections.
// An error is returned if the input is empty or invalid.
func (i *OauthConnectionWhereInput) P() (predicate.OauthConnection, error) {
	var predicates []predicate.OauthConnection
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, oauthconnection.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.OauthConnection, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, oauthconnection.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.OauthConnection, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, oauthconnection.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, oauthconnection.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, oauthconnection.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, oauthconnection.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, oauthconnection.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, oauthconnection.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, oauthconnection.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, oauthconnection.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, oauthconnection.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, oauthconnection.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, oauthconnection.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, oauthconnection.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, oauthconnection.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, oauthconnection.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, oauthconnection.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, oauthconnection.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, oauthconnection.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, oauthconnection.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, oauthconnection.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, oauthconnection.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, oauthconnection.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, oauthconnection.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, oauthconnection.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, oauthconnection.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, oauthconnection.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, oauthconnection.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, oauthconnection.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, oauthconnection.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, oauthconnection.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, oauthconnection.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, oauthconnection.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, oauthconnection.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, oauthconnection.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, oauthconnection.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, oauthconnection.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, oauthconnection.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, oauthconnection.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, oauthconnection.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, oauthconnection.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, oauthconnection.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, oauthconnection.NameContainsFold(*i.NameContainsFold))
	}
	if i.Provider != nil {
		predicates = append(predicates, oauthconnection.ProviderEQ(*i.Provider))
	}
	if i.ProviderNEQ != nil {
		predicates = append(predicates, oauthconnection.ProviderNEQ(*i.ProviderNEQ))
	}
	if len(i.ProviderIn) > 0 {
		predicates = append(predicates, oauthconnection.ProviderIn(i.ProviderIn...))
	}
	if len(i.ProviderNotIn) > 0 {
		predicates = append(predicates, oauthconnection.ProviderNotIn(i.ProviderNotIn...))
	}
	if i.ProviderGT != nil {
		predicates = append(predicates, oauthconnection.ProviderGT(*i.ProviderGT))
	}
	if i.ProviderGTE != nil {
		predicates = append(predicates, oauthconnection.ProviderGTE(*i.ProviderGTE))
	}
	if i.ProviderLT != nil {
		predicates = append(predicates, oauthconnection.ProviderLT(*i.ProviderLT))
	}
	if i.ProviderLTE != nil {
		predicates = append(predicates, oauthconnection.ProviderLTE(*i.ProviderLTE))
	}
	if i.ProviderContains != nil {
		predicates = append(predicates, oauthconnection.ProviderContains(*i.ProviderContains))
	}
	if i.ProviderHasPrefix != nil {
		predicates = append(predicates, oauthconnection.ProviderHasPrefix(*i.ProviderHasPrefix))
	}
	if i.ProviderHasSuffix != nil {
		predicates = append(predicates, oauthconnection.ProviderHasSuffix(*i.ProviderHasSuffix))
	}
	if i.ProviderIsNil {
		predicates = append(predicates, oauthconnection.ProviderIsNil())
	}
	if i.ProviderNotNil {
		predicates = append(predicates, oauthconnection.ProviderNotNil())
	}
	if i.ProviderEqualFold != nil {
		predicates = append(predicates, oauthconnection.ProviderEqualFold(*i.ProviderEqualFold))
	}
	if i.ProviderContainsFold != nil {
		predicates = append(predicates, oauthconnection.ProviderContainsFold(*i.ProviderContainsFold))
	}
	if i.ClientID != nil {
		predicates = append(predicates, oauthconnection.ClientIDEQ(*i.ClientID))
	}
	if i.ClientIDNEQ != nil {
		predicates = append(predicates, oauthconnection.ClientIDNEQ(*i.ClientIDNEQ))
	}
	if len(i.ClientIDIn) > 0 {
		predicates = append(predicates, oauthconnection.ClientIDIn(i.ClientIDIn...))
	}
	if len(i.ClientIDNotIn) > 0 {
		predicates = append(predicates, oauthconnection.ClientIDNotIn(i.ClientIDNotIn...))
	}
	if i.ClientIDGT != nil {
		predicates = append(predicates, oauthconnection.ClientIDGT(*i.ClientIDGT))
	}
	if i.ClientIDGTE != nil {
		predicates = append(predicates, oauthconnection.ClientIDGTE(*i.ClientIDGTE))
	}
	if i.ClientIDLT != nil {
		predicates = append(predicates, oauthconnection.ClientIDLT(*i.ClientIDLT))
	}
	if i.ClientIDLTE != nil {
		predicates = append(predicates, oauthconnection.ClientIDLTE(*i.ClientIDLTE))
	}
	if i.ClientIDContains != nil {
		predicates = append(predicates, oauthconnection.ClientIDContains(*i.ClientIDContains))
	}
	if i.ClientIDHasPrefix != nil {
		predicates = append(predicates, oauthconnection.ClientIDHasPrefix(*i.ClientIDHasPrefix))
	}
	if i.ClientIDHasSuffix != nil {
		predicates = append(predicates, oauthconnection.ClientIDHasSuffix(*i.ClientIDHasSuffix))
	}
	if i.ClientIDIsNil {
		predicates = append(predicates, oauthconnection.ClientIDIsNil())
	}
	if i.ClientIDNotNil {
		predicates = append(predicates, oauthconnection.ClientIDNotNil())
	}
	if i.ClientIDEqualFold != nil {
		predicates = append(predicates, oauthconnection.ClientIDEqualFold(*i.ClientIDEqualFold))
	}
	if i.ClientIDContainsFold != nil {
		predicates = append(predicates, oauthconnection.ClientIDContainsFold(*i.ClientIDContainsFold))
	}
	if i.ClientSecret != nil {
		predicates = append(predicates, oauthconnection.ClientSecretEQ(*i.ClientSecret))
	}
	if i.ClientSecretNEQ != nil {
		predicates = append(predicates, oauthconnection.ClientSecretNEQ(*i.ClientSecretNEQ))
	}
	if len(i.ClientSecretIn) > 0 {
		predicates = append(predicates, oauthconnection.ClientSecretIn(i.ClientSecretIn...))
	}
	if len(i.ClientSecretNotIn) > 0 {
		predicates = append(predicates, oauthconnection.ClientSecretNotIn(i.ClientSecretNotIn...))
	}
	if i.ClientSecretGT != nil {
		predicates = append(predicates, oauthconnection.ClientSecretGT(*i.ClientSecretGT))
	}
	if i.ClientSecretGTE != nil {
		predicates = append(predicates, oauthconnection.ClientSecretGTE(*i.ClientSecretGTE))
	}
	if i.ClientSecretLT != nil {
		predicates = append(predicates, oauthconnection.ClientSecretLT(*i.ClientSecretLT))
	}
	if i.ClientSecretLTE != nil {
		predicates = append(predicates, oauthconnection.ClientSecretLTE(*i.ClientSecretLTE))
	}
	if i.ClientSecretContains != nil {
		predicates = append(predicates, oauthconnection.ClientSecretContains(*i.ClientSecretContains))
	}
	if i.ClientSecretHasPrefix != nil {
		predicates = append(predicates, oauthconnection.ClientSecretHasPrefix(*i.ClientSecretHasPrefix))
	}
	if i.ClientSecretHasSuffix != nil {
		predicates = append(predicates, oauthconnection.ClientSecretHasSuffix(*i.ClientSecretHasSuffix))
	}
	if i.ClientSecretIsNil {
		predicates = append(predicates, oauthconnection.ClientSecretIsNil())
	}
	if i.ClientSecretNotNil {
		predicates = append(predicates, oauthconnection.ClientSecretNotNil())
	}
	if i.ClientSecretEqualFold != nil {
		predicates = append(predicates, oauthconnection.ClientSecretEqualFold(*i.ClientSecretEqualFold))
	}
	if i.ClientSecretContainsFold != nil {
		predicates = append(predicates, oauthconnection.ClientSecretContainsFold(*i.ClientSecretContainsFold))
	}
	if i.Scopes != nil {
		predicates = append(predicates, oauthconnection.ScopesEQ(*i.Scopes))
	}
	if i.ScopesNEQ != nil {
		predicates = append(predicates, oauthconnection.ScopesNEQ(*i.ScopesNEQ))
	}
	if len(i.ScopesIn) > 0 {
		predicates = append(predicates, oauthconnection.ScopesIn(i.ScopesIn...))
	}
	if len(i.ScopesNotIn) > 0 {
		predicates = append(predicates, oauthconnection.ScopesNotIn(i.ScopesNotIn...))
	}
	if i.ScopesGT != nil {
		predicates = append(predicates, oauthconnection.ScopesGT(*i.ScopesGT))
	}
	if i.ScopesGTE != nil {
		predicates = append(predicates, oauthconnection.ScopesGTE(*i.ScopesGTE))
	}
	if i.ScopesLT != nil {
		predicates = append(predicates, oauthconnection.ScopesLT(*i.ScopesLT))
	}
	if i.ScopesLTE != nil {
		predicates = append(predicates, oauthconnection.ScopesLTE(*i.ScopesLTE))
	}
	if i.ScopesContains != nil {
		predicates = append(predicates, oauthconnection.ScopesContains(*i.ScopesContains))
	}
	if i.ScopesHasPrefix != nil {
		predicates = append(predicates, oauthconnection.ScopesHasPrefix(*i.ScopesHasPrefix))
	}
	if i.ScopesHasSuffix != nil {
		predicates = append(predicates, oauthconnection.ScopesHasSuffix(*i.ScopesHasSuffix))
	}
	if i.ScopesIsNil {
		predicates = append(predicates, oauthconnection.ScopesIsNil())
	}
	if i.ScopesNotNil {
		predicates = append(predicates, oauthconnection.ScopesNotNil())
	}
	if i.ScopesEqualFold != nil {
		predicates = append(predicates, oauthconnection.ScopesEqualFold(*i.ScopesEqualFold))
	}
	if i.ScopesContainsFold != nil {
		predicates = append(predicates, oauthconnection.ScopesContainsFold(*i.ScopesContainsFold))
	}
	if i.RedirectURL != nil {
		predicates = append(predicates, oauthconnection.RedirectURLEQ(*i.RedirectURL))
	}
	if i.RedirectURLNEQ != nil {
		predicates = append(predicates, oauthconnection.RedirectURLNEQ(*i.RedirectURLNEQ))
	}
	if len(i.RedirectURLIn) > 0 {
		predicates = append(predicates, oauthconnection.RedirectURLIn(i.RedirectURLIn...))
	}
	if len(i.RedirectURLNotIn) > 0 {
		predicates = append(predicates, oauthconnection.RedirectURLNotIn(i.RedirectURLNotIn...))
	}
	if i.RedirectURLGT != nil {
		predicates = append(predicates, oauthconnection.RedirectURLGT(*i.RedirectURLGT))
	}
	if i.RedirectURLGTE != nil {
		predicates = append(predicates, oauthconnection.RedirectURLGTE(*i.RedirectURLGTE))
	}
	if i.RedirectURLLT != nil {
		predicates = append(predicates, oauthconnection.RedirectURLLT(*i.RedirectURLLT))
	}
	if i.RedirectURLLTE != nil {
		predicates = append(predicates, oauthconnection.RedirectURLLTE(*i.RedirectURLLTE))
	}
	if i.RedirectURLContains != nil {
		predicates = append(predicates, oauthconnection.RedirectURLContains(*i.RedirectURLContains))
	}
	if i.RedirectURLHasPrefix != nil {
		predicates = append(predicates, oauthconnection.RedirectURLHasPrefix(*i.RedirectURLHasPrefix))
	}
	if i.RedirectURLHasSuffix != nil {
		predicates = append(predicates, oauthconnection.RedirectURLHasSuffix(*i.RedirectURLHasSuffix))
	}
	if i.RedirectURLIsNil {
		predicates = append(predicates, oauthconnection.RedirectURLIsNil())
	}
	if i.RedirectURLNotNil {
		predicates = append(predicates, oauthconnection.RedirectURLNotNil())
	}
	if i.RedirectURLEqualFold != nil {
		predicates = append(predicates, oauthconnection.RedirectURLEqualFold(*i.RedirectURLEqualFold))
	}
	if i.RedirectURLContainsFold != nil {
		predicates = append(predicates, oauthconnection.RedirectURLContainsFold(*i.RedirectURLContainsFold))
	}
	if i.DashboardLink != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkEQ(*i.DashboardLink))
	}
	if i.DashboardLinkNEQ != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkNEQ(*i.DashboardLinkNEQ))
	}
	if len(i.DashboardLinkIn) > 0 {
		predicates = append(predicates, oauthconnection.DashboardLinkIn(i.DashboardLinkIn...))
	}
	if len(i.DashboardLinkNotIn) > 0 {
		predicates = append(predicates, oauthconnection.DashboardLinkNotIn(i.DashboardLinkNotIn...))
	}
	if i.DashboardLinkGT != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkGT(*i.DashboardLinkGT))
	}
	if i.DashboardLinkGTE != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkGTE(*i.DashboardLinkGTE))
	}
	if i.DashboardLinkLT != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkLT(*i.DashboardLinkLT))
	}
	if i.DashboardLinkLTE != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkLTE(*i.DashboardLinkLTE))
	}
	if i.DashboardLinkContains != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkContains(*i.DashboardLinkContains))
	}
	if i.DashboardLinkHasPrefix != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkHasPrefix(*i.DashboardLinkHasPrefix))
	}
	if i.DashboardLinkHasSuffix != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkHasSuffix(*i.DashboardLinkHasSuffix))
	}
	if i.DashboardLinkIsNil {
		predicates = append(predicates, oauthconnection.DashboardLinkIsNil())
	}
	if i.DashboardLinkNotNil {
		predicates = append(predicates, oauthconnection.DashboardLinkNotNil())
	}
	if i.DashboardLinkEqualFold != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkEqualFold(*i.DashboardLinkEqualFold))
	}
	if i.DashboardLinkContainsFold != nil {
		predicates = append(predicates, oauthconnection.DashboardLinkContainsFold(*i.DashboardLinkContainsFold))
	}
	if i.Note != nil {
		predicates = append(predicates, oauthconnection.NoteEQ(*i.Note))
	}
	if i.NoteNEQ != nil {
		predicates = append(predicates, oauthconnection.NoteNEQ(*i.NoteNEQ))
	}
	if len(i.NoteIn) > 0 {
		predicates = append(predicates, oauthconnection.NoteIn(i.NoteIn...))
	}
	if len(i.NoteNotIn) > 0 {
		predicates = append(predicates, oauthconnection.NoteNotIn(i.NoteNotIn...))
	}
	if i.NoteGT != nil {
		predicates = append(predicates, oauthconnection.NoteGT(*i.NoteGT))
	}
	if i.NoteGTE != nil {
		predicates = append(predicates, oauthconnection.NoteGTE(*i.NoteGTE))
	}
	if i.NoteLT != nil {
		predicates = append(predicates, oauthconnection.NoteLT(*i.NoteLT))
	}
	if i.NoteLTE != nil {
		predicates = append(predicates, oauthconnection.NoteLTE(*i.NoteLTE))
	}
	if i.NoteContains != nil {
		predicates = append(predicates, oauthconnection.NoteContains(*i.NoteContains))
	}
	if i.NoteHasPrefix != nil {
		predicates = append(predicates, oauthconnection.NoteHasPrefix(*i.NoteHasPrefix))
	}
	if i.NoteHasSuffix != nil {
		predicates = append(predicates, oauthconnection.NoteHasSuffix(*i.NoteHasSuffix))
	}
	if i.NoteIsNil {
		predicates = append(predicates, oauthconnection.NoteIsNil())
	}
	if i.NoteNotNil {
		predicates = append(predicates, oauthconnection.NoteNotNil())
	}
	if i.NoteEqualFold != nil {
		predicates = append(predicates, oauthconnection.NoteEqualFold(*i.NoteEqualFold))
	}
	if i.NoteContainsFold != nil {
		predicates = append(predicates, oauthconnection.NoteContainsFold(*i.NoteContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, oauthconnection.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, oauthconnection.StatusNEQ(*i.StatusNEQ))
	}
	if i.StatusIsNil {
		predicates = append(predicates, oauthconnection.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, oauthconnection.StatusNotNil())
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyOauthConnectionWhereInput
	case 1:
		return predicates[0], nil
	default:
		return oauthconnection.And(predicates...), nil
	}
}

// PostWhereInput represents a where input for filtering Post queries.
type PostWhereInput struct {
	Predicates []predicate.Post  `json:"-"`
	Not        *PostWhereInput   `json:"not,omitempty"`
	Or         []*PostWhereInput `json:"or,omitempty"`
	And        []*PostWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "post_status_id" field predicates.
	PostStatusID             *string  `json:"postStatusID,omitempty"`
	PostStatusIDNEQ          *string  `json:"postStatusIDNEQ,omitempty"`
	PostStatusIDIn           []string `json:"postStatusIDIn,omitempty"`
	PostStatusIDNotIn        []string `json:"postStatusIDNotIn,omitempty"`
	PostStatusIDGT           *string  `json:"postStatusIDGT,omitempty"`
	PostStatusIDGTE          *string  `json:"postStatusIDGTE,omitempty"`
	PostStatusIDLT           *string  `json:"postStatusIDLT,omitempty"`
	PostStatusIDLTE          *string  `json:"postStatusIDLTE,omitempty"`
	PostStatusIDContains     *string  `json:"postStatusIDContains,omitempty"`
	PostStatusIDHasPrefix    *string  `json:"postStatusIDHasPrefix,omitempty"`
	PostStatusIDHasSuffix    *string  `json:"postStatusIDHasSuffix,omitempty"`
	PostStatusIDIsNil        bool     `json:"postStatusIDIsNil,omitempty"`
	PostStatusIDNotNil       bool     `json:"postStatusIDNotNil,omitempty"`
	PostStatusIDEqualFold    *string  `json:"postStatusIDEqualFold,omitempty"`
	PostStatusIDContainsFold *string  `json:"postStatusIDContainsFold,omitempty"`

	// "post_type_id" field predicates.
	PostTypeID             *string  `json:"postTypeID,omitempty"`
	PostTypeIDNEQ          *string  `json:"postTypeIDNEQ,omitempty"`
	PostTypeIDIn           []string `json:"postTypeIDIn,omitempty"`
	PostTypeIDNotIn        []string `json:"postTypeIDNotIn,omitempty"`
	PostTypeIDGT           *string  `json:"postTypeIDGT,omitempty"`
	PostTypeIDGTE          *string  `json:"postTypeIDGTE,omitempty"`
	PostTypeIDLT           *string  `json:"postTypeIDLT,omitempty"`
	PostTypeIDLTE          *string  `json:"postTypeIDLTE,omitempty"`
	PostTypeIDContains     *string  `json:"postTypeIDContains,omitempty"`
	PostTypeIDHasPrefix    *string  `json:"postTypeIDHasPrefix,omitempty"`
	PostTypeIDHasSuffix    *string  `json:"postTypeIDHasSuffix,omitempty"`
	PostTypeIDIsNil        bool     `json:"postTypeIDIsNil,omitempty"`
	PostTypeIDNotNil       bool     `json:"postTypeIDNotNil,omitempty"`
	PostTypeIDEqualFold    *string  `json:"postTypeIDEqualFold,omitempty"`
	PostTypeIDContainsFold *string  `json:"postTypeIDContainsFold,omitempty"`

	// "primary_category_id" field predicates.
	PrimaryCategoryID             *string  `json:"primaryCategoryID,omitempty"`
	PrimaryCategoryIDNEQ          *string  `json:"primaryCategoryIDNEQ,omitempty"`
	PrimaryCategoryIDIn           []string `json:"primaryCategoryIDIn,omitempty"`
	PrimaryCategoryIDNotIn        []string `json:"primaryCategoryIDNotIn,omitempty"`
	PrimaryCategoryIDGT           *string  `json:"primaryCategoryIDGT,omitempty"`
	PrimaryCategoryIDGTE          *string  `json:"primaryCategoryIDGTE,omitempty"`
	PrimaryCategoryIDLT           *string  `json:"primaryCategoryIDLT,omitempty"`
	PrimaryCategoryIDLTE          *string  `json:"primaryCategoryIDLTE,omitempty"`
	PrimaryCategoryIDContains     *string  `json:"primaryCategoryIDContains,omitempty"`
	PrimaryCategoryIDHasPrefix    *string  `json:"primaryCategoryIDHasPrefix,omitempty"`
	PrimaryCategoryIDHasSuffix    *string  `json:"primaryCategoryIDHasSuffix,omitempty"`
	PrimaryCategoryIDIsNil        bool     `json:"primaryCategoryIDIsNil,omitempty"`
	PrimaryCategoryIDNotNil       bool     `json:"primaryCategoryIDNotNil,omitempty"`
	PrimaryCategoryIDEqualFold    *string  `json:"primaryCategoryIDEqualFold,omitempty"`
	PrimaryCategoryIDContainsFold *string  `json:"primaryCategoryIDContainsFold,omitempty"`

	// "headline" field predicates.
	Headline             *string  `json:"headline,omitempty"`
	HeadlineNEQ          *string  `json:"headlineNEQ,omitempty"`
	HeadlineIn           []string `json:"headlineIn,omitempty"`
	HeadlineNotIn        []string `json:"headlineNotIn,omitempty"`
	HeadlineGT           *string  `json:"headlineGT,omitempty"`
	HeadlineGTE          *string  `json:"headlineGTE,omitempty"`
	HeadlineLT           *string  `json:"headlineLT,omitempty"`
	HeadlineLTE          *string  `json:"headlineLTE,omitempty"`
	HeadlineContains     *string  `json:"headlineContains,omitempty"`
	HeadlineHasPrefix    *string  `json:"headlineHasPrefix,omitempty"`
	HeadlineHasSuffix    *string  `json:"headlineHasSuffix,omitempty"`
	HeadlineIsNil        bool     `json:"headlineIsNil,omitempty"`
	HeadlineNotNil       bool     `json:"headlineNotNil,omitempty"`
	HeadlineEqualFold    *string  `json:"headlineEqualFold,omitempty"`
	HeadlineContainsFold *string  `json:"headlineContainsFold,omitempty"`

	// "excerpt" field predicates.
	Excerpt             *string  `json:"excerpt,omitempty"`
	ExcerptNEQ          *string  `json:"excerptNEQ,omitempty"`
	ExcerptIn           []string `json:"excerptIn,omitempty"`
	ExcerptNotIn        []string `json:"excerptNotIn,omitempty"`
	ExcerptGT           *string  `json:"excerptGT,omitempty"`
	ExcerptGTE          *string  `json:"excerptGTE,omitempty"`
	ExcerptLT           *string  `json:"excerptLT,omitempty"`
	ExcerptLTE          *string  `json:"excerptLTE,omitempty"`
	ExcerptContains     *string  `json:"excerptContains,omitempty"`
	ExcerptHasPrefix    *string  `json:"excerptHasPrefix,omitempty"`
	ExcerptHasSuffix    *string  `json:"excerptHasSuffix,omitempty"`
	ExcerptIsNil        bool     `json:"excerptIsNil,omitempty"`
	ExcerptNotNil       bool     `json:"excerptNotNil,omitempty"`
	ExcerptEqualFold    *string  `json:"excerptEqualFold,omitempty"`
	ExcerptContainsFold *string  `json:"excerptContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "meta_title" field predicates.
	MetaTitle             *string  `json:"metaTitle,omitempty"`
	MetaTitleNEQ          *string  `json:"metaTitleNEQ,omitempty"`
	MetaTitleIn           []string `json:"metaTitleIn,omitempty"`
	MetaTitleNotIn        []string `json:"metaTitleNotIn,omitempty"`
	MetaTitleGT           *string  `json:"metaTitleGT,omitempty"`
	MetaTitleGTE          *string  `json:"metaTitleGTE,omitempty"`
	MetaTitleLT           *string  `json:"metaTitleLT,omitempty"`
	MetaTitleLTE          *string  `json:"metaTitleLTE,omitempty"`
	MetaTitleContains     *string  `json:"metaTitleContains,omitempty"`
	MetaTitleHasPrefix    *string  `json:"metaTitleHasPrefix,omitempty"`
	MetaTitleHasSuffix    *string  `json:"metaTitleHasSuffix,omitempty"`
	MetaTitleIsNil        bool     `json:"metaTitleIsNil,omitempty"`
	MetaTitleNotNil       bool     `json:"metaTitleNotNil,omitempty"`
	MetaTitleEqualFold    *string  `json:"metaTitleEqualFold,omitempty"`
	MetaTitleContainsFold *string  `json:"metaTitleContainsFold,omitempty"`

	// "meta_descr" field predicates.
	MetaDescr             *string  `json:"metaDescr,omitempty"`
	MetaDescrNEQ          *string  `json:"metaDescrNEQ,omitempty"`
	MetaDescrIn           []string `json:"metaDescrIn,omitempty"`
	MetaDescrNotIn        []string `json:"metaDescrNotIn,omitempty"`
	MetaDescrGT           *string  `json:"metaDescrGT,omitempty"`
	MetaDescrGTE          *string  `json:"metaDescrGTE,omitempty"`
	MetaDescrLT           *string  `json:"metaDescrLT,omitempty"`
	MetaDescrLTE          *string  `json:"metaDescrLTE,omitempty"`
	MetaDescrContains     *string  `json:"metaDescrContains,omitempty"`
	MetaDescrHasPrefix    *string  `json:"metaDescrHasPrefix,omitempty"`
	MetaDescrHasSuffix    *string  `json:"metaDescrHasSuffix,omitempty"`
	MetaDescrIsNil        bool     `json:"metaDescrIsNil,omitempty"`
	MetaDescrNotNil       bool     `json:"metaDescrNotNil,omitempty"`
	MetaDescrEqualFold    *string  `json:"metaDescrEqualFold,omitempty"`
	MetaDescrContainsFold *string  `json:"metaDescrContainsFold,omitempty"`

	// "meta_canonical_url" field predicates.
	MetaCanonicalURL             *string  `json:"metaCanonicalURL,omitempty"`
	MetaCanonicalURLNEQ          *string  `json:"metaCanonicalURLNEQ,omitempty"`
	MetaCanonicalURLIn           []string `json:"metaCanonicalURLIn,omitempty"`
	MetaCanonicalURLNotIn        []string `json:"metaCanonicalURLNotIn,omitempty"`
	MetaCanonicalURLGT           *string  `json:"metaCanonicalURLGT,omitempty"`
	MetaCanonicalURLGTE          *string  `json:"metaCanonicalURLGTE,omitempty"`
	MetaCanonicalURLLT           *string  `json:"metaCanonicalURLLT,omitempty"`
	MetaCanonicalURLLTE          *string  `json:"metaCanonicalURLLTE,omitempty"`
	MetaCanonicalURLContains     *string  `json:"metaCanonicalURLContains,omitempty"`
	MetaCanonicalURLHasPrefix    *string  `json:"metaCanonicalURLHasPrefix,omitempty"`
	MetaCanonicalURLHasSuffix    *string  `json:"metaCanonicalURLHasSuffix,omitempty"`
	MetaCanonicalURLIsNil        bool     `json:"metaCanonicalURLIsNil,omitempty"`
	MetaCanonicalURLNotNil       bool     `json:"metaCanonicalURLNotNil,omitempty"`
	MetaCanonicalURLEqualFold    *string  `json:"metaCanonicalURLEqualFold,omitempty"`
	MetaCanonicalURLContainsFold *string  `json:"metaCanonicalURLContainsFold,omitempty"`

	// "meta_robots" field predicates.
	MetaRobots             *string  `json:"metaRobots,omitempty"`
	MetaRobotsNEQ          *string  `json:"metaRobotsNEQ,omitempty"`
	MetaRobotsIn           []string `json:"metaRobotsIn,omitempty"`
	MetaRobotsNotIn        []string `json:"metaRobotsNotIn,omitempty"`
	MetaRobotsGT           *string  `json:"metaRobotsGT,omitempty"`
	MetaRobotsGTE          *string  `json:"metaRobotsGTE,omitempty"`
	MetaRobotsLT           *string  `json:"metaRobotsLT,omitempty"`
	MetaRobotsLTE          *string  `json:"metaRobotsLTE,omitempty"`
	MetaRobotsContains     *string  `json:"metaRobotsContains,omitempty"`
	MetaRobotsHasPrefix    *string  `json:"metaRobotsHasPrefix,omitempty"`
	MetaRobotsHasSuffix    *string  `json:"metaRobotsHasSuffix,omitempty"`
	MetaRobotsIsNil        bool     `json:"metaRobotsIsNil,omitempty"`
	MetaRobotsNotNil       bool     `json:"metaRobotsNotNil,omitempty"`
	MetaRobotsEqualFold    *string  `json:"metaRobotsEqualFold,omitempty"`
	MetaRobotsContainsFold *string  `json:"metaRobotsContainsFold,omitempty"`

	// "post_status" edge predicates.
	HasPostStatus     *bool                   `json:"hasPostStatus,omitempty"`
	HasPostStatusWith []*PostStatusWhereInput `json:"hasPostStatusWith,omitempty"`

	// "post_type" edge predicates.
	HasPostType     *bool                 `json:"hasPostType,omitempty"`
	HasPostTypeWith []*PostTypeWhereInput `json:"hasPostTypeWith,omitempty"`

	// "primary_category" edge predicates.
	HasPrimaryCategory     *bool                     `json:"hasPrimaryCategory,omitempty"`
	HasPrimaryCategoryWith []*PostCategoryWhereInput `json:"hasPrimaryCategoryWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostWhereInput) AddPredicates(predicates ...predicate.Post) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostWhereInput filter on the PostQuery builder.
func (i *PostWhereInput) Filter(q *PostQuery) (*PostQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostWhereInput is returned in case the PostWhereInput is empty.
var ErrEmptyPostWhereInput = errors.New("ent: empty predicate PostWhereInput")

// P returns a predicate for filtering posts.
// An error is returned if the input is empty or invalid.
func (i *PostWhereInput) P() (predicate.Post, error) {
	var predicates []predicate.Post
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, post.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Post, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, post.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Post, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, post.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, post.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, post.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, post.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, post.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, post.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, post.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, post.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, post.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, post.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, post.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, post.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, post.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, post.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, post.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, post.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, post.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, post.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, post.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, post.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, post.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, post.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, post.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, post.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, post.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, post.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, post.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, post.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, post.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, post.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, post.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, post.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, post.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, post.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, post.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, post.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, post.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, post.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, post.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, post.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, post.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, post.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, post.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, post.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, post.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, post.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, post.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, post.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, post.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, post.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, post.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, post.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, post.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, post.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, post.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, post.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, post.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, post.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, post.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, post.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, post.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.PostStatusID != nil {
		predicates = append(predicates, post.PostStatusIDEQ(*i.PostStatusID))
	}
	if i.PostStatusIDNEQ != nil {
		predicates = append(predicates, post.PostStatusIDNEQ(*i.PostStatusIDNEQ))
	}
	if len(i.PostStatusIDIn) > 0 {
		predicates = append(predicates, post.PostStatusIDIn(i.PostStatusIDIn...))
	}
	if len(i.PostStatusIDNotIn) > 0 {
		predicates = append(predicates, post.PostStatusIDNotIn(i.PostStatusIDNotIn...))
	}
	if i.PostStatusIDGT != nil {
		predicates = append(predicates, post.PostStatusIDGT(*i.PostStatusIDGT))
	}
	if i.PostStatusIDGTE != nil {
		predicates = append(predicates, post.PostStatusIDGTE(*i.PostStatusIDGTE))
	}
	if i.PostStatusIDLT != nil {
		predicates = append(predicates, post.PostStatusIDLT(*i.PostStatusIDLT))
	}
	if i.PostStatusIDLTE != nil {
		predicates = append(predicates, post.PostStatusIDLTE(*i.PostStatusIDLTE))
	}
	if i.PostStatusIDContains != nil {
		predicates = append(predicates, post.PostStatusIDContains(*i.PostStatusIDContains))
	}
	if i.PostStatusIDHasPrefix != nil {
		predicates = append(predicates, post.PostStatusIDHasPrefix(*i.PostStatusIDHasPrefix))
	}
	if i.PostStatusIDHasSuffix != nil {
		predicates = append(predicates, post.PostStatusIDHasSuffix(*i.PostStatusIDHasSuffix))
	}
	if i.PostStatusIDIsNil {
		predicates = append(predicates, post.PostStatusIDIsNil())
	}
	if i.PostStatusIDNotNil {
		predicates = append(predicates, post.PostStatusIDNotNil())
	}
	if i.PostStatusIDEqualFold != nil {
		predicates = append(predicates, post.PostStatusIDEqualFold(*i.PostStatusIDEqualFold))
	}
	if i.PostStatusIDContainsFold != nil {
		predicates = append(predicates, post.PostStatusIDContainsFold(*i.PostStatusIDContainsFold))
	}
	if i.PostTypeID != nil {
		predicates = append(predicates, post.PostTypeIDEQ(*i.PostTypeID))
	}
	if i.PostTypeIDNEQ != nil {
		predicates = append(predicates, post.PostTypeIDNEQ(*i.PostTypeIDNEQ))
	}
	if len(i.PostTypeIDIn) > 0 {
		predicates = append(predicates, post.PostTypeIDIn(i.PostTypeIDIn...))
	}
	if len(i.PostTypeIDNotIn) > 0 {
		predicates = append(predicates, post.PostTypeIDNotIn(i.PostTypeIDNotIn...))
	}
	if i.PostTypeIDGT != nil {
		predicates = append(predicates, post.PostTypeIDGT(*i.PostTypeIDGT))
	}
	if i.PostTypeIDGTE != nil {
		predicates = append(predicates, post.PostTypeIDGTE(*i.PostTypeIDGTE))
	}
	if i.PostTypeIDLT != nil {
		predicates = append(predicates, post.PostTypeIDLT(*i.PostTypeIDLT))
	}
	if i.PostTypeIDLTE != nil {
		predicates = append(predicates, post.PostTypeIDLTE(*i.PostTypeIDLTE))
	}
	if i.PostTypeIDContains != nil {
		predicates = append(predicates, post.PostTypeIDContains(*i.PostTypeIDContains))
	}
	if i.PostTypeIDHasPrefix != nil {
		predicates = append(predicates, post.PostTypeIDHasPrefix(*i.PostTypeIDHasPrefix))
	}
	if i.PostTypeIDHasSuffix != nil {
		predicates = append(predicates, post.PostTypeIDHasSuffix(*i.PostTypeIDHasSuffix))
	}
	if i.PostTypeIDIsNil {
		predicates = append(predicates, post.PostTypeIDIsNil())
	}
	if i.PostTypeIDNotNil {
		predicates = append(predicates, post.PostTypeIDNotNil())
	}
	if i.PostTypeIDEqualFold != nil {
		predicates = append(predicates, post.PostTypeIDEqualFold(*i.PostTypeIDEqualFold))
	}
	if i.PostTypeIDContainsFold != nil {
		predicates = append(predicates, post.PostTypeIDContainsFold(*i.PostTypeIDContainsFold))
	}
	if i.PrimaryCategoryID != nil {
		predicates = append(predicates, post.PrimaryCategoryIDEQ(*i.PrimaryCategoryID))
	}
	if i.PrimaryCategoryIDNEQ != nil {
		predicates = append(predicates, post.PrimaryCategoryIDNEQ(*i.PrimaryCategoryIDNEQ))
	}
	if len(i.PrimaryCategoryIDIn) > 0 {
		predicates = append(predicates, post.PrimaryCategoryIDIn(i.PrimaryCategoryIDIn...))
	}
	if len(i.PrimaryCategoryIDNotIn) > 0 {
		predicates = append(predicates, post.PrimaryCategoryIDNotIn(i.PrimaryCategoryIDNotIn...))
	}
	if i.PrimaryCategoryIDGT != nil {
		predicates = append(predicates, post.PrimaryCategoryIDGT(*i.PrimaryCategoryIDGT))
	}
	if i.PrimaryCategoryIDGTE != nil {
		predicates = append(predicates, post.PrimaryCategoryIDGTE(*i.PrimaryCategoryIDGTE))
	}
	if i.PrimaryCategoryIDLT != nil {
		predicates = append(predicates, post.PrimaryCategoryIDLT(*i.PrimaryCategoryIDLT))
	}
	if i.PrimaryCategoryIDLTE != nil {
		predicates = append(predicates, post.PrimaryCategoryIDLTE(*i.PrimaryCategoryIDLTE))
	}
	if i.PrimaryCategoryIDContains != nil {
		predicates = append(predicates, post.PrimaryCategoryIDContains(*i.PrimaryCategoryIDContains))
	}
	if i.PrimaryCategoryIDHasPrefix != nil {
		predicates = append(predicates, post.PrimaryCategoryIDHasPrefix(*i.PrimaryCategoryIDHasPrefix))
	}
	if i.PrimaryCategoryIDHasSuffix != nil {
		predicates = append(predicates, post.PrimaryCategoryIDHasSuffix(*i.PrimaryCategoryIDHasSuffix))
	}
	if i.PrimaryCategoryIDIsNil {
		predicates = append(predicates, post.PrimaryCategoryIDIsNil())
	}
	if i.PrimaryCategoryIDNotNil {
		predicates = append(predicates, post.PrimaryCategoryIDNotNil())
	}
	if i.PrimaryCategoryIDEqualFold != nil {
		predicates = append(predicates, post.PrimaryCategoryIDEqualFold(*i.PrimaryCategoryIDEqualFold))
	}
	if i.PrimaryCategoryIDContainsFold != nil {
		predicates = append(predicates, post.PrimaryCategoryIDContainsFold(*i.PrimaryCategoryIDContainsFold))
	}
	if i.Headline != nil {
		predicates = append(predicates, post.HeadlineEQ(*i.Headline))
	}
	if i.HeadlineNEQ != nil {
		predicates = append(predicates, post.HeadlineNEQ(*i.HeadlineNEQ))
	}
	if len(i.HeadlineIn) > 0 {
		predicates = append(predicates, post.HeadlineIn(i.HeadlineIn...))
	}
	if len(i.HeadlineNotIn) > 0 {
		predicates = append(predicates, post.HeadlineNotIn(i.HeadlineNotIn...))
	}
	if i.HeadlineGT != nil {
		predicates = append(predicates, post.HeadlineGT(*i.HeadlineGT))
	}
	if i.HeadlineGTE != nil {
		predicates = append(predicates, post.HeadlineGTE(*i.HeadlineGTE))
	}
	if i.HeadlineLT != nil {
		predicates = append(predicates, post.HeadlineLT(*i.HeadlineLT))
	}
	if i.HeadlineLTE != nil {
		predicates = append(predicates, post.HeadlineLTE(*i.HeadlineLTE))
	}
	if i.HeadlineContains != nil {
		predicates = append(predicates, post.HeadlineContains(*i.HeadlineContains))
	}
	if i.HeadlineHasPrefix != nil {
		predicates = append(predicates, post.HeadlineHasPrefix(*i.HeadlineHasPrefix))
	}
	if i.HeadlineHasSuffix != nil {
		predicates = append(predicates, post.HeadlineHasSuffix(*i.HeadlineHasSuffix))
	}
	if i.HeadlineIsNil {
		predicates = append(predicates, post.HeadlineIsNil())
	}
	if i.HeadlineNotNil {
		predicates = append(predicates, post.HeadlineNotNil())
	}
	if i.HeadlineEqualFold != nil {
		predicates = append(predicates, post.HeadlineEqualFold(*i.HeadlineEqualFold))
	}
	if i.HeadlineContainsFold != nil {
		predicates = append(predicates, post.HeadlineContainsFold(*i.HeadlineContainsFold))
	}
	if i.Excerpt != nil {
		predicates = append(predicates, post.ExcerptEQ(*i.Excerpt))
	}
	if i.ExcerptNEQ != nil {
		predicates = append(predicates, post.ExcerptNEQ(*i.ExcerptNEQ))
	}
	if len(i.ExcerptIn) > 0 {
		predicates = append(predicates, post.ExcerptIn(i.ExcerptIn...))
	}
	if len(i.ExcerptNotIn) > 0 {
		predicates = append(predicates, post.ExcerptNotIn(i.ExcerptNotIn...))
	}
	if i.ExcerptGT != nil {
		predicates = append(predicates, post.ExcerptGT(*i.ExcerptGT))
	}
	if i.ExcerptGTE != nil {
		predicates = append(predicates, post.ExcerptGTE(*i.ExcerptGTE))
	}
	if i.ExcerptLT != nil {
		predicates = append(predicates, post.ExcerptLT(*i.ExcerptLT))
	}
	if i.ExcerptLTE != nil {
		predicates = append(predicates, post.ExcerptLTE(*i.ExcerptLTE))
	}
	if i.ExcerptContains != nil {
		predicates = append(predicates, post.ExcerptContains(*i.ExcerptContains))
	}
	if i.ExcerptHasPrefix != nil {
		predicates = append(predicates, post.ExcerptHasPrefix(*i.ExcerptHasPrefix))
	}
	if i.ExcerptHasSuffix != nil {
		predicates = append(predicates, post.ExcerptHasSuffix(*i.ExcerptHasSuffix))
	}
	if i.ExcerptIsNil {
		predicates = append(predicates, post.ExcerptIsNil())
	}
	if i.ExcerptNotNil {
		predicates = append(predicates, post.ExcerptNotNil())
	}
	if i.ExcerptEqualFold != nil {
		predicates = append(predicates, post.ExcerptEqualFold(*i.ExcerptEqualFold))
	}
	if i.ExcerptContainsFold != nil {
		predicates = append(predicates, post.ExcerptContainsFold(*i.ExcerptContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, post.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, post.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, post.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, post.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, post.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, post.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, post.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, post.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, post.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, post.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, post.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, post.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, post.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, post.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, post.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.MetaTitle != nil {
		predicates = append(predicates, post.MetaTitleEQ(*i.MetaTitle))
	}
	if i.MetaTitleNEQ != nil {
		predicates = append(predicates, post.MetaTitleNEQ(*i.MetaTitleNEQ))
	}
	if len(i.MetaTitleIn) > 0 {
		predicates = append(predicates, post.MetaTitleIn(i.MetaTitleIn...))
	}
	if len(i.MetaTitleNotIn) > 0 {
		predicates = append(predicates, post.MetaTitleNotIn(i.MetaTitleNotIn...))
	}
	if i.MetaTitleGT != nil {
		predicates = append(predicates, post.MetaTitleGT(*i.MetaTitleGT))
	}
	if i.MetaTitleGTE != nil {
		predicates = append(predicates, post.MetaTitleGTE(*i.MetaTitleGTE))
	}
	if i.MetaTitleLT != nil {
		predicates = append(predicates, post.MetaTitleLT(*i.MetaTitleLT))
	}
	if i.MetaTitleLTE != nil {
		predicates = append(predicates, post.MetaTitleLTE(*i.MetaTitleLTE))
	}
	if i.MetaTitleContains != nil {
		predicates = append(predicates, post.MetaTitleContains(*i.MetaTitleContains))
	}
	if i.MetaTitleHasPrefix != nil {
		predicates = append(predicates, post.MetaTitleHasPrefix(*i.MetaTitleHasPrefix))
	}
	if i.MetaTitleHasSuffix != nil {
		predicates = append(predicates, post.MetaTitleHasSuffix(*i.MetaTitleHasSuffix))
	}
	if i.MetaTitleIsNil {
		predicates = append(predicates, post.MetaTitleIsNil())
	}
	if i.MetaTitleNotNil {
		predicates = append(predicates, post.MetaTitleNotNil())
	}
	if i.MetaTitleEqualFold != nil {
		predicates = append(predicates, post.MetaTitleEqualFold(*i.MetaTitleEqualFold))
	}
	if i.MetaTitleContainsFold != nil {
		predicates = append(predicates, post.MetaTitleContainsFold(*i.MetaTitleContainsFold))
	}
	if i.MetaDescr != nil {
		predicates = append(predicates, post.MetaDescrEQ(*i.MetaDescr))
	}
	if i.MetaDescrNEQ != nil {
		predicates = append(predicates, post.MetaDescrNEQ(*i.MetaDescrNEQ))
	}
	if len(i.MetaDescrIn) > 0 {
		predicates = append(predicates, post.MetaDescrIn(i.MetaDescrIn...))
	}
	if len(i.MetaDescrNotIn) > 0 {
		predicates = append(predicates, post.MetaDescrNotIn(i.MetaDescrNotIn...))
	}
	if i.MetaDescrGT != nil {
		predicates = append(predicates, post.MetaDescrGT(*i.MetaDescrGT))
	}
	if i.MetaDescrGTE != nil {
		predicates = append(predicates, post.MetaDescrGTE(*i.MetaDescrGTE))
	}
	if i.MetaDescrLT != nil {
		predicates = append(predicates, post.MetaDescrLT(*i.MetaDescrLT))
	}
	if i.MetaDescrLTE != nil {
		predicates = append(predicates, post.MetaDescrLTE(*i.MetaDescrLTE))
	}
	if i.MetaDescrContains != nil {
		predicates = append(predicates, post.MetaDescrContains(*i.MetaDescrContains))
	}
	if i.MetaDescrHasPrefix != nil {
		predicates = append(predicates, post.MetaDescrHasPrefix(*i.MetaDescrHasPrefix))
	}
	if i.MetaDescrHasSuffix != nil {
		predicates = append(predicates, post.MetaDescrHasSuffix(*i.MetaDescrHasSuffix))
	}
	if i.MetaDescrIsNil {
		predicates = append(predicates, post.MetaDescrIsNil())
	}
	if i.MetaDescrNotNil {
		predicates = append(predicates, post.MetaDescrNotNil())
	}
	if i.MetaDescrEqualFold != nil {
		predicates = append(predicates, post.MetaDescrEqualFold(*i.MetaDescrEqualFold))
	}
	if i.MetaDescrContainsFold != nil {
		predicates = append(predicates, post.MetaDescrContainsFold(*i.MetaDescrContainsFold))
	}
	if i.MetaCanonicalURL != nil {
		predicates = append(predicates, post.MetaCanonicalURLEQ(*i.MetaCanonicalURL))
	}
	if i.MetaCanonicalURLNEQ != nil {
		predicates = append(predicates, post.MetaCanonicalURLNEQ(*i.MetaCanonicalURLNEQ))
	}
	if len(i.MetaCanonicalURLIn) > 0 {
		predicates = append(predicates, post.MetaCanonicalURLIn(i.MetaCanonicalURLIn...))
	}
	if len(i.MetaCanonicalURLNotIn) > 0 {
		predicates = append(predicates, post.MetaCanonicalURLNotIn(i.MetaCanonicalURLNotIn...))
	}
	if i.MetaCanonicalURLGT != nil {
		predicates = append(predicates, post.MetaCanonicalURLGT(*i.MetaCanonicalURLGT))
	}
	if i.MetaCanonicalURLGTE != nil {
		predicates = append(predicates, post.MetaCanonicalURLGTE(*i.MetaCanonicalURLGTE))
	}
	if i.MetaCanonicalURLLT != nil {
		predicates = append(predicates, post.MetaCanonicalURLLT(*i.MetaCanonicalURLLT))
	}
	if i.MetaCanonicalURLLTE != nil {
		predicates = append(predicates, post.MetaCanonicalURLLTE(*i.MetaCanonicalURLLTE))
	}
	if i.MetaCanonicalURLContains != nil {
		predicates = append(predicates, post.MetaCanonicalURLContains(*i.MetaCanonicalURLContains))
	}
	if i.MetaCanonicalURLHasPrefix != nil {
		predicates = append(predicates, post.MetaCanonicalURLHasPrefix(*i.MetaCanonicalURLHasPrefix))
	}
	if i.MetaCanonicalURLHasSuffix != nil {
		predicates = append(predicates, post.MetaCanonicalURLHasSuffix(*i.MetaCanonicalURLHasSuffix))
	}
	if i.MetaCanonicalURLIsNil {
		predicates = append(predicates, post.MetaCanonicalURLIsNil())
	}
	if i.MetaCanonicalURLNotNil {
		predicates = append(predicates, post.MetaCanonicalURLNotNil())
	}
	if i.MetaCanonicalURLEqualFold != nil {
		predicates = append(predicates, post.MetaCanonicalURLEqualFold(*i.MetaCanonicalURLEqualFold))
	}
	if i.MetaCanonicalURLContainsFold != nil {
		predicates = append(predicates, post.MetaCanonicalURLContainsFold(*i.MetaCanonicalURLContainsFold))
	}
	if i.MetaRobots != nil {
		predicates = append(predicates, post.MetaRobotsEQ(*i.MetaRobots))
	}
	if i.MetaRobotsNEQ != nil {
		predicates = append(predicates, post.MetaRobotsNEQ(*i.MetaRobotsNEQ))
	}
	if len(i.MetaRobotsIn) > 0 {
		predicates = append(predicates, post.MetaRobotsIn(i.MetaRobotsIn...))
	}
	if len(i.MetaRobotsNotIn) > 0 {
		predicates = append(predicates, post.MetaRobotsNotIn(i.MetaRobotsNotIn...))
	}
	if i.MetaRobotsGT != nil {
		predicates = append(predicates, post.MetaRobotsGT(*i.MetaRobotsGT))
	}
	if i.MetaRobotsGTE != nil {
		predicates = append(predicates, post.MetaRobotsGTE(*i.MetaRobotsGTE))
	}
	if i.MetaRobotsLT != nil {
		predicates = append(predicates, post.MetaRobotsLT(*i.MetaRobotsLT))
	}
	if i.MetaRobotsLTE != nil {
		predicates = append(predicates, post.MetaRobotsLTE(*i.MetaRobotsLTE))
	}
	if i.MetaRobotsContains != nil {
		predicates = append(predicates, post.MetaRobotsContains(*i.MetaRobotsContains))
	}
	if i.MetaRobotsHasPrefix != nil {
		predicates = append(predicates, post.MetaRobotsHasPrefix(*i.MetaRobotsHasPrefix))
	}
	if i.MetaRobotsHasSuffix != nil {
		predicates = append(predicates, post.MetaRobotsHasSuffix(*i.MetaRobotsHasSuffix))
	}
	if i.MetaRobotsIsNil {
		predicates = append(predicates, post.MetaRobotsIsNil())
	}
	if i.MetaRobotsNotNil {
		predicates = append(predicates, post.MetaRobotsNotNil())
	}
	if i.MetaRobotsEqualFold != nil {
		predicates = append(predicates, post.MetaRobotsEqualFold(*i.MetaRobotsEqualFold))
	}
	if i.MetaRobotsContainsFold != nil {
		predicates = append(predicates, post.MetaRobotsContainsFold(*i.MetaRobotsContainsFold))
	}

	if i.HasPostStatus != nil {
		p := post.HasPostStatus()
		if !*i.HasPostStatus {
			p = post.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostStatusWith) > 0 {
		with := make([]predicate.PostStatus, 0, len(i.HasPostStatusWith))
		for _, w := range i.HasPostStatusWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostStatusWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, post.HasPostStatusWith(with...))
	}
	if i.HasPostType != nil {
		p := post.HasPostType()
		if !*i.HasPostType {
			p = post.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostTypeWith) > 0 {
		with := make([]predicate.PostType, 0, len(i.HasPostTypeWith))
		for _, w := range i.HasPostTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, post.HasPostTypeWith(with...))
	}
	if i.HasPrimaryCategory != nil {
		p := post.HasPrimaryCategory()
		if !*i.HasPrimaryCategory {
			p = post.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPrimaryCategoryWith) > 0 {
		with := make([]predicate.PostCategory, 0, len(i.HasPrimaryCategoryWith))
		for _, w := range i.HasPrimaryCategoryWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPrimaryCategoryWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, post.HasPrimaryCategoryWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostWhereInput
	case 1:
		return predicates[0], nil
	default:
		return post.And(predicates...), nil
	}
}

// PostCategoryWhereInput represents a where input for filtering PostCategory queries.
type PostCategoryWhereInput struct {
	Predicates []predicate.PostCategory  `json:"-"`
	Not        *PostCategoryWhereInput   `json:"not,omitempty"`
	Or         []*PostCategoryWhereInput `json:"or,omitempty"`
	And        []*PostCategoryWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "excerpt" field predicates.
	Excerpt             *string  `json:"excerpt,omitempty"`
	ExcerptNEQ          *string  `json:"excerptNEQ,omitempty"`
	ExcerptIn           []string `json:"excerptIn,omitempty"`
	ExcerptNotIn        []string `json:"excerptNotIn,omitempty"`
	ExcerptGT           *string  `json:"excerptGT,omitempty"`
	ExcerptGTE          *string  `json:"excerptGTE,omitempty"`
	ExcerptLT           *string  `json:"excerptLT,omitempty"`
	ExcerptLTE          *string  `json:"excerptLTE,omitempty"`
	ExcerptContains     *string  `json:"excerptContains,omitempty"`
	ExcerptHasPrefix    *string  `json:"excerptHasPrefix,omitempty"`
	ExcerptHasSuffix    *string  `json:"excerptHasSuffix,omitempty"`
	ExcerptIsNil        bool     `json:"excerptIsNil,omitempty"`
	ExcerptNotNil       bool     `json:"excerptNotNil,omitempty"`
	ExcerptEqualFold    *string  `json:"excerptEqualFold,omitempty"`
	ExcerptContainsFold *string  `json:"excerptContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "meta_title" field predicates.
	MetaTitle             *string  `json:"metaTitle,omitempty"`
	MetaTitleNEQ          *string  `json:"metaTitleNEQ,omitempty"`
	MetaTitleIn           []string `json:"metaTitleIn,omitempty"`
	MetaTitleNotIn        []string `json:"metaTitleNotIn,omitempty"`
	MetaTitleGT           *string  `json:"metaTitleGT,omitempty"`
	MetaTitleGTE          *string  `json:"metaTitleGTE,omitempty"`
	MetaTitleLT           *string  `json:"metaTitleLT,omitempty"`
	MetaTitleLTE          *string  `json:"metaTitleLTE,omitempty"`
	MetaTitleContains     *string  `json:"metaTitleContains,omitempty"`
	MetaTitleHasPrefix    *string  `json:"metaTitleHasPrefix,omitempty"`
	MetaTitleHasSuffix    *string  `json:"metaTitleHasSuffix,omitempty"`
	MetaTitleIsNil        bool     `json:"metaTitleIsNil,omitempty"`
	MetaTitleNotNil       bool     `json:"metaTitleNotNil,omitempty"`
	MetaTitleEqualFold    *string  `json:"metaTitleEqualFold,omitempty"`
	MetaTitleContainsFold *string  `json:"metaTitleContainsFold,omitempty"`

	// "meta_descr" field predicates.
	MetaDescr             *string  `json:"metaDescr,omitempty"`
	MetaDescrNEQ          *string  `json:"metaDescrNEQ,omitempty"`
	MetaDescrIn           []string `json:"metaDescrIn,omitempty"`
	MetaDescrNotIn        []string `json:"metaDescrNotIn,omitempty"`
	MetaDescrGT           *string  `json:"metaDescrGT,omitempty"`
	MetaDescrGTE          *string  `json:"metaDescrGTE,omitempty"`
	MetaDescrLT           *string  `json:"metaDescrLT,omitempty"`
	MetaDescrLTE          *string  `json:"metaDescrLTE,omitempty"`
	MetaDescrContains     *string  `json:"metaDescrContains,omitempty"`
	MetaDescrHasPrefix    *string  `json:"metaDescrHasPrefix,omitempty"`
	MetaDescrHasSuffix    *string  `json:"metaDescrHasSuffix,omitempty"`
	MetaDescrIsNil        bool     `json:"metaDescrIsNil,omitempty"`
	MetaDescrNotNil       bool     `json:"metaDescrNotNil,omitempty"`
	MetaDescrEqualFold    *string  `json:"metaDescrEqualFold,omitempty"`
	MetaDescrContainsFold *string  `json:"metaDescrContainsFold,omitempty"`

	// "meta_canonical_url" field predicates.
	MetaCanonicalURL             *string  `json:"metaCanonicalURL,omitempty"`
	MetaCanonicalURLNEQ          *string  `json:"metaCanonicalURLNEQ,omitempty"`
	MetaCanonicalURLIn           []string `json:"metaCanonicalURLIn,omitempty"`
	MetaCanonicalURLNotIn        []string `json:"metaCanonicalURLNotIn,omitempty"`
	MetaCanonicalURLGT           *string  `json:"metaCanonicalURLGT,omitempty"`
	MetaCanonicalURLGTE          *string  `json:"metaCanonicalURLGTE,omitempty"`
	MetaCanonicalURLLT           *string  `json:"metaCanonicalURLLT,omitempty"`
	MetaCanonicalURLLTE          *string  `json:"metaCanonicalURLLTE,omitempty"`
	MetaCanonicalURLContains     *string  `json:"metaCanonicalURLContains,omitempty"`
	MetaCanonicalURLHasPrefix    *string  `json:"metaCanonicalURLHasPrefix,omitempty"`
	MetaCanonicalURLHasSuffix    *string  `json:"metaCanonicalURLHasSuffix,omitempty"`
	MetaCanonicalURLIsNil        bool     `json:"metaCanonicalURLIsNil,omitempty"`
	MetaCanonicalURLNotNil       bool     `json:"metaCanonicalURLNotNil,omitempty"`
	MetaCanonicalURLEqualFold    *string  `json:"metaCanonicalURLEqualFold,omitempty"`
	MetaCanonicalURLContainsFold *string  `json:"metaCanonicalURLContainsFold,omitempty"`

	// "meta_robots" field predicates.
	MetaRobots             *string  `json:"metaRobots,omitempty"`
	MetaRobotsNEQ          *string  `json:"metaRobotsNEQ,omitempty"`
	MetaRobotsIn           []string `json:"metaRobotsIn,omitempty"`
	MetaRobotsNotIn        []string `json:"metaRobotsNotIn,omitempty"`
	MetaRobotsGT           *string  `json:"metaRobotsGT,omitempty"`
	MetaRobotsGTE          *string  `json:"metaRobotsGTE,omitempty"`
	MetaRobotsLT           *string  `json:"metaRobotsLT,omitempty"`
	MetaRobotsLTE          *string  `json:"metaRobotsLTE,omitempty"`
	MetaRobotsContains     *string  `json:"metaRobotsContains,omitempty"`
	MetaRobotsHasPrefix    *string  `json:"metaRobotsHasPrefix,omitempty"`
	MetaRobotsHasSuffix    *string  `json:"metaRobotsHasSuffix,omitempty"`
	MetaRobotsIsNil        bool     `json:"metaRobotsIsNil,omitempty"`
	MetaRobotsNotNil       bool     `json:"metaRobotsNotNil,omitempty"`
	MetaRobotsEqualFold    *string  `json:"metaRobotsEqualFold,omitempty"`
	MetaRobotsContainsFold *string  `json:"metaRobotsContainsFold,omitempty"`

	// "posts" edge predicates.
	HasPosts     *bool             `json:"hasPosts,omitempty"`
	HasPostsWith []*PostWhereInput `json:"hasPostsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostCategoryWhereInput) AddPredicates(predicates ...predicate.PostCategory) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostCategoryWhereInput filter on the PostCategoryQuery builder.
func (i *PostCategoryWhereInput) Filter(q *PostCategoryQuery) (*PostCategoryQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostCategoryWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostCategoryWhereInput is returned in case the PostCategoryWhereInput is empty.
var ErrEmptyPostCategoryWhereInput = errors.New("ent: empty predicate PostCategoryWhereInput")

// P returns a predicate for filtering postcategories.
// An error is returned if the input is empty or invalid.
func (i *PostCategoryWhereInput) P() (predicate.PostCategory, error) {
	var predicates []predicate.PostCategory
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, postcategory.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostCategory, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, postcategory.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostCategory, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, postcategory.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, postcategory.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, postcategory.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, postcategory.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, postcategory.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, postcategory.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, postcategory.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, postcategory.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, postcategory.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, postcategory.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, postcategory.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, postcategory.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, postcategory.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, postcategory.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, postcategory.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, postcategory.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, postcategory.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, postcategory.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, postcategory.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, postcategory.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, postcategory.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, postcategory.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, postcategory.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, postcategory.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, postcategory.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, postcategory.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, postcategory.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, postcategory.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, postcategory.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, postcategory.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, postcategory.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, postcategory.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, postcategory.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, postcategory.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, postcategory.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, postcategory.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, postcategory.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, postcategory.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, postcategory.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, postcategory.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, postcategory.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, postcategory.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, postcategory.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, postcategory.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, postcategory.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, postcategory.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, postcategory.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, postcategory.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, postcategory.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, postcategory.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, postcategory.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, postcategory.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, postcategory.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, postcategory.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, postcategory.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, postcategory.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, postcategory.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, postcategory.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, postcategory.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, postcategory.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, postcategory.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, postcategory.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, postcategory.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, postcategory.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, postcategory.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, postcategory.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, postcategory.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, postcategory.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, postcategory.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, postcategory.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, postcategory.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, postcategory.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, postcategory.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, postcategory.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, postcategory.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, postcategory.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.Excerpt != nil {
		predicates = append(predicates, postcategory.ExcerptEQ(*i.Excerpt))
	}
	if i.ExcerptNEQ != nil {
		predicates = append(predicates, postcategory.ExcerptNEQ(*i.ExcerptNEQ))
	}
	if len(i.ExcerptIn) > 0 {
		predicates = append(predicates, postcategory.ExcerptIn(i.ExcerptIn...))
	}
	if len(i.ExcerptNotIn) > 0 {
		predicates = append(predicates, postcategory.ExcerptNotIn(i.ExcerptNotIn...))
	}
	if i.ExcerptGT != nil {
		predicates = append(predicates, postcategory.ExcerptGT(*i.ExcerptGT))
	}
	if i.ExcerptGTE != nil {
		predicates = append(predicates, postcategory.ExcerptGTE(*i.ExcerptGTE))
	}
	if i.ExcerptLT != nil {
		predicates = append(predicates, postcategory.ExcerptLT(*i.ExcerptLT))
	}
	if i.ExcerptLTE != nil {
		predicates = append(predicates, postcategory.ExcerptLTE(*i.ExcerptLTE))
	}
	if i.ExcerptContains != nil {
		predicates = append(predicates, postcategory.ExcerptContains(*i.ExcerptContains))
	}
	if i.ExcerptHasPrefix != nil {
		predicates = append(predicates, postcategory.ExcerptHasPrefix(*i.ExcerptHasPrefix))
	}
	if i.ExcerptHasSuffix != nil {
		predicates = append(predicates, postcategory.ExcerptHasSuffix(*i.ExcerptHasSuffix))
	}
	if i.ExcerptIsNil {
		predicates = append(predicates, postcategory.ExcerptIsNil())
	}
	if i.ExcerptNotNil {
		predicates = append(predicates, postcategory.ExcerptNotNil())
	}
	if i.ExcerptEqualFold != nil {
		predicates = append(predicates, postcategory.ExcerptEqualFold(*i.ExcerptEqualFold))
	}
	if i.ExcerptContainsFold != nil {
		predicates = append(predicates, postcategory.ExcerptContainsFold(*i.ExcerptContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, postcategory.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, postcategory.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, postcategory.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, postcategory.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, postcategory.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, postcategory.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, postcategory.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, postcategory.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, postcategory.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, postcategory.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, postcategory.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, postcategory.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, postcategory.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, postcategory.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, postcategory.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.MetaTitle != nil {
		predicates = append(predicates, postcategory.MetaTitleEQ(*i.MetaTitle))
	}
	if i.MetaTitleNEQ != nil {
		predicates = append(predicates, postcategory.MetaTitleNEQ(*i.MetaTitleNEQ))
	}
	if len(i.MetaTitleIn) > 0 {
		predicates = append(predicates, postcategory.MetaTitleIn(i.MetaTitleIn...))
	}
	if len(i.MetaTitleNotIn) > 0 {
		predicates = append(predicates, postcategory.MetaTitleNotIn(i.MetaTitleNotIn...))
	}
	if i.MetaTitleGT != nil {
		predicates = append(predicates, postcategory.MetaTitleGT(*i.MetaTitleGT))
	}
	if i.MetaTitleGTE != nil {
		predicates = append(predicates, postcategory.MetaTitleGTE(*i.MetaTitleGTE))
	}
	if i.MetaTitleLT != nil {
		predicates = append(predicates, postcategory.MetaTitleLT(*i.MetaTitleLT))
	}
	if i.MetaTitleLTE != nil {
		predicates = append(predicates, postcategory.MetaTitleLTE(*i.MetaTitleLTE))
	}
	if i.MetaTitleContains != nil {
		predicates = append(predicates, postcategory.MetaTitleContains(*i.MetaTitleContains))
	}
	if i.MetaTitleHasPrefix != nil {
		predicates = append(predicates, postcategory.MetaTitleHasPrefix(*i.MetaTitleHasPrefix))
	}
	if i.MetaTitleHasSuffix != nil {
		predicates = append(predicates, postcategory.MetaTitleHasSuffix(*i.MetaTitleHasSuffix))
	}
	if i.MetaTitleIsNil {
		predicates = append(predicates, postcategory.MetaTitleIsNil())
	}
	if i.MetaTitleNotNil {
		predicates = append(predicates, postcategory.MetaTitleNotNil())
	}
	if i.MetaTitleEqualFold != nil {
		predicates = append(predicates, postcategory.MetaTitleEqualFold(*i.MetaTitleEqualFold))
	}
	if i.MetaTitleContainsFold != nil {
		predicates = append(predicates, postcategory.MetaTitleContainsFold(*i.MetaTitleContainsFold))
	}
	if i.MetaDescr != nil {
		predicates = append(predicates, postcategory.MetaDescrEQ(*i.MetaDescr))
	}
	if i.MetaDescrNEQ != nil {
		predicates = append(predicates, postcategory.MetaDescrNEQ(*i.MetaDescrNEQ))
	}
	if len(i.MetaDescrIn) > 0 {
		predicates = append(predicates, postcategory.MetaDescrIn(i.MetaDescrIn...))
	}
	if len(i.MetaDescrNotIn) > 0 {
		predicates = append(predicates, postcategory.MetaDescrNotIn(i.MetaDescrNotIn...))
	}
	if i.MetaDescrGT != nil {
		predicates = append(predicates, postcategory.MetaDescrGT(*i.MetaDescrGT))
	}
	if i.MetaDescrGTE != nil {
		predicates = append(predicates, postcategory.MetaDescrGTE(*i.MetaDescrGTE))
	}
	if i.MetaDescrLT != nil {
		predicates = append(predicates, postcategory.MetaDescrLT(*i.MetaDescrLT))
	}
	if i.MetaDescrLTE != nil {
		predicates = append(predicates, postcategory.MetaDescrLTE(*i.MetaDescrLTE))
	}
	if i.MetaDescrContains != nil {
		predicates = append(predicates, postcategory.MetaDescrContains(*i.MetaDescrContains))
	}
	if i.MetaDescrHasPrefix != nil {
		predicates = append(predicates, postcategory.MetaDescrHasPrefix(*i.MetaDescrHasPrefix))
	}
	if i.MetaDescrHasSuffix != nil {
		predicates = append(predicates, postcategory.MetaDescrHasSuffix(*i.MetaDescrHasSuffix))
	}
	if i.MetaDescrIsNil {
		predicates = append(predicates, postcategory.MetaDescrIsNil())
	}
	if i.MetaDescrNotNil {
		predicates = append(predicates, postcategory.MetaDescrNotNil())
	}
	if i.MetaDescrEqualFold != nil {
		predicates = append(predicates, postcategory.MetaDescrEqualFold(*i.MetaDescrEqualFold))
	}
	if i.MetaDescrContainsFold != nil {
		predicates = append(predicates, postcategory.MetaDescrContainsFold(*i.MetaDescrContainsFold))
	}
	if i.MetaCanonicalURL != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLEQ(*i.MetaCanonicalURL))
	}
	if i.MetaCanonicalURLNEQ != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLNEQ(*i.MetaCanonicalURLNEQ))
	}
	if len(i.MetaCanonicalURLIn) > 0 {
		predicates = append(predicates, postcategory.MetaCanonicalURLIn(i.MetaCanonicalURLIn...))
	}
	if len(i.MetaCanonicalURLNotIn) > 0 {
		predicates = append(predicates, postcategory.MetaCanonicalURLNotIn(i.MetaCanonicalURLNotIn...))
	}
	if i.MetaCanonicalURLGT != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLGT(*i.MetaCanonicalURLGT))
	}
	if i.MetaCanonicalURLGTE != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLGTE(*i.MetaCanonicalURLGTE))
	}
	if i.MetaCanonicalURLLT != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLLT(*i.MetaCanonicalURLLT))
	}
	if i.MetaCanonicalURLLTE != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLLTE(*i.MetaCanonicalURLLTE))
	}
	if i.MetaCanonicalURLContains != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLContains(*i.MetaCanonicalURLContains))
	}
	if i.MetaCanonicalURLHasPrefix != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLHasPrefix(*i.MetaCanonicalURLHasPrefix))
	}
	if i.MetaCanonicalURLHasSuffix != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLHasSuffix(*i.MetaCanonicalURLHasSuffix))
	}
	if i.MetaCanonicalURLIsNil {
		predicates = append(predicates, postcategory.MetaCanonicalURLIsNil())
	}
	if i.MetaCanonicalURLNotNil {
		predicates = append(predicates, postcategory.MetaCanonicalURLNotNil())
	}
	if i.MetaCanonicalURLEqualFold != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLEqualFold(*i.MetaCanonicalURLEqualFold))
	}
	if i.MetaCanonicalURLContainsFold != nil {
		predicates = append(predicates, postcategory.MetaCanonicalURLContainsFold(*i.MetaCanonicalURLContainsFold))
	}
	if i.MetaRobots != nil {
		predicates = append(predicates, postcategory.MetaRobotsEQ(*i.MetaRobots))
	}
	if i.MetaRobotsNEQ != nil {
		predicates = append(predicates, postcategory.MetaRobotsNEQ(*i.MetaRobotsNEQ))
	}
	if len(i.MetaRobotsIn) > 0 {
		predicates = append(predicates, postcategory.MetaRobotsIn(i.MetaRobotsIn...))
	}
	if len(i.MetaRobotsNotIn) > 0 {
		predicates = append(predicates, postcategory.MetaRobotsNotIn(i.MetaRobotsNotIn...))
	}
	if i.MetaRobotsGT != nil {
		predicates = append(predicates, postcategory.MetaRobotsGT(*i.MetaRobotsGT))
	}
	if i.MetaRobotsGTE != nil {
		predicates = append(predicates, postcategory.MetaRobotsGTE(*i.MetaRobotsGTE))
	}
	if i.MetaRobotsLT != nil {
		predicates = append(predicates, postcategory.MetaRobotsLT(*i.MetaRobotsLT))
	}
	if i.MetaRobotsLTE != nil {
		predicates = append(predicates, postcategory.MetaRobotsLTE(*i.MetaRobotsLTE))
	}
	if i.MetaRobotsContains != nil {
		predicates = append(predicates, postcategory.MetaRobotsContains(*i.MetaRobotsContains))
	}
	if i.MetaRobotsHasPrefix != nil {
		predicates = append(predicates, postcategory.MetaRobotsHasPrefix(*i.MetaRobotsHasPrefix))
	}
	if i.MetaRobotsHasSuffix != nil {
		predicates = append(predicates, postcategory.MetaRobotsHasSuffix(*i.MetaRobotsHasSuffix))
	}
	if i.MetaRobotsIsNil {
		predicates = append(predicates, postcategory.MetaRobotsIsNil())
	}
	if i.MetaRobotsNotNil {
		predicates = append(predicates, postcategory.MetaRobotsNotNil())
	}
	if i.MetaRobotsEqualFold != nil {
		predicates = append(predicates, postcategory.MetaRobotsEqualFold(*i.MetaRobotsEqualFold))
	}
	if i.MetaRobotsContainsFold != nil {
		predicates = append(predicates, postcategory.MetaRobotsContainsFold(*i.MetaRobotsContainsFold))
	}

	if i.HasPosts != nil {
		p := postcategory.HasPosts()
		if !*i.HasPosts {
			p = postcategory.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostsWith) > 0 {
		with := make([]predicate.Post, 0, len(i.HasPostsWith))
		for _, w := range i.HasPostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, postcategory.HasPostsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostCategoryWhereInput
	case 1:
		return predicates[0], nil
	default:
		return postcategory.And(predicates...), nil
	}
}

// PostStatusWhereInput represents a where input for filtering PostStatus queries.
type PostStatusWhereInput struct {
	Predicates []predicate.PostStatus  `json:"-"`
	Not        *PostStatusWhereInput   `json:"not,omitempty"`
	Or         []*PostStatusWhereInput `json:"or,omitempty"`
	And        []*PostStatusWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status       *bool `json:"status,omitempty"`
	StatusNEQ    *bool `json:"statusNEQ,omitempty"`
	StatusIsNil  bool  `json:"statusIsNil,omitempty"`
	StatusNotNil bool  `json:"statusNotNil,omitempty"`

	// "post_type_id" field predicates.
	PostTypeID             *string  `json:"postTypeID,omitempty"`
	PostTypeIDNEQ          *string  `json:"postTypeIDNEQ,omitempty"`
	PostTypeIDIn           []string `json:"postTypeIDIn,omitempty"`
	PostTypeIDNotIn        []string `json:"postTypeIDNotIn,omitempty"`
	PostTypeIDGT           *string  `json:"postTypeIDGT,omitempty"`
	PostTypeIDGTE          *string  `json:"postTypeIDGTE,omitempty"`
	PostTypeIDLT           *string  `json:"postTypeIDLT,omitempty"`
	PostTypeIDLTE          *string  `json:"postTypeIDLTE,omitempty"`
	PostTypeIDContains     *string  `json:"postTypeIDContains,omitempty"`
	PostTypeIDHasPrefix    *string  `json:"postTypeIDHasPrefix,omitempty"`
	PostTypeIDHasSuffix    *string  `json:"postTypeIDHasSuffix,omitempty"`
	PostTypeIDIsNil        bool     `json:"postTypeIDIsNil,omitempty"`
	PostTypeIDNotNil       bool     `json:"postTypeIDNotNil,omitempty"`
	PostTypeIDEqualFold    *string  `json:"postTypeIDEqualFold,omitempty"`
	PostTypeIDContainsFold *string  `json:"postTypeIDContainsFold,omitempty"`

	// "post_type" edge predicates.
	HasPostType     *bool                 `json:"hasPostType,omitempty"`
	HasPostTypeWith []*PostTypeWhereInput `json:"hasPostTypeWith,omitempty"`

	// "posts" edge predicates.
	HasPosts     *bool             `json:"hasPosts,omitempty"`
	HasPostsWith []*PostWhereInput `json:"hasPostsWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostStatusWhereInput) AddPredicates(predicates ...predicate.PostStatus) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostStatusWhereInput filter on the PostStatusQuery builder.
func (i *PostStatusWhereInput) Filter(q *PostStatusQuery) (*PostStatusQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostStatusWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostStatusWhereInput is returned in case the PostStatusWhereInput is empty.
var ErrEmptyPostStatusWhereInput = errors.New("ent: empty predicate PostStatusWhereInput")

// P returns a predicate for filtering poststatusslice.
// An error is returned if the input is empty or invalid.
func (i *PostStatusWhereInput) P() (predicate.PostStatus, error) {
	var predicates []predicate.PostStatus
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, poststatus.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostStatus, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, poststatus.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostStatus, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, poststatus.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, poststatus.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, poststatus.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, poststatus.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, poststatus.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, poststatus.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, poststatus.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, poststatus.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, poststatus.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, poststatus.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, poststatus.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, poststatus.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, poststatus.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, poststatus.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, poststatus.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, poststatus.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, poststatus.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, poststatus.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, poststatus.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, poststatus.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, poststatus.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, poststatus.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, poststatus.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, poststatus.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, poststatus.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, poststatus.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, poststatus.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, poststatus.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, poststatus.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, poststatus.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, poststatus.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, poststatus.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, poststatus.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, poststatus.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, poststatus.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, poststatus.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, poststatus.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, poststatus.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, poststatus.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, poststatus.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, poststatus.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, poststatus.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, poststatus.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, poststatus.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, poststatus.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, poststatus.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, poststatus.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, poststatus.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, poststatus.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, poststatus.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, poststatus.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, poststatus.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, poststatus.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, poststatus.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, poststatus.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, poststatus.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, poststatus.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, poststatus.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, poststatus.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, poststatus.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, poststatus.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, poststatus.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, poststatus.StatusNEQ(*i.StatusNEQ))
	}
	if i.StatusIsNil {
		predicates = append(predicates, poststatus.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, poststatus.StatusNotNil())
	}
	if i.PostTypeID != nil {
		predicates = append(predicates, poststatus.PostTypeIDEQ(*i.PostTypeID))
	}
	if i.PostTypeIDNEQ != nil {
		predicates = append(predicates, poststatus.PostTypeIDNEQ(*i.PostTypeIDNEQ))
	}
	if len(i.PostTypeIDIn) > 0 {
		predicates = append(predicates, poststatus.PostTypeIDIn(i.PostTypeIDIn...))
	}
	if len(i.PostTypeIDNotIn) > 0 {
		predicates = append(predicates, poststatus.PostTypeIDNotIn(i.PostTypeIDNotIn...))
	}
	if i.PostTypeIDGT != nil {
		predicates = append(predicates, poststatus.PostTypeIDGT(*i.PostTypeIDGT))
	}
	if i.PostTypeIDGTE != nil {
		predicates = append(predicates, poststatus.PostTypeIDGTE(*i.PostTypeIDGTE))
	}
	if i.PostTypeIDLT != nil {
		predicates = append(predicates, poststatus.PostTypeIDLT(*i.PostTypeIDLT))
	}
	if i.PostTypeIDLTE != nil {
		predicates = append(predicates, poststatus.PostTypeIDLTE(*i.PostTypeIDLTE))
	}
	if i.PostTypeIDContains != nil {
		predicates = append(predicates, poststatus.PostTypeIDContains(*i.PostTypeIDContains))
	}
	if i.PostTypeIDHasPrefix != nil {
		predicates = append(predicates, poststatus.PostTypeIDHasPrefix(*i.PostTypeIDHasPrefix))
	}
	if i.PostTypeIDHasSuffix != nil {
		predicates = append(predicates, poststatus.PostTypeIDHasSuffix(*i.PostTypeIDHasSuffix))
	}
	if i.PostTypeIDIsNil {
		predicates = append(predicates, poststatus.PostTypeIDIsNil())
	}
	if i.PostTypeIDNotNil {
		predicates = append(predicates, poststatus.PostTypeIDNotNil())
	}
	if i.PostTypeIDEqualFold != nil {
		predicates = append(predicates, poststatus.PostTypeIDEqualFold(*i.PostTypeIDEqualFold))
	}
	if i.PostTypeIDContainsFold != nil {
		predicates = append(predicates, poststatus.PostTypeIDContainsFold(*i.PostTypeIDContainsFold))
	}

	if i.HasPostType != nil {
		p := poststatus.HasPostType()
		if !*i.HasPostType {
			p = poststatus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostTypeWith) > 0 {
		with := make([]predicate.PostType, 0, len(i.HasPostTypeWith))
		for _, w := range i.HasPostTypeWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostTypeWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, poststatus.HasPostTypeWith(with...))
	}
	if i.HasPosts != nil {
		p := poststatus.HasPosts()
		if !*i.HasPosts {
			p = poststatus.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostsWith) > 0 {
		with := make([]predicate.Post, 0, len(i.HasPostsWith))
		for _, w := range i.HasPostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, poststatus.HasPostsWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostStatusWhereInput
	case 1:
		return predicates[0], nil
	default:
		return poststatus.And(predicates...), nil
	}
}

// PostTagWhereInput represents a where input for filtering PostTag queries.
type PostTagWhereInput struct {
	Predicates []predicate.PostTag  `json:"-"`
	Not        *PostTagWhereInput   `json:"not,omitempty"`
	Or         []*PostTagWhereInput `json:"or,omitempty"`
	And        []*PostTagWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "excerpt" field predicates.
	Excerpt             *string  `json:"excerpt,omitempty"`
	ExcerptNEQ          *string  `json:"excerptNEQ,omitempty"`
	ExcerptIn           []string `json:"excerptIn,omitempty"`
	ExcerptNotIn        []string `json:"excerptNotIn,omitempty"`
	ExcerptGT           *string  `json:"excerptGT,omitempty"`
	ExcerptGTE          *string  `json:"excerptGTE,omitempty"`
	ExcerptLT           *string  `json:"excerptLT,omitempty"`
	ExcerptLTE          *string  `json:"excerptLTE,omitempty"`
	ExcerptContains     *string  `json:"excerptContains,omitempty"`
	ExcerptHasPrefix    *string  `json:"excerptHasPrefix,omitempty"`
	ExcerptHasSuffix    *string  `json:"excerptHasSuffix,omitempty"`
	ExcerptIsNil        bool     `json:"excerptIsNil,omitempty"`
	ExcerptNotNil       bool     `json:"excerptNotNil,omitempty"`
	ExcerptEqualFold    *string  `json:"excerptEqualFold,omitempty"`
	ExcerptContainsFold *string  `json:"excerptContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "meta_title" field predicates.
	MetaTitle             *string  `json:"metaTitle,omitempty"`
	MetaTitleNEQ          *string  `json:"metaTitleNEQ,omitempty"`
	MetaTitleIn           []string `json:"metaTitleIn,omitempty"`
	MetaTitleNotIn        []string `json:"metaTitleNotIn,omitempty"`
	MetaTitleGT           *string  `json:"metaTitleGT,omitempty"`
	MetaTitleGTE          *string  `json:"metaTitleGTE,omitempty"`
	MetaTitleLT           *string  `json:"metaTitleLT,omitempty"`
	MetaTitleLTE          *string  `json:"metaTitleLTE,omitempty"`
	MetaTitleContains     *string  `json:"metaTitleContains,omitempty"`
	MetaTitleHasPrefix    *string  `json:"metaTitleHasPrefix,omitempty"`
	MetaTitleHasSuffix    *string  `json:"metaTitleHasSuffix,omitempty"`
	MetaTitleIsNil        bool     `json:"metaTitleIsNil,omitempty"`
	MetaTitleNotNil       bool     `json:"metaTitleNotNil,omitempty"`
	MetaTitleEqualFold    *string  `json:"metaTitleEqualFold,omitempty"`
	MetaTitleContainsFold *string  `json:"metaTitleContainsFold,omitempty"`

	// "meta_descr" field predicates.
	MetaDescr             *string  `json:"metaDescr,omitempty"`
	MetaDescrNEQ          *string  `json:"metaDescrNEQ,omitempty"`
	MetaDescrIn           []string `json:"metaDescrIn,omitempty"`
	MetaDescrNotIn        []string `json:"metaDescrNotIn,omitempty"`
	MetaDescrGT           *string  `json:"metaDescrGT,omitempty"`
	MetaDescrGTE          *string  `json:"metaDescrGTE,omitempty"`
	MetaDescrLT           *string  `json:"metaDescrLT,omitempty"`
	MetaDescrLTE          *string  `json:"metaDescrLTE,omitempty"`
	MetaDescrContains     *string  `json:"metaDescrContains,omitempty"`
	MetaDescrHasPrefix    *string  `json:"metaDescrHasPrefix,omitempty"`
	MetaDescrHasSuffix    *string  `json:"metaDescrHasSuffix,omitempty"`
	MetaDescrIsNil        bool     `json:"metaDescrIsNil,omitempty"`
	MetaDescrNotNil       bool     `json:"metaDescrNotNil,omitempty"`
	MetaDescrEqualFold    *string  `json:"metaDescrEqualFold,omitempty"`
	MetaDescrContainsFold *string  `json:"metaDescrContainsFold,omitempty"`

	// "meta_canonical_url" field predicates.
	MetaCanonicalURL             *string  `json:"metaCanonicalURL,omitempty"`
	MetaCanonicalURLNEQ          *string  `json:"metaCanonicalURLNEQ,omitempty"`
	MetaCanonicalURLIn           []string `json:"metaCanonicalURLIn,omitempty"`
	MetaCanonicalURLNotIn        []string `json:"metaCanonicalURLNotIn,omitempty"`
	MetaCanonicalURLGT           *string  `json:"metaCanonicalURLGT,omitempty"`
	MetaCanonicalURLGTE          *string  `json:"metaCanonicalURLGTE,omitempty"`
	MetaCanonicalURLLT           *string  `json:"metaCanonicalURLLT,omitempty"`
	MetaCanonicalURLLTE          *string  `json:"metaCanonicalURLLTE,omitempty"`
	MetaCanonicalURLContains     *string  `json:"metaCanonicalURLContains,omitempty"`
	MetaCanonicalURLHasPrefix    *string  `json:"metaCanonicalURLHasPrefix,omitempty"`
	MetaCanonicalURLHasSuffix    *string  `json:"metaCanonicalURLHasSuffix,omitempty"`
	MetaCanonicalURLIsNil        bool     `json:"metaCanonicalURLIsNil,omitempty"`
	MetaCanonicalURLNotNil       bool     `json:"metaCanonicalURLNotNil,omitempty"`
	MetaCanonicalURLEqualFold    *string  `json:"metaCanonicalURLEqualFold,omitempty"`
	MetaCanonicalURLContainsFold *string  `json:"metaCanonicalURLContainsFold,omitempty"`

	// "meta_robots" field predicates.
	MetaRobots             *string  `json:"metaRobots,omitempty"`
	MetaRobotsNEQ          *string  `json:"metaRobotsNEQ,omitempty"`
	MetaRobotsIn           []string `json:"metaRobotsIn,omitempty"`
	MetaRobotsNotIn        []string `json:"metaRobotsNotIn,omitempty"`
	MetaRobotsGT           *string  `json:"metaRobotsGT,omitempty"`
	MetaRobotsGTE          *string  `json:"metaRobotsGTE,omitempty"`
	MetaRobotsLT           *string  `json:"metaRobotsLT,omitempty"`
	MetaRobotsLTE          *string  `json:"metaRobotsLTE,omitempty"`
	MetaRobotsContains     *string  `json:"metaRobotsContains,omitempty"`
	MetaRobotsHasPrefix    *string  `json:"metaRobotsHasPrefix,omitempty"`
	MetaRobotsHasSuffix    *string  `json:"metaRobotsHasSuffix,omitempty"`
	MetaRobotsIsNil        bool     `json:"metaRobotsIsNil,omitempty"`
	MetaRobotsNotNil       bool     `json:"metaRobotsNotNil,omitempty"`
	MetaRobotsEqualFold    *string  `json:"metaRobotsEqualFold,omitempty"`
	MetaRobotsContainsFold *string  `json:"metaRobotsContainsFold,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostTagWhereInput) AddPredicates(predicates ...predicate.PostTag) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostTagWhereInput filter on the PostTagQuery builder.
func (i *PostTagWhereInput) Filter(q *PostTagQuery) (*PostTagQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostTagWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostTagWhereInput is returned in case the PostTagWhereInput is empty.
var ErrEmptyPostTagWhereInput = errors.New("ent: empty predicate PostTagWhereInput")

// P returns a predicate for filtering posttags.
// An error is returned if the input is empty or invalid.
func (i *PostTagWhereInput) P() (predicate.PostTag, error) {
	var predicates []predicate.PostTag
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, posttag.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostTag, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, posttag.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostTag, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, posttag.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, posttag.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, posttag.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, posttag.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, posttag.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, posttag.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, posttag.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, posttag.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, posttag.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, posttag.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, posttag.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, posttag.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, posttag.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, posttag.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, posttag.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, posttag.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, posttag.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, posttag.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, posttag.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, posttag.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, posttag.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, posttag.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, posttag.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, posttag.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, posttag.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, posttag.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, posttag.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, posttag.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, posttag.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, posttag.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, posttag.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, posttag.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, posttag.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, posttag.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, posttag.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, posttag.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, posttag.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, posttag.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, posttag.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, posttag.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, posttag.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, posttag.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, posttag.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, posttag.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, posttag.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, posttag.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, posttag.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, posttag.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, posttag.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, posttag.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, posttag.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, posttag.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, posttag.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, posttag.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, posttag.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, posttag.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, posttag.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, posttag.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, posttag.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, posttag.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, posttag.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, posttag.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, posttag.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, posttag.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, posttag.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, posttag.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, posttag.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, posttag.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, posttag.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, posttag.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, posttag.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, posttag.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, posttag.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, posttag.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, posttag.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, posttag.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.Excerpt != nil {
		predicates = append(predicates, posttag.ExcerptEQ(*i.Excerpt))
	}
	if i.ExcerptNEQ != nil {
		predicates = append(predicates, posttag.ExcerptNEQ(*i.ExcerptNEQ))
	}
	if len(i.ExcerptIn) > 0 {
		predicates = append(predicates, posttag.ExcerptIn(i.ExcerptIn...))
	}
	if len(i.ExcerptNotIn) > 0 {
		predicates = append(predicates, posttag.ExcerptNotIn(i.ExcerptNotIn...))
	}
	if i.ExcerptGT != nil {
		predicates = append(predicates, posttag.ExcerptGT(*i.ExcerptGT))
	}
	if i.ExcerptGTE != nil {
		predicates = append(predicates, posttag.ExcerptGTE(*i.ExcerptGTE))
	}
	if i.ExcerptLT != nil {
		predicates = append(predicates, posttag.ExcerptLT(*i.ExcerptLT))
	}
	if i.ExcerptLTE != nil {
		predicates = append(predicates, posttag.ExcerptLTE(*i.ExcerptLTE))
	}
	if i.ExcerptContains != nil {
		predicates = append(predicates, posttag.ExcerptContains(*i.ExcerptContains))
	}
	if i.ExcerptHasPrefix != nil {
		predicates = append(predicates, posttag.ExcerptHasPrefix(*i.ExcerptHasPrefix))
	}
	if i.ExcerptHasSuffix != nil {
		predicates = append(predicates, posttag.ExcerptHasSuffix(*i.ExcerptHasSuffix))
	}
	if i.ExcerptIsNil {
		predicates = append(predicates, posttag.ExcerptIsNil())
	}
	if i.ExcerptNotNil {
		predicates = append(predicates, posttag.ExcerptNotNil())
	}
	if i.ExcerptEqualFold != nil {
		predicates = append(predicates, posttag.ExcerptEqualFold(*i.ExcerptEqualFold))
	}
	if i.ExcerptContainsFold != nil {
		predicates = append(predicates, posttag.ExcerptContainsFold(*i.ExcerptContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, posttag.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, posttag.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, posttag.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, posttag.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, posttag.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, posttag.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, posttag.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, posttag.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, posttag.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, posttag.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, posttag.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, posttag.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, posttag.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, posttag.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, posttag.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.MetaTitle != nil {
		predicates = append(predicates, posttag.MetaTitleEQ(*i.MetaTitle))
	}
	if i.MetaTitleNEQ != nil {
		predicates = append(predicates, posttag.MetaTitleNEQ(*i.MetaTitleNEQ))
	}
	if len(i.MetaTitleIn) > 0 {
		predicates = append(predicates, posttag.MetaTitleIn(i.MetaTitleIn...))
	}
	if len(i.MetaTitleNotIn) > 0 {
		predicates = append(predicates, posttag.MetaTitleNotIn(i.MetaTitleNotIn...))
	}
	if i.MetaTitleGT != nil {
		predicates = append(predicates, posttag.MetaTitleGT(*i.MetaTitleGT))
	}
	if i.MetaTitleGTE != nil {
		predicates = append(predicates, posttag.MetaTitleGTE(*i.MetaTitleGTE))
	}
	if i.MetaTitleLT != nil {
		predicates = append(predicates, posttag.MetaTitleLT(*i.MetaTitleLT))
	}
	if i.MetaTitleLTE != nil {
		predicates = append(predicates, posttag.MetaTitleLTE(*i.MetaTitleLTE))
	}
	if i.MetaTitleContains != nil {
		predicates = append(predicates, posttag.MetaTitleContains(*i.MetaTitleContains))
	}
	if i.MetaTitleHasPrefix != nil {
		predicates = append(predicates, posttag.MetaTitleHasPrefix(*i.MetaTitleHasPrefix))
	}
	if i.MetaTitleHasSuffix != nil {
		predicates = append(predicates, posttag.MetaTitleHasSuffix(*i.MetaTitleHasSuffix))
	}
	if i.MetaTitleIsNil {
		predicates = append(predicates, posttag.MetaTitleIsNil())
	}
	if i.MetaTitleNotNil {
		predicates = append(predicates, posttag.MetaTitleNotNil())
	}
	if i.MetaTitleEqualFold != nil {
		predicates = append(predicates, posttag.MetaTitleEqualFold(*i.MetaTitleEqualFold))
	}
	if i.MetaTitleContainsFold != nil {
		predicates = append(predicates, posttag.MetaTitleContainsFold(*i.MetaTitleContainsFold))
	}
	if i.MetaDescr != nil {
		predicates = append(predicates, posttag.MetaDescrEQ(*i.MetaDescr))
	}
	if i.MetaDescrNEQ != nil {
		predicates = append(predicates, posttag.MetaDescrNEQ(*i.MetaDescrNEQ))
	}
	if len(i.MetaDescrIn) > 0 {
		predicates = append(predicates, posttag.MetaDescrIn(i.MetaDescrIn...))
	}
	if len(i.MetaDescrNotIn) > 0 {
		predicates = append(predicates, posttag.MetaDescrNotIn(i.MetaDescrNotIn...))
	}
	if i.MetaDescrGT != nil {
		predicates = append(predicates, posttag.MetaDescrGT(*i.MetaDescrGT))
	}
	if i.MetaDescrGTE != nil {
		predicates = append(predicates, posttag.MetaDescrGTE(*i.MetaDescrGTE))
	}
	if i.MetaDescrLT != nil {
		predicates = append(predicates, posttag.MetaDescrLT(*i.MetaDescrLT))
	}
	if i.MetaDescrLTE != nil {
		predicates = append(predicates, posttag.MetaDescrLTE(*i.MetaDescrLTE))
	}
	if i.MetaDescrContains != nil {
		predicates = append(predicates, posttag.MetaDescrContains(*i.MetaDescrContains))
	}
	if i.MetaDescrHasPrefix != nil {
		predicates = append(predicates, posttag.MetaDescrHasPrefix(*i.MetaDescrHasPrefix))
	}
	if i.MetaDescrHasSuffix != nil {
		predicates = append(predicates, posttag.MetaDescrHasSuffix(*i.MetaDescrHasSuffix))
	}
	if i.MetaDescrIsNil {
		predicates = append(predicates, posttag.MetaDescrIsNil())
	}
	if i.MetaDescrNotNil {
		predicates = append(predicates, posttag.MetaDescrNotNil())
	}
	if i.MetaDescrEqualFold != nil {
		predicates = append(predicates, posttag.MetaDescrEqualFold(*i.MetaDescrEqualFold))
	}
	if i.MetaDescrContainsFold != nil {
		predicates = append(predicates, posttag.MetaDescrContainsFold(*i.MetaDescrContainsFold))
	}
	if i.MetaCanonicalURL != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLEQ(*i.MetaCanonicalURL))
	}
	if i.MetaCanonicalURLNEQ != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLNEQ(*i.MetaCanonicalURLNEQ))
	}
	if len(i.MetaCanonicalURLIn) > 0 {
		predicates = append(predicates, posttag.MetaCanonicalURLIn(i.MetaCanonicalURLIn...))
	}
	if len(i.MetaCanonicalURLNotIn) > 0 {
		predicates = append(predicates, posttag.MetaCanonicalURLNotIn(i.MetaCanonicalURLNotIn...))
	}
	if i.MetaCanonicalURLGT != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLGT(*i.MetaCanonicalURLGT))
	}
	if i.MetaCanonicalURLGTE != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLGTE(*i.MetaCanonicalURLGTE))
	}
	if i.MetaCanonicalURLLT != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLLT(*i.MetaCanonicalURLLT))
	}
	if i.MetaCanonicalURLLTE != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLLTE(*i.MetaCanonicalURLLTE))
	}
	if i.MetaCanonicalURLContains != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLContains(*i.MetaCanonicalURLContains))
	}
	if i.MetaCanonicalURLHasPrefix != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLHasPrefix(*i.MetaCanonicalURLHasPrefix))
	}
	if i.MetaCanonicalURLHasSuffix != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLHasSuffix(*i.MetaCanonicalURLHasSuffix))
	}
	if i.MetaCanonicalURLIsNil {
		predicates = append(predicates, posttag.MetaCanonicalURLIsNil())
	}
	if i.MetaCanonicalURLNotNil {
		predicates = append(predicates, posttag.MetaCanonicalURLNotNil())
	}
	if i.MetaCanonicalURLEqualFold != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLEqualFold(*i.MetaCanonicalURLEqualFold))
	}
	if i.MetaCanonicalURLContainsFold != nil {
		predicates = append(predicates, posttag.MetaCanonicalURLContainsFold(*i.MetaCanonicalURLContainsFold))
	}
	if i.MetaRobots != nil {
		predicates = append(predicates, posttag.MetaRobotsEQ(*i.MetaRobots))
	}
	if i.MetaRobotsNEQ != nil {
		predicates = append(predicates, posttag.MetaRobotsNEQ(*i.MetaRobotsNEQ))
	}
	if len(i.MetaRobotsIn) > 0 {
		predicates = append(predicates, posttag.MetaRobotsIn(i.MetaRobotsIn...))
	}
	if len(i.MetaRobotsNotIn) > 0 {
		predicates = append(predicates, posttag.MetaRobotsNotIn(i.MetaRobotsNotIn...))
	}
	if i.MetaRobotsGT != nil {
		predicates = append(predicates, posttag.MetaRobotsGT(*i.MetaRobotsGT))
	}
	if i.MetaRobotsGTE != nil {
		predicates = append(predicates, posttag.MetaRobotsGTE(*i.MetaRobotsGTE))
	}
	if i.MetaRobotsLT != nil {
		predicates = append(predicates, posttag.MetaRobotsLT(*i.MetaRobotsLT))
	}
	if i.MetaRobotsLTE != nil {
		predicates = append(predicates, posttag.MetaRobotsLTE(*i.MetaRobotsLTE))
	}
	if i.MetaRobotsContains != nil {
		predicates = append(predicates, posttag.MetaRobotsContains(*i.MetaRobotsContains))
	}
	if i.MetaRobotsHasPrefix != nil {
		predicates = append(predicates, posttag.MetaRobotsHasPrefix(*i.MetaRobotsHasPrefix))
	}
	if i.MetaRobotsHasSuffix != nil {
		predicates = append(predicates, posttag.MetaRobotsHasSuffix(*i.MetaRobotsHasSuffix))
	}
	if i.MetaRobotsIsNil {
		predicates = append(predicates, posttag.MetaRobotsIsNil())
	}
	if i.MetaRobotsNotNil {
		predicates = append(predicates, posttag.MetaRobotsNotNil())
	}
	if i.MetaRobotsEqualFold != nil {
		predicates = append(predicates, posttag.MetaRobotsEqualFold(*i.MetaRobotsEqualFold))
	}
	if i.MetaRobotsContainsFold != nil {
		predicates = append(predicates, posttag.MetaRobotsContainsFold(*i.MetaRobotsContainsFold))
	}

	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostTagWhereInput
	case 1:
		return predicates[0], nil
	default:
		return posttag.And(predicates...), nil
	}
}

// PostTypeWhereInput represents a where input for filtering PostType queries.
type PostTypeWhereInput struct {
	Predicates []predicate.PostType  `json:"-"`
	Not        *PostTypeWhereInput   `json:"not,omitempty"`
	Or         []*PostTypeWhereInput `json:"or,omitempty"`
	And        []*PostTypeWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "slug" field predicates.
	Slug             *string  `json:"slug,omitempty"`
	SlugNEQ          *string  `json:"slugNEQ,omitempty"`
	SlugIn           []string `json:"slugIn,omitempty"`
	SlugNotIn        []string `json:"slugNotIn,omitempty"`
	SlugGT           *string  `json:"slugGT,omitempty"`
	SlugGTE          *string  `json:"slugGTE,omitempty"`
	SlugLT           *string  `json:"slugLT,omitempty"`
	SlugLTE          *string  `json:"slugLTE,omitempty"`
	SlugContains     *string  `json:"slugContains,omitempty"`
	SlugHasPrefix    *string  `json:"slugHasPrefix,omitempty"`
	SlugHasSuffix    *string  `json:"slugHasSuffix,omitempty"`
	SlugIsNil        bool     `json:"slugIsNil,omitempty"`
	SlugNotNil       bool     `json:"slugNotNil,omitempty"`
	SlugEqualFold    *string  `json:"slugEqualFold,omitempty"`
	SlugContainsFold *string  `json:"slugContainsFold,omitempty"`

	// "status" field predicates.
	Status             *string  `json:"status,omitempty"`
	StatusNEQ          *string  `json:"statusNEQ,omitempty"`
	StatusIn           []string `json:"statusIn,omitempty"`
	StatusNotIn        []string `json:"statusNotIn,omitempty"`
	StatusGT           *string  `json:"statusGT,omitempty"`
	StatusGTE          *string  `json:"statusGTE,omitempty"`
	StatusLT           *string  `json:"statusLT,omitempty"`
	StatusLTE          *string  `json:"statusLTE,omitempty"`
	StatusContains     *string  `json:"statusContains,omitempty"`
	StatusHasPrefix    *string  `json:"statusHasPrefix,omitempty"`
	StatusHasSuffix    *string  `json:"statusHasSuffix,omitempty"`
	StatusIsNil        bool     `json:"statusIsNil,omitempty"`
	StatusNotNil       bool     `json:"statusNotNil,omitempty"`
	StatusEqualFold    *string  `json:"statusEqualFold,omitempty"`
	StatusContainsFold *string  `json:"statusContainsFold,omitempty"`

	// "excerpt" field predicates.
	Excerpt             *string  `json:"excerpt,omitempty"`
	ExcerptNEQ          *string  `json:"excerptNEQ,omitempty"`
	ExcerptIn           []string `json:"excerptIn,omitempty"`
	ExcerptNotIn        []string `json:"excerptNotIn,omitempty"`
	ExcerptGT           *string  `json:"excerptGT,omitempty"`
	ExcerptGTE          *string  `json:"excerptGTE,omitempty"`
	ExcerptLT           *string  `json:"excerptLT,omitempty"`
	ExcerptLTE          *string  `json:"excerptLTE,omitempty"`
	ExcerptContains     *string  `json:"excerptContains,omitempty"`
	ExcerptHasPrefix    *string  `json:"excerptHasPrefix,omitempty"`
	ExcerptHasSuffix    *string  `json:"excerptHasSuffix,omitempty"`
	ExcerptIsNil        bool     `json:"excerptIsNil,omitempty"`
	ExcerptNotNil       bool     `json:"excerptNotNil,omitempty"`
	ExcerptEqualFold    *string  `json:"excerptEqualFold,omitempty"`
	ExcerptContainsFold *string  `json:"excerptContainsFold,omitempty"`

	// "content" field predicates.
	Content             *string  `json:"content,omitempty"`
	ContentNEQ          *string  `json:"contentNEQ,omitempty"`
	ContentIn           []string `json:"contentIn,omitempty"`
	ContentNotIn        []string `json:"contentNotIn,omitempty"`
	ContentGT           *string  `json:"contentGT,omitempty"`
	ContentGTE          *string  `json:"contentGTE,omitempty"`
	ContentLT           *string  `json:"contentLT,omitempty"`
	ContentLTE          *string  `json:"contentLTE,omitempty"`
	ContentContains     *string  `json:"contentContains,omitempty"`
	ContentHasPrefix    *string  `json:"contentHasPrefix,omitempty"`
	ContentHasSuffix    *string  `json:"contentHasSuffix,omitempty"`
	ContentIsNil        bool     `json:"contentIsNil,omitempty"`
	ContentNotNil       bool     `json:"contentNotNil,omitempty"`
	ContentEqualFold    *string  `json:"contentEqualFold,omitempty"`
	ContentContainsFold *string  `json:"contentContainsFold,omitempty"`

	// "meta_title" field predicates.
	MetaTitle             *string  `json:"metaTitle,omitempty"`
	MetaTitleNEQ          *string  `json:"metaTitleNEQ,omitempty"`
	MetaTitleIn           []string `json:"metaTitleIn,omitempty"`
	MetaTitleNotIn        []string `json:"metaTitleNotIn,omitempty"`
	MetaTitleGT           *string  `json:"metaTitleGT,omitempty"`
	MetaTitleGTE          *string  `json:"metaTitleGTE,omitempty"`
	MetaTitleLT           *string  `json:"metaTitleLT,omitempty"`
	MetaTitleLTE          *string  `json:"metaTitleLTE,omitempty"`
	MetaTitleContains     *string  `json:"metaTitleContains,omitempty"`
	MetaTitleHasPrefix    *string  `json:"metaTitleHasPrefix,omitempty"`
	MetaTitleHasSuffix    *string  `json:"metaTitleHasSuffix,omitempty"`
	MetaTitleIsNil        bool     `json:"metaTitleIsNil,omitempty"`
	MetaTitleNotNil       bool     `json:"metaTitleNotNil,omitempty"`
	MetaTitleEqualFold    *string  `json:"metaTitleEqualFold,omitempty"`
	MetaTitleContainsFold *string  `json:"metaTitleContainsFold,omitempty"`

	// "meta_descr" field predicates.
	MetaDescr             *string  `json:"metaDescr,omitempty"`
	MetaDescrNEQ          *string  `json:"metaDescrNEQ,omitempty"`
	MetaDescrIn           []string `json:"metaDescrIn,omitempty"`
	MetaDescrNotIn        []string `json:"metaDescrNotIn,omitempty"`
	MetaDescrGT           *string  `json:"metaDescrGT,omitempty"`
	MetaDescrGTE          *string  `json:"metaDescrGTE,omitempty"`
	MetaDescrLT           *string  `json:"metaDescrLT,omitempty"`
	MetaDescrLTE          *string  `json:"metaDescrLTE,omitempty"`
	MetaDescrContains     *string  `json:"metaDescrContains,omitempty"`
	MetaDescrHasPrefix    *string  `json:"metaDescrHasPrefix,omitempty"`
	MetaDescrHasSuffix    *string  `json:"metaDescrHasSuffix,omitempty"`
	MetaDescrIsNil        bool     `json:"metaDescrIsNil,omitempty"`
	MetaDescrNotNil       bool     `json:"metaDescrNotNil,omitempty"`
	MetaDescrEqualFold    *string  `json:"metaDescrEqualFold,omitempty"`
	MetaDescrContainsFold *string  `json:"metaDescrContainsFold,omitempty"`

	// "meta_canonical_url" field predicates.
	MetaCanonicalURL             *string  `json:"metaCanonicalURL,omitempty"`
	MetaCanonicalURLNEQ          *string  `json:"metaCanonicalURLNEQ,omitempty"`
	MetaCanonicalURLIn           []string `json:"metaCanonicalURLIn,omitempty"`
	MetaCanonicalURLNotIn        []string `json:"metaCanonicalURLNotIn,omitempty"`
	MetaCanonicalURLGT           *string  `json:"metaCanonicalURLGT,omitempty"`
	MetaCanonicalURLGTE          *string  `json:"metaCanonicalURLGTE,omitempty"`
	MetaCanonicalURLLT           *string  `json:"metaCanonicalURLLT,omitempty"`
	MetaCanonicalURLLTE          *string  `json:"metaCanonicalURLLTE,omitempty"`
	MetaCanonicalURLContains     *string  `json:"metaCanonicalURLContains,omitempty"`
	MetaCanonicalURLHasPrefix    *string  `json:"metaCanonicalURLHasPrefix,omitempty"`
	MetaCanonicalURLHasSuffix    *string  `json:"metaCanonicalURLHasSuffix,omitempty"`
	MetaCanonicalURLIsNil        bool     `json:"metaCanonicalURLIsNil,omitempty"`
	MetaCanonicalURLNotNil       bool     `json:"metaCanonicalURLNotNil,omitempty"`
	MetaCanonicalURLEqualFold    *string  `json:"metaCanonicalURLEqualFold,omitempty"`
	MetaCanonicalURLContainsFold *string  `json:"metaCanonicalURLContainsFold,omitempty"`

	// "meta_robots" field predicates.
	MetaRobots             *string  `json:"metaRobots,omitempty"`
	MetaRobotsNEQ          *string  `json:"metaRobotsNEQ,omitempty"`
	MetaRobotsIn           []string `json:"metaRobotsIn,omitempty"`
	MetaRobotsNotIn        []string `json:"metaRobotsNotIn,omitempty"`
	MetaRobotsGT           *string  `json:"metaRobotsGT,omitempty"`
	MetaRobotsGTE          *string  `json:"metaRobotsGTE,omitempty"`
	MetaRobotsLT           *string  `json:"metaRobotsLT,omitempty"`
	MetaRobotsLTE          *string  `json:"metaRobotsLTE,omitempty"`
	MetaRobotsContains     *string  `json:"metaRobotsContains,omitempty"`
	MetaRobotsHasPrefix    *string  `json:"metaRobotsHasPrefix,omitempty"`
	MetaRobotsHasSuffix    *string  `json:"metaRobotsHasSuffix,omitempty"`
	MetaRobotsIsNil        bool     `json:"metaRobotsIsNil,omitempty"`
	MetaRobotsNotNil       bool     `json:"metaRobotsNotNil,omitempty"`
	MetaRobotsEqualFold    *string  `json:"metaRobotsEqualFold,omitempty"`
	MetaRobotsContainsFold *string  `json:"metaRobotsContainsFold,omitempty"`

	// "posts" edge predicates.
	HasPosts     *bool             `json:"hasPosts,omitempty"`
	HasPostsWith []*PostWhereInput `json:"hasPostsWith,omitempty"`

	// "post_statuses" edge predicates.
	HasPostStatuses     *bool                   `json:"hasPostStatuses,omitempty"`
	HasPostStatusesWith []*PostStatusWhereInput `json:"hasPostStatusesWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *PostTypeWhereInput) AddPredicates(predicates ...predicate.PostType) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the PostTypeWhereInput filter on the PostTypeQuery builder.
func (i *PostTypeWhereInput) Filter(q *PostTypeQuery) (*PostTypeQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyPostTypeWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyPostTypeWhereInput is returned in case the PostTypeWhereInput is empty.
var ErrEmptyPostTypeWhereInput = errors.New("ent: empty predicate PostTypeWhereInput")

// P returns a predicate for filtering posttypes.
// An error is returned if the input is empty or invalid.
func (i *PostTypeWhereInput) P() (predicate.PostType, error) {
	var predicates []predicate.PostType
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, posttype.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.PostType, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, posttype.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.PostType, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, posttype.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, posttype.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, posttype.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, posttype.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, posttype.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, posttype.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, posttype.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, posttype.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, posttype.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, posttype.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, posttype.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, posttype.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, posttype.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, posttype.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, posttype.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, posttype.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, posttype.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, posttype.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, posttype.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, posttype.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, posttype.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, posttype.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, posttype.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, posttype.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, posttype.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, posttype.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, posttype.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, posttype.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, posttype.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, posttype.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, posttype.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, posttype.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, posttype.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, posttype.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, posttype.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, posttype.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, posttype.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, posttype.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, posttype.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, posttype.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, posttype.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, posttype.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, posttype.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, posttype.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, posttype.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, posttype.NameContainsFold(*i.NameContainsFold))
	}
	if i.Slug != nil {
		predicates = append(predicates, posttype.SlugEQ(*i.Slug))
	}
	if i.SlugNEQ != nil {
		predicates = append(predicates, posttype.SlugNEQ(*i.SlugNEQ))
	}
	if len(i.SlugIn) > 0 {
		predicates = append(predicates, posttype.SlugIn(i.SlugIn...))
	}
	if len(i.SlugNotIn) > 0 {
		predicates = append(predicates, posttype.SlugNotIn(i.SlugNotIn...))
	}
	if i.SlugGT != nil {
		predicates = append(predicates, posttype.SlugGT(*i.SlugGT))
	}
	if i.SlugGTE != nil {
		predicates = append(predicates, posttype.SlugGTE(*i.SlugGTE))
	}
	if i.SlugLT != nil {
		predicates = append(predicates, posttype.SlugLT(*i.SlugLT))
	}
	if i.SlugLTE != nil {
		predicates = append(predicates, posttype.SlugLTE(*i.SlugLTE))
	}
	if i.SlugContains != nil {
		predicates = append(predicates, posttype.SlugContains(*i.SlugContains))
	}
	if i.SlugHasPrefix != nil {
		predicates = append(predicates, posttype.SlugHasPrefix(*i.SlugHasPrefix))
	}
	if i.SlugHasSuffix != nil {
		predicates = append(predicates, posttype.SlugHasSuffix(*i.SlugHasSuffix))
	}
	if i.SlugIsNil {
		predicates = append(predicates, posttype.SlugIsNil())
	}
	if i.SlugNotNil {
		predicates = append(predicates, posttype.SlugNotNil())
	}
	if i.SlugEqualFold != nil {
		predicates = append(predicates, posttype.SlugEqualFold(*i.SlugEqualFold))
	}
	if i.SlugContainsFold != nil {
		predicates = append(predicates, posttype.SlugContainsFold(*i.SlugContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, posttype.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, posttype.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, posttype.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, posttype.StatusNotIn(i.StatusNotIn...))
	}
	if i.StatusGT != nil {
		predicates = append(predicates, posttype.StatusGT(*i.StatusGT))
	}
	if i.StatusGTE != nil {
		predicates = append(predicates, posttype.StatusGTE(*i.StatusGTE))
	}
	if i.StatusLT != nil {
		predicates = append(predicates, posttype.StatusLT(*i.StatusLT))
	}
	if i.StatusLTE != nil {
		predicates = append(predicates, posttype.StatusLTE(*i.StatusLTE))
	}
	if i.StatusContains != nil {
		predicates = append(predicates, posttype.StatusContains(*i.StatusContains))
	}
	if i.StatusHasPrefix != nil {
		predicates = append(predicates, posttype.StatusHasPrefix(*i.StatusHasPrefix))
	}
	if i.StatusHasSuffix != nil {
		predicates = append(predicates, posttype.StatusHasSuffix(*i.StatusHasSuffix))
	}
	if i.StatusIsNil {
		predicates = append(predicates, posttype.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, posttype.StatusNotNil())
	}
	if i.StatusEqualFold != nil {
		predicates = append(predicates, posttype.StatusEqualFold(*i.StatusEqualFold))
	}
	if i.StatusContainsFold != nil {
		predicates = append(predicates, posttype.StatusContainsFold(*i.StatusContainsFold))
	}
	if i.Excerpt != nil {
		predicates = append(predicates, posttype.ExcerptEQ(*i.Excerpt))
	}
	if i.ExcerptNEQ != nil {
		predicates = append(predicates, posttype.ExcerptNEQ(*i.ExcerptNEQ))
	}
	if len(i.ExcerptIn) > 0 {
		predicates = append(predicates, posttype.ExcerptIn(i.ExcerptIn...))
	}
	if len(i.ExcerptNotIn) > 0 {
		predicates = append(predicates, posttype.ExcerptNotIn(i.ExcerptNotIn...))
	}
	if i.ExcerptGT != nil {
		predicates = append(predicates, posttype.ExcerptGT(*i.ExcerptGT))
	}
	if i.ExcerptGTE != nil {
		predicates = append(predicates, posttype.ExcerptGTE(*i.ExcerptGTE))
	}
	if i.ExcerptLT != nil {
		predicates = append(predicates, posttype.ExcerptLT(*i.ExcerptLT))
	}
	if i.ExcerptLTE != nil {
		predicates = append(predicates, posttype.ExcerptLTE(*i.ExcerptLTE))
	}
	if i.ExcerptContains != nil {
		predicates = append(predicates, posttype.ExcerptContains(*i.ExcerptContains))
	}
	if i.ExcerptHasPrefix != nil {
		predicates = append(predicates, posttype.ExcerptHasPrefix(*i.ExcerptHasPrefix))
	}
	if i.ExcerptHasSuffix != nil {
		predicates = append(predicates, posttype.ExcerptHasSuffix(*i.ExcerptHasSuffix))
	}
	if i.ExcerptIsNil {
		predicates = append(predicates, posttype.ExcerptIsNil())
	}
	if i.ExcerptNotNil {
		predicates = append(predicates, posttype.ExcerptNotNil())
	}
	if i.ExcerptEqualFold != nil {
		predicates = append(predicates, posttype.ExcerptEqualFold(*i.ExcerptEqualFold))
	}
	if i.ExcerptContainsFold != nil {
		predicates = append(predicates, posttype.ExcerptContainsFold(*i.ExcerptContainsFold))
	}
	if i.Content != nil {
		predicates = append(predicates, posttype.ContentEQ(*i.Content))
	}
	if i.ContentNEQ != nil {
		predicates = append(predicates, posttype.ContentNEQ(*i.ContentNEQ))
	}
	if len(i.ContentIn) > 0 {
		predicates = append(predicates, posttype.ContentIn(i.ContentIn...))
	}
	if len(i.ContentNotIn) > 0 {
		predicates = append(predicates, posttype.ContentNotIn(i.ContentNotIn...))
	}
	if i.ContentGT != nil {
		predicates = append(predicates, posttype.ContentGT(*i.ContentGT))
	}
	if i.ContentGTE != nil {
		predicates = append(predicates, posttype.ContentGTE(*i.ContentGTE))
	}
	if i.ContentLT != nil {
		predicates = append(predicates, posttype.ContentLT(*i.ContentLT))
	}
	if i.ContentLTE != nil {
		predicates = append(predicates, posttype.ContentLTE(*i.ContentLTE))
	}
	if i.ContentContains != nil {
		predicates = append(predicates, posttype.ContentContains(*i.ContentContains))
	}
	if i.ContentHasPrefix != nil {
		predicates = append(predicates, posttype.ContentHasPrefix(*i.ContentHasPrefix))
	}
	if i.ContentHasSuffix != nil {
		predicates = append(predicates, posttype.ContentHasSuffix(*i.ContentHasSuffix))
	}
	if i.ContentIsNil {
		predicates = append(predicates, posttype.ContentIsNil())
	}
	if i.ContentNotNil {
		predicates = append(predicates, posttype.ContentNotNil())
	}
	if i.ContentEqualFold != nil {
		predicates = append(predicates, posttype.ContentEqualFold(*i.ContentEqualFold))
	}
	if i.ContentContainsFold != nil {
		predicates = append(predicates, posttype.ContentContainsFold(*i.ContentContainsFold))
	}
	if i.MetaTitle != nil {
		predicates = append(predicates, posttype.MetaTitleEQ(*i.MetaTitle))
	}
	if i.MetaTitleNEQ != nil {
		predicates = append(predicates, posttype.MetaTitleNEQ(*i.MetaTitleNEQ))
	}
	if len(i.MetaTitleIn) > 0 {
		predicates = append(predicates, posttype.MetaTitleIn(i.MetaTitleIn...))
	}
	if len(i.MetaTitleNotIn) > 0 {
		predicates = append(predicates, posttype.MetaTitleNotIn(i.MetaTitleNotIn...))
	}
	if i.MetaTitleGT != nil {
		predicates = append(predicates, posttype.MetaTitleGT(*i.MetaTitleGT))
	}
	if i.MetaTitleGTE != nil {
		predicates = append(predicates, posttype.MetaTitleGTE(*i.MetaTitleGTE))
	}
	if i.MetaTitleLT != nil {
		predicates = append(predicates, posttype.MetaTitleLT(*i.MetaTitleLT))
	}
	if i.MetaTitleLTE != nil {
		predicates = append(predicates, posttype.MetaTitleLTE(*i.MetaTitleLTE))
	}
	if i.MetaTitleContains != nil {
		predicates = append(predicates, posttype.MetaTitleContains(*i.MetaTitleContains))
	}
	if i.MetaTitleHasPrefix != nil {
		predicates = append(predicates, posttype.MetaTitleHasPrefix(*i.MetaTitleHasPrefix))
	}
	if i.MetaTitleHasSuffix != nil {
		predicates = append(predicates, posttype.MetaTitleHasSuffix(*i.MetaTitleHasSuffix))
	}
	if i.MetaTitleIsNil {
		predicates = append(predicates, posttype.MetaTitleIsNil())
	}
	if i.MetaTitleNotNil {
		predicates = append(predicates, posttype.MetaTitleNotNil())
	}
	if i.MetaTitleEqualFold != nil {
		predicates = append(predicates, posttype.MetaTitleEqualFold(*i.MetaTitleEqualFold))
	}
	if i.MetaTitleContainsFold != nil {
		predicates = append(predicates, posttype.MetaTitleContainsFold(*i.MetaTitleContainsFold))
	}
	if i.MetaDescr != nil {
		predicates = append(predicates, posttype.MetaDescrEQ(*i.MetaDescr))
	}
	if i.MetaDescrNEQ != nil {
		predicates = append(predicates, posttype.MetaDescrNEQ(*i.MetaDescrNEQ))
	}
	if len(i.MetaDescrIn) > 0 {
		predicates = append(predicates, posttype.MetaDescrIn(i.MetaDescrIn...))
	}
	if len(i.MetaDescrNotIn) > 0 {
		predicates = append(predicates, posttype.MetaDescrNotIn(i.MetaDescrNotIn...))
	}
	if i.MetaDescrGT != nil {
		predicates = append(predicates, posttype.MetaDescrGT(*i.MetaDescrGT))
	}
	if i.MetaDescrGTE != nil {
		predicates = append(predicates, posttype.MetaDescrGTE(*i.MetaDescrGTE))
	}
	if i.MetaDescrLT != nil {
		predicates = append(predicates, posttype.MetaDescrLT(*i.MetaDescrLT))
	}
	if i.MetaDescrLTE != nil {
		predicates = append(predicates, posttype.MetaDescrLTE(*i.MetaDescrLTE))
	}
	if i.MetaDescrContains != nil {
		predicates = append(predicates, posttype.MetaDescrContains(*i.MetaDescrContains))
	}
	if i.MetaDescrHasPrefix != nil {
		predicates = append(predicates, posttype.MetaDescrHasPrefix(*i.MetaDescrHasPrefix))
	}
	if i.MetaDescrHasSuffix != nil {
		predicates = append(predicates, posttype.MetaDescrHasSuffix(*i.MetaDescrHasSuffix))
	}
	if i.MetaDescrIsNil {
		predicates = append(predicates, posttype.MetaDescrIsNil())
	}
	if i.MetaDescrNotNil {
		predicates = append(predicates, posttype.MetaDescrNotNil())
	}
	if i.MetaDescrEqualFold != nil {
		predicates = append(predicates, posttype.MetaDescrEqualFold(*i.MetaDescrEqualFold))
	}
	if i.MetaDescrContainsFold != nil {
		predicates = append(predicates, posttype.MetaDescrContainsFold(*i.MetaDescrContainsFold))
	}
	if i.MetaCanonicalURL != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLEQ(*i.MetaCanonicalURL))
	}
	if i.MetaCanonicalURLNEQ != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLNEQ(*i.MetaCanonicalURLNEQ))
	}
	if len(i.MetaCanonicalURLIn) > 0 {
		predicates = append(predicates, posttype.MetaCanonicalURLIn(i.MetaCanonicalURLIn...))
	}
	if len(i.MetaCanonicalURLNotIn) > 0 {
		predicates = append(predicates, posttype.MetaCanonicalURLNotIn(i.MetaCanonicalURLNotIn...))
	}
	if i.MetaCanonicalURLGT != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLGT(*i.MetaCanonicalURLGT))
	}
	if i.MetaCanonicalURLGTE != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLGTE(*i.MetaCanonicalURLGTE))
	}
	if i.MetaCanonicalURLLT != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLLT(*i.MetaCanonicalURLLT))
	}
	if i.MetaCanonicalURLLTE != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLLTE(*i.MetaCanonicalURLLTE))
	}
	if i.MetaCanonicalURLContains != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLContains(*i.MetaCanonicalURLContains))
	}
	if i.MetaCanonicalURLHasPrefix != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLHasPrefix(*i.MetaCanonicalURLHasPrefix))
	}
	if i.MetaCanonicalURLHasSuffix != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLHasSuffix(*i.MetaCanonicalURLHasSuffix))
	}
	if i.MetaCanonicalURLIsNil {
		predicates = append(predicates, posttype.MetaCanonicalURLIsNil())
	}
	if i.MetaCanonicalURLNotNil {
		predicates = append(predicates, posttype.MetaCanonicalURLNotNil())
	}
	if i.MetaCanonicalURLEqualFold != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLEqualFold(*i.MetaCanonicalURLEqualFold))
	}
	if i.MetaCanonicalURLContainsFold != nil {
		predicates = append(predicates, posttype.MetaCanonicalURLContainsFold(*i.MetaCanonicalURLContainsFold))
	}
	if i.MetaRobots != nil {
		predicates = append(predicates, posttype.MetaRobotsEQ(*i.MetaRobots))
	}
	if i.MetaRobotsNEQ != nil {
		predicates = append(predicates, posttype.MetaRobotsNEQ(*i.MetaRobotsNEQ))
	}
	if len(i.MetaRobotsIn) > 0 {
		predicates = append(predicates, posttype.MetaRobotsIn(i.MetaRobotsIn...))
	}
	if len(i.MetaRobotsNotIn) > 0 {
		predicates = append(predicates, posttype.MetaRobotsNotIn(i.MetaRobotsNotIn...))
	}
	if i.MetaRobotsGT != nil {
		predicates = append(predicates, posttype.MetaRobotsGT(*i.MetaRobotsGT))
	}
	if i.MetaRobotsGTE != nil {
		predicates = append(predicates, posttype.MetaRobotsGTE(*i.MetaRobotsGTE))
	}
	if i.MetaRobotsLT != nil {
		predicates = append(predicates, posttype.MetaRobotsLT(*i.MetaRobotsLT))
	}
	if i.MetaRobotsLTE != nil {
		predicates = append(predicates, posttype.MetaRobotsLTE(*i.MetaRobotsLTE))
	}
	if i.MetaRobotsContains != nil {
		predicates = append(predicates, posttype.MetaRobotsContains(*i.MetaRobotsContains))
	}
	if i.MetaRobotsHasPrefix != nil {
		predicates = append(predicates, posttype.MetaRobotsHasPrefix(*i.MetaRobotsHasPrefix))
	}
	if i.MetaRobotsHasSuffix != nil {
		predicates = append(predicates, posttype.MetaRobotsHasSuffix(*i.MetaRobotsHasSuffix))
	}
	if i.MetaRobotsIsNil {
		predicates = append(predicates, posttype.MetaRobotsIsNil())
	}
	if i.MetaRobotsNotNil {
		predicates = append(predicates, posttype.MetaRobotsNotNil())
	}
	if i.MetaRobotsEqualFold != nil {
		predicates = append(predicates, posttype.MetaRobotsEqualFold(*i.MetaRobotsEqualFold))
	}
	if i.MetaRobotsContainsFold != nil {
		predicates = append(predicates, posttype.MetaRobotsContainsFold(*i.MetaRobotsContainsFold))
	}

	if i.HasPosts != nil {
		p := posttype.HasPosts()
		if !*i.HasPosts {
			p = posttype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostsWith) > 0 {
		with := make([]predicate.Post, 0, len(i.HasPostsWith))
		for _, w := range i.HasPostsWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostsWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, posttype.HasPostsWith(with...))
	}
	if i.HasPostStatuses != nil {
		p := posttype.HasPostStatuses()
		if !*i.HasPostStatuses {
			p = posttype.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasPostStatusesWith) > 0 {
		with := make([]predicate.PostStatus, 0, len(i.HasPostStatusesWith))
		for _, w := range i.HasPostStatusesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasPostStatusesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, posttype.HasPostStatusesWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyPostTypeWhereInput
	case 1:
		return predicates[0], nil
	default:
		return posttype.And(predicates...), nil
	}
}

// TodoWhereInput represents a where input for filtering Todo queries.
type TodoWhereInput struct {
	Predicates []predicate.Todo  `json:"-"`
	Not        *TodoWhereInput   `json:"not,omitempty"`
	Or         []*TodoWhereInput `json:"or,omitempty"`
	And        []*TodoWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "text" field predicates.
	Text             *string  `json:"text,omitempty"`
	TextNEQ          *string  `json:"textNEQ,omitempty"`
	TextIn           []string `json:"textIn,omitempty"`
	TextNotIn        []string `json:"textNotIn,omitempty"`
	TextGT           *string  `json:"textGT,omitempty"`
	TextGTE          *string  `json:"textGTE,omitempty"`
	TextLT           *string  `json:"textLT,omitempty"`
	TextLTE          *string  `json:"textLTE,omitempty"`
	TextContains     *string  `json:"textContains,omitempty"`
	TextHasPrefix    *string  `json:"textHasPrefix,omitempty"`
	TextHasSuffix    *string  `json:"textHasSuffix,omitempty"`
	TextEqualFold    *string  `json:"textEqualFold,omitempty"`
	TextContainsFold *string  `json:"textContainsFold,omitempty"`

	// "status" field predicates.
	Status      *todo.Status  `json:"status,omitempty"`
	StatusNEQ   *todo.Status  `json:"statusNEQ,omitempty"`
	StatusIn    []todo.Status `json:"statusIn,omitempty"`
	StatusNotIn []todo.Status `json:"statusNotIn,omitempty"`

	// "priority" field predicates.
	Priority      *int  `json:"priority,omitempty"`
	PriorityNEQ   *int  `json:"priorityNEQ,omitempty"`
	PriorityIn    []int `json:"priorityIn,omitempty"`
	PriorityNotIn []int `json:"priorityNotIn,omitempty"`
	PriorityGT    *int  `json:"priorityGT,omitempty"`
	PriorityGTE   *int  `json:"priorityGTE,omitempty"`
	PriorityLT    *int  `json:"priorityLT,omitempty"`
	PriorityLTE   *int  `json:"priorityLTE,omitempty"`

	// "children" edge predicates.
	HasChildren     *bool             `json:"hasChildren,omitempty"`
	HasChildrenWith []*TodoWhereInput `json:"hasChildrenWith,omitempty"`

	// "parent" edge predicates.
	HasParent     *bool             `json:"hasParent,omitempty"`
	HasParentWith []*TodoWhereInput `json:"hasParentWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *TodoWhereInput) AddPredicates(predicates ...predicate.Todo) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the TodoWhereInput filter on the TodoQuery builder.
func (i *TodoWhereInput) Filter(q *TodoQuery) (*TodoQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyTodoWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyTodoWhereInput is returned in case the TodoWhereInput is empty.
var ErrEmptyTodoWhereInput = errors.New("ent: empty predicate TodoWhereInput")

// P returns a predicate for filtering todos.
// An error is returned if the input is empty or invalid.
func (i *TodoWhereInput) P() (predicate.Todo, error) {
	var predicates []predicate.Todo
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, todo.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Todo, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, todo.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Todo, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, todo.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, todo.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, todo.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, todo.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, todo.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, todo.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, todo.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, todo.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, todo.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, todo.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, todo.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, todo.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, todo.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, todo.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, todo.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, todo.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, todo.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, todo.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, todo.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, todo.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, todo.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, todo.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, todo.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, todo.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, todo.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, todo.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, todo.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, todo.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, todo.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, todo.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, todo.UpdatedAtNotNil())
	}
	if i.Text != nil {
		predicates = append(predicates, todo.TextEQ(*i.Text))
	}
	if i.TextNEQ != nil {
		predicates = append(predicates, todo.TextNEQ(*i.TextNEQ))
	}
	if len(i.TextIn) > 0 {
		predicates = append(predicates, todo.TextIn(i.TextIn...))
	}
	if len(i.TextNotIn) > 0 {
		predicates = append(predicates, todo.TextNotIn(i.TextNotIn...))
	}
	if i.TextGT != nil {
		predicates = append(predicates, todo.TextGT(*i.TextGT))
	}
	if i.TextGTE != nil {
		predicates = append(predicates, todo.TextGTE(*i.TextGTE))
	}
	if i.TextLT != nil {
		predicates = append(predicates, todo.TextLT(*i.TextLT))
	}
	if i.TextLTE != nil {
		predicates = append(predicates, todo.TextLTE(*i.TextLTE))
	}
	if i.TextContains != nil {
		predicates = append(predicates, todo.TextContains(*i.TextContains))
	}
	if i.TextHasPrefix != nil {
		predicates = append(predicates, todo.TextHasPrefix(*i.TextHasPrefix))
	}
	if i.TextHasSuffix != nil {
		predicates = append(predicates, todo.TextHasSuffix(*i.TextHasSuffix))
	}
	if i.TextEqualFold != nil {
		predicates = append(predicates, todo.TextEqualFold(*i.TextEqualFold))
	}
	if i.TextContainsFold != nil {
		predicates = append(predicates, todo.TextContainsFold(*i.TextContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, todo.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, todo.StatusNEQ(*i.StatusNEQ))
	}
	if len(i.StatusIn) > 0 {
		predicates = append(predicates, todo.StatusIn(i.StatusIn...))
	}
	if len(i.StatusNotIn) > 0 {
		predicates = append(predicates, todo.StatusNotIn(i.StatusNotIn...))
	}
	if i.Priority != nil {
		predicates = append(predicates, todo.PriorityEQ(*i.Priority))
	}
	if i.PriorityNEQ != nil {
		predicates = append(predicates, todo.PriorityNEQ(*i.PriorityNEQ))
	}
	if len(i.PriorityIn) > 0 {
		predicates = append(predicates, todo.PriorityIn(i.PriorityIn...))
	}
	if len(i.PriorityNotIn) > 0 {
		predicates = append(predicates, todo.PriorityNotIn(i.PriorityNotIn...))
	}
	if i.PriorityGT != nil {
		predicates = append(predicates, todo.PriorityGT(*i.PriorityGT))
	}
	if i.PriorityGTE != nil {
		predicates = append(predicates, todo.PriorityGTE(*i.PriorityGTE))
	}
	if i.PriorityLT != nil {
		predicates = append(predicates, todo.PriorityLT(*i.PriorityLT))
	}
	if i.PriorityLTE != nil {
		predicates = append(predicates, todo.PriorityLTE(*i.PriorityLTE))
	}

	if i.HasChildren != nil {
		p := todo.HasChildren()
		if !*i.HasChildren {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasChildrenWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasChildrenWith))
		for _, w := range i.HasChildrenWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasChildrenWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasChildrenWith(with...))
	}
	if i.HasParent != nil {
		p := todo.HasParent()
		if !*i.HasParent {
			p = todo.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasParentWith) > 0 {
		with := make([]predicate.Todo, 0, len(i.HasParentWith))
		for _, w := range i.HasParentWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasParentWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, todo.HasParentWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyTodoWhereInput
	case 1:
		return predicates[0], nil
	default:
		return todo.And(predicates...), nil
	}
}

// UserWhereInput represents a where input for filtering User queries.
type UserWhereInput struct {
	Predicates []predicate.User  `json:"-"`
	Not        *UserWhereInput   `json:"not,omitempty"`
	Or         []*UserWhereInput `json:"or,omitempty"`
	And        []*UserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "phone" field predicates.
	Phone             *string  `json:"phone,omitempty"`
	PhoneNEQ          *string  `json:"phoneNEQ,omitempty"`
	PhoneIn           []string `json:"phoneIn,omitempty"`
	PhoneNotIn        []string `json:"phoneNotIn,omitempty"`
	PhoneGT           *string  `json:"phoneGT,omitempty"`
	PhoneGTE          *string  `json:"phoneGTE,omitempty"`
	PhoneLT           *string  `json:"phoneLT,omitempty"`
	PhoneLTE          *string  `json:"phoneLTE,omitempty"`
	PhoneContains     *string  `json:"phoneContains,omitempty"`
	PhoneHasPrefix    *string  `json:"phoneHasPrefix,omitempty"`
	PhoneHasSuffix    *string  `json:"phoneHasSuffix,omitempty"`
	PhoneIsNil        bool     `json:"phoneIsNil,omitempty"`
	PhoneNotNil       bool     `json:"phoneNotNil,omitempty"`
	PhoneEqualFold    *string  `json:"phoneEqualFold,omitempty"`
	PhoneContainsFold *string  `json:"phoneContainsFold,omitempty"`

	// "first_name" field predicates.
	FirstName             *string  `json:"firstName,omitempty"`
	FirstNameNEQ          *string  `json:"firstNameNEQ,omitempty"`
	FirstNameIn           []string `json:"firstNameIn,omitempty"`
	FirstNameNotIn        []string `json:"firstNameNotIn,omitempty"`
	FirstNameGT           *string  `json:"firstNameGT,omitempty"`
	FirstNameGTE          *string  `json:"firstNameGTE,omitempty"`
	FirstNameLT           *string  `json:"firstNameLT,omitempty"`
	FirstNameLTE          *string  `json:"firstNameLTE,omitempty"`
	FirstNameContains     *string  `json:"firstNameContains,omitempty"`
	FirstNameHasPrefix    *string  `json:"firstNameHasPrefix,omitempty"`
	FirstNameHasSuffix    *string  `json:"firstNameHasSuffix,omitempty"`
	FirstNameIsNil        bool     `json:"firstNameIsNil,omitempty"`
	FirstNameNotNil       bool     `json:"firstNameNotNil,omitempty"`
	FirstNameEqualFold    *string  `json:"firstNameEqualFold,omitempty"`
	FirstNameContainsFold *string  `json:"firstNameContainsFold,omitempty"`

	// "last_name" field predicates.
	LastName             *string  `json:"lastName,omitempty"`
	LastNameNEQ          *string  `json:"lastNameNEQ,omitempty"`
	LastNameIn           []string `json:"lastNameIn,omitempty"`
	LastNameNotIn        []string `json:"lastNameNotIn,omitempty"`
	LastNameGT           *string  `json:"lastNameGT,omitempty"`
	LastNameGTE          *string  `json:"lastNameGTE,omitempty"`
	LastNameLT           *string  `json:"lastNameLT,omitempty"`
	LastNameLTE          *string  `json:"lastNameLTE,omitempty"`
	LastNameContains     *string  `json:"lastNameContains,omitempty"`
	LastNameHasPrefix    *string  `json:"lastNameHasPrefix,omitempty"`
	LastNameHasSuffix    *string  `json:"lastNameHasSuffix,omitempty"`
	LastNameIsNil        bool     `json:"lastNameIsNil,omitempty"`
	LastNameNotNil       bool     `json:"lastNameNotNil,omitempty"`
	LastNameEqualFold    *string  `json:"lastNameEqualFold,omitempty"`
	LastNameContainsFold *string  `json:"lastNameContainsFold,omitempty"`

	// "company" field predicates.
	Company             *string  `json:"company,omitempty"`
	CompanyNEQ          *string  `json:"companyNEQ,omitempty"`
	CompanyIn           []string `json:"companyIn,omitempty"`
	CompanyNotIn        []string `json:"companyNotIn,omitempty"`
	CompanyGT           *string  `json:"companyGT,omitempty"`
	CompanyGTE          *string  `json:"companyGTE,omitempty"`
	CompanyLT           *string  `json:"companyLT,omitempty"`
	CompanyLTE          *string  `json:"companyLTE,omitempty"`
	CompanyContains     *string  `json:"companyContains,omitempty"`
	CompanyHasPrefix    *string  `json:"companyHasPrefix,omitempty"`
	CompanyHasSuffix    *string  `json:"companyHasSuffix,omitempty"`
	CompanyIsNil        bool     `json:"companyIsNil,omitempty"`
	CompanyNotNil       bool     `json:"companyNotNil,omitempty"`
	CompanyEqualFold    *string  `json:"companyEqualFold,omitempty"`
	CompanyContainsFold *string  `json:"companyContainsFold,omitempty"`

	// "locale" field predicates.
	Locale             *string  `json:"locale,omitempty"`
	LocaleNEQ          *string  `json:"localeNEQ,omitempty"`
	LocaleIn           []string `json:"localeIn,omitempty"`
	LocaleNotIn        []string `json:"localeNotIn,omitempty"`
	LocaleGT           *string  `json:"localeGT,omitempty"`
	LocaleGTE          *string  `json:"localeGTE,omitempty"`
	LocaleLT           *string  `json:"localeLT,omitempty"`
	LocaleLTE          *string  `json:"localeLTE,omitempty"`
	LocaleContains     *string  `json:"localeContains,omitempty"`
	LocaleHasPrefix    *string  `json:"localeHasPrefix,omitempty"`
	LocaleHasSuffix    *string  `json:"localeHasSuffix,omitempty"`
	LocaleIsNil        bool     `json:"localeIsNil,omitempty"`
	LocaleNotNil       bool     `json:"localeNotNil,omitempty"`
	LocaleEqualFold    *string  `json:"localeEqualFold,omitempty"`
	LocaleContainsFold *string  `json:"localeContainsFold,omitempty"`

	// "role_id" field predicates.
	RoleID             *string  `json:"roleID,omitempty"`
	RoleIDNEQ          *string  `json:"roleIDNEQ,omitempty"`
	RoleIDIn           []string `json:"roleIDIn,omitempty"`
	RoleIDNotIn        []string `json:"roleIDNotIn,omitempty"`
	RoleIDGT           *string  `json:"roleIDGT,omitempty"`
	RoleIDGTE          *string  `json:"roleIDGTE,omitempty"`
	RoleIDLT           *string  `json:"roleIDLT,omitempty"`
	RoleIDLTE          *string  `json:"roleIDLTE,omitempty"`
	RoleIDContains     *string  `json:"roleIDContains,omitempty"`
	RoleIDHasPrefix    *string  `json:"roleIDHasPrefix,omitempty"`
	RoleIDHasSuffix    *string  `json:"roleIDHasSuffix,omitempty"`
	RoleIDIsNil        bool     `json:"roleIDIsNil,omitempty"`
	RoleIDNotNil       bool     `json:"roleIDNotNil,omitempty"`
	RoleIDEqualFold    *string  `json:"roleIDEqualFold,omitempty"`
	RoleIDContainsFold *string  `json:"roleIDContainsFold,omitempty"`

	// "status" field predicates.
	Status       *bool `json:"status,omitempty"`
	StatusNEQ    *bool `json:"statusNEQ,omitempty"`
	StatusIsNil  bool  `json:"statusIsNil,omitempty"`
	StatusNotNil bool  `json:"statusNotNil,omitempty"`

	// "password" field predicates.
	Password             *string  `json:"password,omitempty"`
	PasswordNEQ          *string  `json:"passwordNEQ,omitempty"`
	PasswordIn           []string `json:"passwordIn,omitempty"`
	PasswordNotIn        []string `json:"passwordNotIn,omitempty"`
	PasswordGT           *string  `json:"passwordGT,omitempty"`
	PasswordGTE          *string  `json:"passwordGTE,omitempty"`
	PasswordLT           *string  `json:"passwordLT,omitempty"`
	PasswordLTE          *string  `json:"passwordLTE,omitempty"`
	PasswordContains     *string  `json:"passwordContains,omitempty"`
	PasswordHasPrefix    *string  `json:"passwordHasPrefix,omitempty"`
	PasswordHasSuffix    *string  `json:"passwordHasSuffix,omitempty"`
	PasswordIsNil        bool     `json:"passwordIsNil,omitempty"`
	PasswordNotNil       bool     `json:"passwordNotNil,omitempty"`
	PasswordEqualFold    *string  `json:"passwordEqualFold,omitempty"`
	PasswordContainsFold *string  `json:"passwordContainsFold,omitempty"`

	// "secret" field predicates.
	Secret             *string  `json:"secret,omitempty"`
	SecretNEQ          *string  `json:"secretNEQ,omitempty"`
	SecretIn           []string `json:"secretIn,omitempty"`
	SecretNotIn        []string `json:"secretNotIn,omitempty"`
	SecretGT           *string  `json:"secretGT,omitempty"`
	SecretGTE          *string  `json:"secretGTE,omitempty"`
	SecretLT           *string  `json:"secretLT,omitempty"`
	SecretLTE          *string  `json:"secretLTE,omitempty"`
	SecretContains     *string  `json:"secretContains,omitempty"`
	SecretHasPrefix    *string  `json:"secretHasPrefix,omitempty"`
	SecretHasSuffix    *string  `json:"secretHasSuffix,omitempty"`
	SecretIsNil        bool     `json:"secretIsNil,omitempty"`
	SecretNotNil       bool     `json:"secretNotNil,omitempty"`
	SecretEqualFold    *string  `json:"secretEqualFold,omitempty"`
	SecretContainsFold *string  `json:"secretContainsFold,omitempty"`

	// "api_key" field predicates.
	APIKey             *string  `json:"apiKey,omitempty"`
	APIKeyNEQ          *string  `json:"apiKeyNEQ,omitempty"`
	APIKeyIn           []string `json:"apiKeyIn,omitempty"`
	APIKeyNotIn        []string `json:"apiKeyNotIn,omitempty"`
	APIKeyGT           *string  `json:"apiKeyGT,omitempty"`
	APIKeyGTE          *string  `json:"apiKeyGTE,omitempty"`
	APIKeyLT           *string  `json:"apiKeyLT,omitempty"`
	APIKeyLTE          *string  `json:"apiKeyLTE,omitempty"`
	APIKeyContains     *string  `json:"apiKeyContains,omitempty"`
	APIKeyHasPrefix    *string  `json:"apiKeyHasPrefix,omitempty"`
	APIKeyHasSuffix    *string  `json:"apiKeyHasSuffix,omitempty"`
	APIKeyIsNil        bool     `json:"apiKeyIsNil,omitempty"`
	APIKeyNotNil       bool     `json:"apiKeyNotNil,omitempty"`
	APIKeyEqualFold    *string  `json:"apiKeyEqualFold,omitempty"`
	APIKeyContainsFold *string  `json:"apiKeyContainsFold,omitempty"`

	// "welcome_email_sent" field predicates.
	WelcomeEmailSent       *bool `json:"welcomeEmailSent,omitempty"`
	WelcomeEmailSentNEQ    *bool `json:"welcomeEmailSentNEQ,omitempty"`
	WelcomeEmailSentIsNil  bool  `json:"welcomeEmailSentIsNil,omitempty"`
	WelcomeEmailSentNotNil bool  `json:"welcomeEmailSentNotNil,omitempty"`

	// "can_admin" field predicates.
	CanAdmin       *bool `json:"canAdmin,omitempty"`
	CanAdminNEQ    *bool `json:"canAdminNEQ,omitempty"`
	CanAdminIsNil  bool  `json:"canAdminIsNil,omitempty"`
	CanAdminNotNil bool  `json:"canAdminNotNil,omitempty"`

	// "workspaces" edge predicates.
	HasWorkspaces     *bool                  `json:"hasWorkspaces,omitempty"`
	HasWorkspacesWith []*WorkspaceWhereInput `json:"hasWorkspacesWith,omitempty"`

	// "workspace_users" edge predicates.
	HasWorkspaceUsers     *bool                      `json:"hasWorkspaceUsers,omitempty"`
	HasWorkspaceUsersWith []*WorkspaceUserWhereInput `json:"hasWorkspaceUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *UserWhereInput) AddPredicates(predicates ...predicate.User) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the UserWhereInput filter on the UserQuery builder.
func (i *UserWhereInput) Filter(q *UserQuery) (*UserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyUserWhereInput is returned in case the UserWhereInput is empty.
var ErrEmptyUserWhereInput = errors.New("ent: empty predicate UserWhereInput")

// P returns a predicate for filtering users.
// An error is returned if the input is empty or invalid.
func (i *UserWhereInput) P() (predicate.User, error) {
	var predicates []predicate.User
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, user.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.User, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, user.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.User, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, user.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, user.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, user.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, user.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, user.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, user.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, user.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, user.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, user.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, user.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, user.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, user.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, user.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, user.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, user.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, user.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, user.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, user.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, user.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, user.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, user.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, user.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, user.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, user.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, user.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, user.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, user.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, user.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, user.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, user.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, user.UpdatedAtNotNil())
	}
	if i.Email != nil {
		predicates = append(predicates, user.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, user.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, user.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, user.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, user.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, user.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, user.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, user.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, user.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, user.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, user.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, user.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, user.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Phone != nil {
		predicates = append(predicates, user.PhoneEQ(*i.Phone))
	}
	if i.PhoneNEQ != nil {
		predicates = append(predicates, user.PhoneNEQ(*i.PhoneNEQ))
	}
	if len(i.PhoneIn) > 0 {
		predicates = append(predicates, user.PhoneIn(i.PhoneIn...))
	}
	if len(i.PhoneNotIn) > 0 {
		predicates = append(predicates, user.PhoneNotIn(i.PhoneNotIn...))
	}
	if i.PhoneGT != nil {
		predicates = append(predicates, user.PhoneGT(*i.PhoneGT))
	}
	if i.PhoneGTE != nil {
		predicates = append(predicates, user.PhoneGTE(*i.PhoneGTE))
	}
	if i.PhoneLT != nil {
		predicates = append(predicates, user.PhoneLT(*i.PhoneLT))
	}
	if i.PhoneLTE != nil {
		predicates = append(predicates, user.PhoneLTE(*i.PhoneLTE))
	}
	if i.PhoneContains != nil {
		predicates = append(predicates, user.PhoneContains(*i.PhoneContains))
	}
	if i.PhoneHasPrefix != nil {
		predicates = append(predicates, user.PhoneHasPrefix(*i.PhoneHasPrefix))
	}
	if i.PhoneHasSuffix != nil {
		predicates = append(predicates, user.PhoneHasSuffix(*i.PhoneHasSuffix))
	}
	if i.PhoneIsNil {
		predicates = append(predicates, user.PhoneIsNil())
	}
	if i.PhoneNotNil {
		predicates = append(predicates, user.PhoneNotNil())
	}
	if i.PhoneEqualFold != nil {
		predicates = append(predicates, user.PhoneEqualFold(*i.PhoneEqualFold))
	}
	if i.PhoneContainsFold != nil {
		predicates = append(predicates, user.PhoneContainsFold(*i.PhoneContainsFold))
	}
	if i.FirstName != nil {
		predicates = append(predicates, user.FirstNameEQ(*i.FirstName))
	}
	if i.FirstNameNEQ != nil {
		predicates = append(predicates, user.FirstNameNEQ(*i.FirstNameNEQ))
	}
	if len(i.FirstNameIn) > 0 {
		predicates = append(predicates, user.FirstNameIn(i.FirstNameIn...))
	}
	if len(i.FirstNameNotIn) > 0 {
		predicates = append(predicates, user.FirstNameNotIn(i.FirstNameNotIn...))
	}
	if i.FirstNameGT != nil {
		predicates = append(predicates, user.FirstNameGT(*i.FirstNameGT))
	}
	if i.FirstNameGTE != nil {
		predicates = append(predicates, user.FirstNameGTE(*i.FirstNameGTE))
	}
	if i.FirstNameLT != nil {
		predicates = append(predicates, user.FirstNameLT(*i.FirstNameLT))
	}
	if i.FirstNameLTE != nil {
		predicates = append(predicates, user.FirstNameLTE(*i.FirstNameLTE))
	}
	if i.FirstNameContains != nil {
		predicates = append(predicates, user.FirstNameContains(*i.FirstNameContains))
	}
	if i.FirstNameHasPrefix != nil {
		predicates = append(predicates, user.FirstNameHasPrefix(*i.FirstNameHasPrefix))
	}
	if i.FirstNameHasSuffix != nil {
		predicates = append(predicates, user.FirstNameHasSuffix(*i.FirstNameHasSuffix))
	}
	if i.FirstNameIsNil {
		predicates = append(predicates, user.FirstNameIsNil())
	}
	if i.FirstNameNotNil {
		predicates = append(predicates, user.FirstNameNotNil())
	}
	if i.FirstNameEqualFold != nil {
		predicates = append(predicates, user.FirstNameEqualFold(*i.FirstNameEqualFold))
	}
	if i.FirstNameContainsFold != nil {
		predicates = append(predicates, user.FirstNameContainsFold(*i.FirstNameContainsFold))
	}
	if i.LastName != nil {
		predicates = append(predicates, user.LastNameEQ(*i.LastName))
	}
	if i.LastNameNEQ != nil {
		predicates = append(predicates, user.LastNameNEQ(*i.LastNameNEQ))
	}
	if len(i.LastNameIn) > 0 {
		predicates = append(predicates, user.LastNameIn(i.LastNameIn...))
	}
	if len(i.LastNameNotIn) > 0 {
		predicates = append(predicates, user.LastNameNotIn(i.LastNameNotIn...))
	}
	if i.LastNameGT != nil {
		predicates = append(predicates, user.LastNameGT(*i.LastNameGT))
	}
	if i.LastNameGTE != nil {
		predicates = append(predicates, user.LastNameGTE(*i.LastNameGTE))
	}
	if i.LastNameLT != nil {
		predicates = append(predicates, user.LastNameLT(*i.LastNameLT))
	}
	if i.LastNameLTE != nil {
		predicates = append(predicates, user.LastNameLTE(*i.LastNameLTE))
	}
	if i.LastNameContains != nil {
		predicates = append(predicates, user.LastNameContains(*i.LastNameContains))
	}
	if i.LastNameHasPrefix != nil {
		predicates = append(predicates, user.LastNameHasPrefix(*i.LastNameHasPrefix))
	}
	if i.LastNameHasSuffix != nil {
		predicates = append(predicates, user.LastNameHasSuffix(*i.LastNameHasSuffix))
	}
	if i.LastNameIsNil {
		predicates = append(predicates, user.LastNameIsNil())
	}
	if i.LastNameNotNil {
		predicates = append(predicates, user.LastNameNotNil())
	}
	if i.LastNameEqualFold != nil {
		predicates = append(predicates, user.LastNameEqualFold(*i.LastNameEqualFold))
	}
	if i.LastNameContainsFold != nil {
		predicates = append(predicates, user.LastNameContainsFold(*i.LastNameContainsFold))
	}
	if i.Company != nil {
		predicates = append(predicates, user.CompanyEQ(*i.Company))
	}
	if i.CompanyNEQ != nil {
		predicates = append(predicates, user.CompanyNEQ(*i.CompanyNEQ))
	}
	if len(i.CompanyIn) > 0 {
		predicates = append(predicates, user.CompanyIn(i.CompanyIn...))
	}
	if len(i.CompanyNotIn) > 0 {
		predicates = append(predicates, user.CompanyNotIn(i.CompanyNotIn...))
	}
	if i.CompanyGT != nil {
		predicates = append(predicates, user.CompanyGT(*i.CompanyGT))
	}
	if i.CompanyGTE != nil {
		predicates = append(predicates, user.CompanyGTE(*i.CompanyGTE))
	}
	if i.CompanyLT != nil {
		predicates = append(predicates, user.CompanyLT(*i.CompanyLT))
	}
	if i.CompanyLTE != nil {
		predicates = append(predicates, user.CompanyLTE(*i.CompanyLTE))
	}
	if i.CompanyContains != nil {
		predicates = append(predicates, user.CompanyContains(*i.CompanyContains))
	}
	if i.CompanyHasPrefix != nil {
		predicates = append(predicates, user.CompanyHasPrefix(*i.CompanyHasPrefix))
	}
	if i.CompanyHasSuffix != nil {
		predicates = append(predicates, user.CompanyHasSuffix(*i.CompanyHasSuffix))
	}
	if i.CompanyIsNil {
		predicates = append(predicates, user.CompanyIsNil())
	}
	if i.CompanyNotNil {
		predicates = append(predicates, user.CompanyNotNil())
	}
	if i.CompanyEqualFold != nil {
		predicates = append(predicates, user.CompanyEqualFold(*i.CompanyEqualFold))
	}
	if i.CompanyContainsFold != nil {
		predicates = append(predicates, user.CompanyContainsFold(*i.CompanyContainsFold))
	}
	if i.Locale != nil {
		predicates = append(predicates, user.LocaleEQ(*i.Locale))
	}
	if i.LocaleNEQ != nil {
		predicates = append(predicates, user.LocaleNEQ(*i.LocaleNEQ))
	}
	if len(i.LocaleIn) > 0 {
		predicates = append(predicates, user.LocaleIn(i.LocaleIn...))
	}
	if len(i.LocaleNotIn) > 0 {
		predicates = append(predicates, user.LocaleNotIn(i.LocaleNotIn...))
	}
	if i.LocaleGT != nil {
		predicates = append(predicates, user.LocaleGT(*i.LocaleGT))
	}
	if i.LocaleGTE != nil {
		predicates = append(predicates, user.LocaleGTE(*i.LocaleGTE))
	}
	if i.LocaleLT != nil {
		predicates = append(predicates, user.LocaleLT(*i.LocaleLT))
	}
	if i.LocaleLTE != nil {
		predicates = append(predicates, user.LocaleLTE(*i.LocaleLTE))
	}
	if i.LocaleContains != nil {
		predicates = append(predicates, user.LocaleContains(*i.LocaleContains))
	}
	if i.LocaleHasPrefix != nil {
		predicates = append(predicates, user.LocaleHasPrefix(*i.LocaleHasPrefix))
	}
	if i.LocaleHasSuffix != nil {
		predicates = append(predicates, user.LocaleHasSuffix(*i.LocaleHasSuffix))
	}
	if i.LocaleIsNil {
		predicates = append(predicates, user.LocaleIsNil())
	}
	if i.LocaleNotNil {
		predicates = append(predicates, user.LocaleNotNil())
	}
	if i.LocaleEqualFold != nil {
		predicates = append(predicates, user.LocaleEqualFold(*i.LocaleEqualFold))
	}
	if i.LocaleContainsFold != nil {
		predicates = append(predicates, user.LocaleContainsFold(*i.LocaleContainsFold))
	}
	if i.RoleID != nil {
		predicates = append(predicates, user.RoleIDEQ(*i.RoleID))
	}
	if i.RoleIDNEQ != nil {
		predicates = append(predicates, user.RoleIDNEQ(*i.RoleIDNEQ))
	}
	if len(i.RoleIDIn) > 0 {
		predicates = append(predicates, user.RoleIDIn(i.RoleIDIn...))
	}
	if len(i.RoleIDNotIn) > 0 {
		predicates = append(predicates, user.RoleIDNotIn(i.RoleIDNotIn...))
	}
	if i.RoleIDGT != nil {
		predicates = append(predicates, user.RoleIDGT(*i.RoleIDGT))
	}
	if i.RoleIDGTE != nil {
		predicates = append(predicates, user.RoleIDGTE(*i.RoleIDGTE))
	}
	if i.RoleIDLT != nil {
		predicates = append(predicates, user.RoleIDLT(*i.RoleIDLT))
	}
	if i.RoleIDLTE != nil {
		predicates = append(predicates, user.RoleIDLTE(*i.RoleIDLTE))
	}
	if i.RoleIDContains != nil {
		predicates = append(predicates, user.RoleIDContains(*i.RoleIDContains))
	}
	if i.RoleIDHasPrefix != nil {
		predicates = append(predicates, user.RoleIDHasPrefix(*i.RoleIDHasPrefix))
	}
	if i.RoleIDHasSuffix != nil {
		predicates = append(predicates, user.RoleIDHasSuffix(*i.RoleIDHasSuffix))
	}
	if i.RoleIDIsNil {
		predicates = append(predicates, user.RoleIDIsNil())
	}
	if i.RoleIDNotNil {
		predicates = append(predicates, user.RoleIDNotNil())
	}
	if i.RoleIDEqualFold != nil {
		predicates = append(predicates, user.RoleIDEqualFold(*i.RoleIDEqualFold))
	}
	if i.RoleIDContainsFold != nil {
		predicates = append(predicates, user.RoleIDContainsFold(*i.RoleIDContainsFold))
	}
	if i.Status != nil {
		predicates = append(predicates, user.StatusEQ(*i.Status))
	}
	if i.StatusNEQ != nil {
		predicates = append(predicates, user.StatusNEQ(*i.StatusNEQ))
	}
	if i.StatusIsNil {
		predicates = append(predicates, user.StatusIsNil())
	}
	if i.StatusNotNil {
		predicates = append(predicates, user.StatusNotNil())
	}
	if i.Password != nil {
		predicates = append(predicates, user.PasswordEQ(*i.Password))
	}
	if i.PasswordNEQ != nil {
		predicates = append(predicates, user.PasswordNEQ(*i.PasswordNEQ))
	}
	if len(i.PasswordIn) > 0 {
		predicates = append(predicates, user.PasswordIn(i.PasswordIn...))
	}
	if len(i.PasswordNotIn) > 0 {
		predicates = append(predicates, user.PasswordNotIn(i.PasswordNotIn...))
	}
	if i.PasswordGT != nil {
		predicates = append(predicates, user.PasswordGT(*i.PasswordGT))
	}
	if i.PasswordGTE != nil {
		predicates = append(predicates, user.PasswordGTE(*i.PasswordGTE))
	}
	if i.PasswordLT != nil {
		predicates = append(predicates, user.PasswordLT(*i.PasswordLT))
	}
	if i.PasswordLTE != nil {
		predicates = append(predicates, user.PasswordLTE(*i.PasswordLTE))
	}
	if i.PasswordContains != nil {
		predicates = append(predicates, user.PasswordContains(*i.PasswordContains))
	}
	if i.PasswordHasPrefix != nil {
		predicates = append(predicates, user.PasswordHasPrefix(*i.PasswordHasPrefix))
	}
	if i.PasswordHasSuffix != nil {
		predicates = append(predicates, user.PasswordHasSuffix(*i.PasswordHasSuffix))
	}
	if i.PasswordIsNil {
		predicates = append(predicates, user.PasswordIsNil())
	}
	if i.PasswordNotNil {
		predicates = append(predicates, user.PasswordNotNil())
	}
	if i.PasswordEqualFold != nil {
		predicates = append(predicates, user.PasswordEqualFold(*i.PasswordEqualFold))
	}
	if i.PasswordContainsFold != nil {
		predicates = append(predicates, user.PasswordContainsFold(*i.PasswordContainsFold))
	}
	if i.Secret != nil {
		predicates = append(predicates, user.SecretEQ(*i.Secret))
	}
	if i.SecretNEQ != nil {
		predicates = append(predicates, user.SecretNEQ(*i.SecretNEQ))
	}
	if len(i.SecretIn) > 0 {
		predicates = append(predicates, user.SecretIn(i.SecretIn...))
	}
	if len(i.SecretNotIn) > 0 {
		predicates = append(predicates, user.SecretNotIn(i.SecretNotIn...))
	}
	if i.SecretGT != nil {
		predicates = append(predicates, user.SecretGT(*i.SecretGT))
	}
	if i.SecretGTE != nil {
		predicates = append(predicates, user.SecretGTE(*i.SecretGTE))
	}
	if i.SecretLT != nil {
		predicates = append(predicates, user.SecretLT(*i.SecretLT))
	}
	if i.SecretLTE != nil {
		predicates = append(predicates, user.SecretLTE(*i.SecretLTE))
	}
	if i.SecretContains != nil {
		predicates = append(predicates, user.SecretContains(*i.SecretContains))
	}
	if i.SecretHasPrefix != nil {
		predicates = append(predicates, user.SecretHasPrefix(*i.SecretHasPrefix))
	}
	if i.SecretHasSuffix != nil {
		predicates = append(predicates, user.SecretHasSuffix(*i.SecretHasSuffix))
	}
	if i.SecretIsNil {
		predicates = append(predicates, user.SecretIsNil())
	}
	if i.SecretNotNil {
		predicates = append(predicates, user.SecretNotNil())
	}
	if i.SecretEqualFold != nil {
		predicates = append(predicates, user.SecretEqualFold(*i.SecretEqualFold))
	}
	if i.SecretContainsFold != nil {
		predicates = append(predicates, user.SecretContainsFold(*i.SecretContainsFold))
	}
	if i.APIKey != nil {
		predicates = append(predicates, user.APIKeyEQ(*i.APIKey))
	}
	if i.APIKeyNEQ != nil {
		predicates = append(predicates, user.APIKeyNEQ(*i.APIKeyNEQ))
	}
	if len(i.APIKeyIn) > 0 {
		predicates = append(predicates, user.APIKeyIn(i.APIKeyIn...))
	}
	if len(i.APIKeyNotIn) > 0 {
		predicates = append(predicates, user.APIKeyNotIn(i.APIKeyNotIn...))
	}
	if i.APIKeyGT != nil {
		predicates = append(predicates, user.APIKeyGT(*i.APIKeyGT))
	}
	if i.APIKeyGTE != nil {
		predicates = append(predicates, user.APIKeyGTE(*i.APIKeyGTE))
	}
	if i.APIKeyLT != nil {
		predicates = append(predicates, user.APIKeyLT(*i.APIKeyLT))
	}
	if i.APIKeyLTE != nil {
		predicates = append(predicates, user.APIKeyLTE(*i.APIKeyLTE))
	}
	if i.APIKeyContains != nil {
		predicates = append(predicates, user.APIKeyContains(*i.APIKeyContains))
	}
	if i.APIKeyHasPrefix != nil {
		predicates = append(predicates, user.APIKeyHasPrefix(*i.APIKeyHasPrefix))
	}
	if i.APIKeyHasSuffix != nil {
		predicates = append(predicates, user.APIKeyHasSuffix(*i.APIKeyHasSuffix))
	}
	if i.APIKeyIsNil {
		predicates = append(predicates, user.APIKeyIsNil())
	}
	if i.APIKeyNotNil {
		predicates = append(predicates, user.APIKeyNotNil())
	}
	if i.APIKeyEqualFold != nil {
		predicates = append(predicates, user.APIKeyEqualFold(*i.APIKeyEqualFold))
	}
	if i.APIKeyContainsFold != nil {
		predicates = append(predicates, user.APIKeyContainsFold(*i.APIKeyContainsFold))
	}
	if i.WelcomeEmailSent != nil {
		predicates = append(predicates, user.WelcomeEmailSentEQ(*i.WelcomeEmailSent))
	}
	if i.WelcomeEmailSentNEQ != nil {
		predicates = append(predicates, user.WelcomeEmailSentNEQ(*i.WelcomeEmailSentNEQ))
	}
	if i.WelcomeEmailSentIsNil {
		predicates = append(predicates, user.WelcomeEmailSentIsNil())
	}
	if i.WelcomeEmailSentNotNil {
		predicates = append(predicates, user.WelcomeEmailSentNotNil())
	}
	if i.CanAdmin != nil {
		predicates = append(predicates, user.CanAdminEQ(*i.CanAdmin))
	}
	if i.CanAdminNEQ != nil {
		predicates = append(predicates, user.CanAdminNEQ(*i.CanAdminNEQ))
	}
	if i.CanAdminIsNil {
		predicates = append(predicates, user.CanAdminIsNil())
	}
	if i.CanAdminNotNil {
		predicates = append(predicates, user.CanAdminNotNil())
	}

	if i.HasWorkspaces != nil {
		p := user.HasWorkspaces()
		if !*i.HasWorkspaces {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkspacesWith) > 0 {
		with := make([]predicate.Workspace, 0, len(i.HasWorkspacesWith))
		for _, w := range i.HasWorkspacesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkspacesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasWorkspacesWith(with...))
	}
	if i.HasWorkspaceUsers != nil {
		p := user.HasWorkspaceUsers()
		if !*i.HasWorkspaceUsers {
			p = user.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkspaceUsersWith) > 0 {
		with := make([]predicate.WorkspaceUser, 0, len(i.HasWorkspaceUsersWith))
		for _, w := range i.HasWorkspaceUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkspaceUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, user.HasWorkspaceUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return user.And(predicates...), nil
	}
}

// WorkspaceWhereInput represents a where input for filtering Workspace queries.
type WorkspaceWhereInput struct {
	Predicates []predicate.Workspace  `json:"-"`
	Not        *WorkspaceWhereInput   `json:"not,omitempty"`
	Or         []*WorkspaceWhereInput `json:"or,omitempty"`
	And        []*WorkspaceWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "name" field predicates.
	Name             *string  `json:"name,omitempty"`
	NameNEQ          *string  `json:"nameNEQ,omitempty"`
	NameIn           []string `json:"nameIn,omitempty"`
	NameNotIn        []string `json:"nameNotIn,omitempty"`
	NameGT           *string  `json:"nameGT,omitempty"`
	NameGTE          *string  `json:"nameGTE,omitempty"`
	NameLT           *string  `json:"nameLT,omitempty"`
	NameLTE          *string  `json:"nameLTE,omitempty"`
	NameContains     *string  `json:"nameContains,omitempty"`
	NameHasPrefix    *string  `json:"nameHasPrefix,omitempty"`
	NameHasSuffix    *string  `json:"nameHasSuffix,omitempty"`
	NameIsNil        bool     `json:"nameIsNil,omitempty"`
	NameNotNil       bool     `json:"nameNotNil,omitempty"`
	NameEqualFold    *string  `json:"nameEqualFold,omitempty"`
	NameContainsFold *string  `json:"nameContainsFold,omitempty"`

	// "is_personal" field predicates.
	IsPersonal       *bool `json:"isPersonal,omitempty"`
	IsPersonalNEQ    *bool `json:"isPersonalNEQ,omitempty"`
	IsPersonalIsNil  bool  `json:"isPersonalIsNil,omitempty"`
	IsPersonalNotNil bool  `json:"isPersonalNotNil,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDIsNil        bool     `json:"userIDIsNil,omitempty"`
	UserIDNotNil       bool     `json:"userIDNotNil,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "users" edge predicates.
	HasUsers     *bool             `json:"hasUsers,omitempty"`
	HasUsersWith []*UserWhereInput `json:"hasUsersWith,omitempty"`

	// "workspace_invites" edge predicates.
	HasWorkspaceInvites     *bool                        `json:"hasWorkspaceInvites,omitempty"`
	HasWorkspaceInvitesWith []*WorkspaceInviteWhereInput `json:"hasWorkspaceInvitesWith,omitempty"`

	// "workspace_users" edge predicates.
	HasWorkspaceUsers     *bool                      `json:"hasWorkspaceUsers,omitempty"`
	HasWorkspaceUsersWith []*WorkspaceUserWhereInput `json:"hasWorkspaceUsersWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkspaceWhereInput) AddPredicates(predicates ...predicate.Workspace) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkspaceWhereInput filter on the WorkspaceQuery builder.
func (i *WorkspaceWhereInput) Filter(q *WorkspaceQuery) (*WorkspaceQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkspaceWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkspaceWhereInput is returned in case the WorkspaceWhereInput is empty.
var ErrEmptyWorkspaceWhereInput = errors.New("ent: empty predicate WorkspaceWhereInput")

// P returns a predicate for filtering workspaces.
// An error is returned if the input is empty or invalid.
func (i *WorkspaceWhereInput) P() (predicate.Workspace, error) {
	var predicates []predicate.Workspace
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workspace.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.Workspace, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workspace.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.Workspace, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workspace.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workspace.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workspace.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workspace.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workspace.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workspace.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workspace.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workspace.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workspace.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, workspace.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, workspace.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workspace.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workspace.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workspace.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workspace.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workspace.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workspace.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workspace.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workspace.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, workspace.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, workspace.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, workspace.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, workspace.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, workspace.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, workspace.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, workspace.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, workspace.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, workspace.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, workspace.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, workspace.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, workspace.UpdatedAtNotNil())
	}
	if i.Name != nil {
		predicates = append(predicates, workspace.NameEQ(*i.Name))
	}
	if i.NameNEQ != nil {
		predicates = append(predicates, workspace.NameNEQ(*i.NameNEQ))
	}
	if len(i.NameIn) > 0 {
		predicates = append(predicates, workspace.NameIn(i.NameIn...))
	}
	if len(i.NameNotIn) > 0 {
		predicates = append(predicates, workspace.NameNotIn(i.NameNotIn...))
	}
	if i.NameGT != nil {
		predicates = append(predicates, workspace.NameGT(*i.NameGT))
	}
	if i.NameGTE != nil {
		predicates = append(predicates, workspace.NameGTE(*i.NameGTE))
	}
	if i.NameLT != nil {
		predicates = append(predicates, workspace.NameLT(*i.NameLT))
	}
	if i.NameLTE != nil {
		predicates = append(predicates, workspace.NameLTE(*i.NameLTE))
	}
	if i.NameContains != nil {
		predicates = append(predicates, workspace.NameContains(*i.NameContains))
	}
	if i.NameHasPrefix != nil {
		predicates = append(predicates, workspace.NameHasPrefix(*i.NameHasPrefix))
	}
	if i.NameHasSuffix != nil {
		predicates = append(predicates, workspace.NameHasSuffix(*i.NameHasSuffix))
	}
	if i.NameIsNil {
		predicates = append(predicates, workspace.NameIsNil())
	}
	if i.NameNotNil {
		predicates = append(predicates, workspace.NameNotNil())
	}
	if i.NameEqualFold != nil {
		predicates = append(predicates, workspace.NameEqualFold(*i.NameEqualFold))
	}
	if i.NameContainsFold != nil {
		predicates = append(predicates, workspace.NameContainsFold(*i.NameContainsFold))
	}
	if i.IsPersonal != nil {
		predicates = append(predicates, workspace.IsPersonalEQ(*i.IsPersonal))
	}
	if i.IsPersonalNEQ != nil {
		predicates = append(predicates, workspace.IsPersonalNEQ(*i.IsPersonalNEQ))
	}
	if i.IsPersonalIsNil {
		predicates = append(predicates, workspace.IsPersonalIsNil())
	}
	if i.IsPersonalNotNil {
		predicates = append(predicates, workspace.IsPersonalNotNil())
	}
	if i.UserID != nil {
		predicates = append(predicates, workspace.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, workspace.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, workspace.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, workspace.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, workspace.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, workspace.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, workspace.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, workspace.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, workspace.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, workspace.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, workspace.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDIsNil {
		predicates = append(predicates, workspace.UserIDIsNil())
	}
	if i.UserIDNotNil {
		predicates = append(predicates, workspace.UserIDNotNil())
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, workspace.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, workspace.UserIDContainsFold(*i.UserIDContainsFold))
	}

	if i.HasUsers != nil {
		p := workspace.HasUsers()
		if !*i.HasUsers {
			p = workspace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUsersWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUsersWith))
		for _, w := range i.HasUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspace.HasUsersWith(with...))
	}
	if i.HasWorkspaceInvites != nil {
		p := workspace.HasWorkspaceInvites()
		if !*i.HasWorkspaceInvites {
			p = workspace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkspaceInvitesWith) > 0 {
		with := make([]predicate.WorkspaceInvite, 0, len(i.HasWorkspaceInvitesWith))
		for _, w := range i.HasWorkspaceInvitesWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkspaceInvitesWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspace.HasWorkspaceInvitesWith(with...))
	}
	if i.HasWorkspaceUsers != nil {
		p := workspace.HasWorkspaceUsers()
		if !*i.HasWorkspaceUsers {
			p = workspace.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkspaceUsersWith) > 0 {
		with := make([]predicate.WorkspaceUser, 0, len(i.HasWorkspaceUsersWith))
		for _, w := range i.HasWorkspaceUsersWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkspaceUsersWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspace.HasWorkspaceUsersWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkspaceWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workspace.And(predicates...), nil
	}
}

// WorkspaceInviteWhereInput represents a where input for filtering WorkspaceInvite queries.
type WorkspaceInviteWhereInput struct {
	Predicates []predicate.WorkspaceInvite  `json:"-"`
	Not        *WorkspaceInviteWhereInput   `json:"not,omitempty"`
	Or         []*WorkspaceInviteWhereInput `json:"or,omitempty"`
	And        []*WorkspaceInviteWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "workspace_id" field predicates.
	WorkspaceID             *string  `json:"workspaceID,omitempty"`
	WorkspaceIDNEQ          *string  `json:"workspaceIDNEQ,omitempty"`
	WorkspaceIDIn           []string `json:"workspaceIDIn,omitempty"`
	WorkspaceIDNotIn        []string `json:"workspaceIDNotIn,omitempty"`
	WorkspaceIDGT           *string  `json:"workspaceIDGT,omitempty"`
	WorkspaceIDGTE          *string  `json:"workspaceIDGTE,omitempty"`
	WorkspaceIDLT           *string  `json:"workspaceIDLT,omitempty"`
	WorkspaceIDLTE          *string  `json:"workspaceIDLTE,omitempty"`
	WorkspaceIDContains     *string  `json:"workspaceIDContains,omitempty"`
	WorkspaceIDHasPrefix    *string  `json:"workspaceIDHasPrefix,omitempty"`
	WorkspaceIDHasSuffix    *string  `json:"workspaceIDHasSuffix,omitempty"`
	WorkspaceIDIsNil        bool     `json:"workspaceIDIsNil,omitempty"`
	WorkspaceIDNotNil       bool     `json:"workspaceIDNotNil,omitempty"`
	WorkspaceIDEqualFold    *string  `json:"workspaceIDEqualFold,omitempty"`
	WorkspaceIDContainsFold *string  `json:"workspaceIDContainsFold,omitempty"`

	// "email" field predicates.
	Email             *string  `json:"email,omitempty"`
	EmailNEQ          *string  `json:"emailNEQ,omitempty"`
	EmailIn           []string `json:"emailIn,omitempty"`
	EmailNotIn        []string `json:"emailNotIn,omitempty"`
	EmailGT           *string  `json:"emailGT,omitempty"`
	EmailGTE          *string  `json:"emailGTE,omitempty"`
	EmailLT           *string  `json:"emailLT,omitempty"`
	EmailLTE          *string  `json:"emailLTE,omitempty"`
	EmailContains     *string  `json:"emailContains,omitempty"`
	EmailHasPrefix    *string  `json:"emailHasPrefix,omitempty"`
	EmailHasSuffix    *string  `json:"emailHasSuffix,omitempty"`
	EmailIsNil        bool     `json:"emailIsNil,omitempty"`
	EmailNotNil       bool     `json:"emailNotNil,omitempty"`
	EmailEqualFold    *string  `json:"emailEqualFold,omitempty"`
	EmailContainsFold *string  `json:"emailContainsFold,omitempty"`

	// "role" field predicates.
	Role             *string  `json:"role,omitempty"`
	RoleNEQ          *string  `json:"roleNEQ,omitempty"`
	RoleIn           []string `json:"roleIn,omitempty"`
	RoleNotIn        []string `json:"roleNotIn,omitempty"`
	RoleGT           *string  `json:"roleGT,omitempty"`
	RoleGTE          *string  `json:"roleGTE,omitempty"`
	RoleLT           *string  `json:"roleLT,omitempty"`
	RoleLTE          *string  `json:"roleLTE,omitempty"`
	RoleContains     *string  `json:"roleContains,omitempty"`
	RoleHasPrefix    *string  `json:"roleHasPrefix,omitempty"`
	RoleHasSuffix    *string  `json:"roleHasSuffix,omitempty"`
	RoleIsNil        bool     `json:"roleIsNil,omitempty"`
	RoleNotNil       bool     `json:"roleNotNil,omitempty"`
	RoleEqualFold    *string  `json:"roleEqualFold,omitempty"`
	RoleContainsFold *string  `json:"roleContainsFold,omitempty"`

	// "workspace" edge predicates.
	HasWorkspace     *bool                  `json:"hasWorkspace,omitempty"`
	HasWorkspaceWith []*WorkspaceWhereInput `json:"hasWorkspaceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkspaceInviteWhereInput) AddPredicates(predicates ...predicate.WorkspaceInvite) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkspaceInviteWhereInput filter on the WorkspaceInviteQuery builder.
func (i *WorkspaceInviteWhereInput) Filter(q *WorkspaceInviteQuery) (*WorkspaceInviteQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkspaceInviteWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkspaceInviteWhereInput is returned in case the WorkspaceInviteWhereInput is empty.
var ErrEmptyWorkspaceInviteWhereInput = errors.New("ent: empty predicate WorkspaceInviteWhereInput")

// P returns a predicate for filtering workspaceinvites.
// An error is returned if the input is empty or invalid.
func (i *WorkspaceInviteWhereInput) P() (predicate.WorkspaceInvite, error) {
	var predicates []predicate.WorkspaceInvite
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workspaceinvite.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WorkspaceInvite, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workspaceinvite.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WorkspaceInvite, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workspaceinvite.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workspaceinvite.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workspaceinvite.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workspaceinvite.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workspaceinvite.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workspaceinvite.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workspaceinvite.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workspaceinvite.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workspaceinvite.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, workspaceinvite.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, workspaceinvite.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workspaceinvite.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workspaceinvite.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workspaceinvite.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workspaceinvite.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workspaceinvite.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workspaceinvite.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workspaceinvite.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workspaceinvite.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, workspaceinvite.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, workspaceinvite.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, workspaceinvite.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, workspaceinvite.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, workspaceinvite.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, workspaceinvite.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, workspaceinvite.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, workspaceinvite.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, workspaceinvite.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, workspaceinvite.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, workspaceinvite.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, workspaceinvite.UpdatedAtNotNil())
	}
	if i.WorkspaceID != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDEQ(*i.WorkspaceID))
	}
	if i.WorkspaceIDNEQ != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDNEQ(*i.WorkspaceIDNEQ))
	}
	if len(i.WorkspaceIDIn) > 0 {
		predicates = append(predicates, workspaceinvite.WorkspaceIDIn(i.WorkspaceIDIn...))
	}
	if len(i.WorkspaceIDNotIn) > 0 {
		predicates = append(predicates, workspaceinvite.WorkspaceIDNotIn(i.WorkspaceIDNotIn...))
	}
	if i.WorkspaceIDGT != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDGT(*i.WorkspaceIDGT))
	}
	if i.WorkspaceIDGTE != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDGTE(*i.WorkspaceIDGTE))
	}
	if i.WorkspaceIDLT != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDLT(*i.WorkspaceIDLT))
	}
	if i.WorkspaceIDLTE != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDLTE(*i.WorkspaceIDLTE))
	}
	if i.WorkspaceIDContains != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDContains(*i.WorkspaceIDContains))
	}
	if i.WorkspaceIDHasPrefix != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDHasPrefix(*i.WorkspaceIDHasPrefix))
	}
	if i.WorkspaceIDHasSuffix != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDHasSuffix(*i.WorkspaceIDHasSuffix))
	}
	if i.WorkspaceIDIsNil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDIsNil())
	}
	if i.WorkspaceIDNotNil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDNotNil())
	}
	if i.WorkspaceIDEqualFold != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDEqualFold(*i.WorkspaceIDEqualFold))
	}
	if i.WorkspaceIDContainsFold != nil {
		predicates = append(predicates, workspaceinvite.WorkspaceIDContainsFold(*i.WorkspaceIDContainsFold))
	}
	if i.Email != nil {
		predicates = append(predicates, workspaceinvite.EmailEQ(*i.Email))
	}
	if i.EmailNEQ != nil {
		predicates = append(predicates, workspaceinvite.EmailNEQ(*i.EmailNEQ))
	}
	if len(i.EmailIn) > 0 {
		predicates = append(predicates, workspaceinvite.EmailIn(i.EmailIn...))
	}
	if len(i.EmailNotIn) > 0 {
		predicates = append(predicates, workspaceinvite.EmailNotIn(i.EmailNotIn...))
	}
	if i.EmailGT != nil {
		predicates = append(predicates, workspaceinvite.EmailGT(*i.EmailGT))
	}
	if i.EmailGTE != nil {
		predicates = append(predicates, workspaceinvite.EmailGTE(*i.EmailGTE))
	}
	if i.EmailLT != nil {
		predicates = append(predicates, workspaceinvite.EmailLT(*i.EmailLT))
	}
	if i.EmailLTE != nil {
		predicates = append(predicates, workspaceinvite.EmailLTE(*i.EmailLTE))
	}
	if i.EmailContains != nil {
		predicates = append(predicates, workspaceinvite.EmailContains(*i.EmailContains))
	}
	if i.EmailHasPrefix != nil {
		predicates = append(predicates, workspaceinvite.EmailHasPrefix(*i.EmailHasPrefix))
	}
	if i.EmailHasSuffix != nil {
		predicates = append(predicates, workspaceinvite.EmailHasSuffix(*i.EmailHasSuffix))
	}
	if i.EmailIsNil {
		predicates = append(predicates, workspaceinvite.EmailIsNil())
	}
	if i.EmailNotNil {
		predicates = append(predicates, workspaceinvite.EmailNotNil())
	}
	if i.EmailEqualFold != nil {
		predicates = append(predicates, workspaceinvite.EmailEqualFold(*i.EmailEqualFold))
	}
	if i.EmailContainsFold != nil {
		predicates = append(predicates, workspaceinvite.EmailContainsFold(*i.EmailContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, workspaceinvite.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, workspaceinvite.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, workspaceinvite.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, workspaceinvite.RoleNotIn(i.RoleNotIn...))
	}
	if i.RoleGT != nil {
		predicates = append(predicates, workspaceinvite.RoleGT(*i.RoleGT))
	}
	if i.RoleGTE != nil {
		predicates = append(predicates, workspaceinvite.RoleGTE(*i.RoleGTE))
	}
	if i.RoleLT != nil {
		predicates = append(predicates, workspaceinvite.RoleLT(*i.RoleLT))
	}
	if i.RoleLTE != nil {
		predicates = append(predicates, workspaceinvite.RoleLTE(*i.RoleLTE))
	}
	if i.RoleContains != nil {
		predicates = append(predicates, workspaceinvite.RoleContains(*i.RoleContains))
	}
	if i.RoleHasPrefix != nil {
		predicates = append(predicates, workspaceinvite.RoleHasPrefix(*i.RoleHasPrefix))
	}
	if i.RoleHasSuffix != nil {
		predicates = append(predicates, workspaceinvite.RoleHasSuffix(*i.RoleHasSuffix))
	}
	if i.RoleIsNil {
		predicates = append(predicates, workspaceinvite.RoleIsNil())
	}
	if i.RoleNotNil {
		predicates = append(predicates, workspaceinvite.RoleNotNil())
	}
	if i.RoleEqualFold != nil {
		predicates = append(predicates, workspaceinvite.RoleEqualFold(*i.RoleEqualFold))
	}
	if i.RoleContainsFold != nil {
		predicates = append(predicates, workspaceinvite.RoleContainsFold(*i.RoleContainsFold))
	}

	if i.HasWorkspace != nil {
		p := workspaceinvite.HasWorkspace()
		if !*i.HasWorkspace {
			p = workspaceinvite.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkspaceWith) > 0 {
		with := make([]predicate.Workspace, 0, len(i.HasWorkspaceWith))
		for _, w := range i.HasWorkspaceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkspaceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspaceinvite.HasWorkspaceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkspaceInviteWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workspaceinvite.And(predicates...), nil
	}
}

// WorkspaceUserWhereInput represents a where input for filtering WorkspaceUser queries.
type WorkspaceUserWhereInput struct {
	Predicates []predicate.WorkspaceUser  `json:"-"`
	Not        *WorkspaceUserWhereInput   `json:"not,omitempty"`
	Or         []*WorkspaceUserWhereInput `json:"or,omitempty"`
	And        []*WorkspaceUserWhereInput `json:"and,omitempty"`

	// "id" field predicates.
	ID             *string  `json:"id,omitempty"`
	IDNEQ          *string  `json:"idNEQ,omitempty"`
	IDIn           []string `json:"idIn,omitempty"`
	IDNotIn        []string `json:"idNotIn,omitempty"`
	IDGT           *string  `json:"idGT,omitempty"`
	IDGTE          *string  `json:"idGTE,omitempty"`
	IDLT           *string  `json:"idLT,omitempty"`
	IDLTE          *string  `json:"idLTE,omitempty"`
	IDEqualFold    *string  `json:"idEqualFold,omitempty"`
	IDContainsFold *string  `json:"idContainsFold,omitempty"`

	// "created_at" field predicates.
	CreatedAt       *time.Time  `json:"createdAt,omitempty"`
	CreatedAtNEQ    *time.Time  `json:"createdAtNEQ,omitempty"`
	CreatedAtIn     []time.Time `json:"createdAtIn,omitempty"`
	CreatedAtNotIn  []time.Time `json:"createdAtNotIn,omitempty"`
	CreatedAtGT     *time.Time  `json:"createdAtGT,omitempty"`
	CreatedAtGTE    *time.Time  `json:"createdAtGTE,omitempty"`
	CreatedAtLT     *time.Time  `json:"createdAtLT,omitempty"`
	CreatedAtLTE    *time.Time  `json:"createdAtLTE,omitempty"`
	CreatedAtIsNil  bool        `json:"createdAtIsNil,omitempty"`
	CreatedAtNotNil bool        `json:"createdAtNotNil,omitempty"`

	// "updated_at" field predicates.
	UpdatedAt       *time.Time  `json:"updatedAt,omitempty"`
	UpdatedAtNEQ    *time.Time  `json:"updatedAtNEQ,omitempty"`
	UpdatedAtIn     []time.Time `json:"updatedAtIn,omitempty"`
	UpdatedAtNotIn  []time.Time `json:"updatedAtNotIn,omitempty"`
	UpdatedAtGT     *time.Time  `json:"updatedAtGT,omitempty"`
	UpdatedAtGTE    *time.Time  `json:"updatedAtGTE,omitempty"`
	UpdatedAtLT     *time.Time  `json:"updatedAtLT,omitempty"`
	UpdatedAtLTE    *time.Time  `json:"updatedAtLTE,omitempty"`
	UpdatedAtIsNil  bool        `json:"updatedAtIsNil,omitempty"`
	UpdatedAtNotNil bool        `json:"updatedAtNotNil,omitempty"`

	// "workspace_id" field predicates.
	WorkspaceID             *string  `json:"workspaceID,omitempty"`
	WorkspaceIDNEQ          *string  `json:"workspaceIDNEQ,omitempty"`
	WorkspaceIDIn           []string `json:"workspaceIDIn,omitempty"`
	WorkspaceIDNotIn        []string `json:"workspaceIDNotIn,omitempty"`
	WorkspaceIDGT           *string  `json:"workspaceIDGT,omitempty"`
	WorkspaceIDGTE          *string  `json:"workspaceIDGTE,omitempty"`
	WorkspaceIDLT           *string  `json:"workspaceIDLT,omitempty"`
	WorkspaceIDLTE          *string  `json:"workspaceIDLTE,omitempty"`
	WorkspaceIDContains     *string  `json:"workspaceIDContains,omitempty"`
	WorkspaceIDHasPrefix    *string  `json:"workspaceIDHasPrefix,omitempty"`
	WorkspaceIDHasSuffix    *string  `json:"workspaceIDHasSuffix,omitempty"`
	WorkspaceIDEqualFold    *string  `json:"workspaceIDEqualFold,omitempty"`
	WorkspaceIDContainsFold *string  `json:"workspaceIDContainsFold,omitempty"`

	// "user_id" field predicates.
	UserID             *string  `json:"userID,omitempty"`
	UserIDNEQ          *string  `json:"userIDNEQ,omitempty"`
	UserIDIn           []string `json:"userIDIn,omitempty"`
	UserIDNotIn        []string `json:"userIDNotIn,omitempty"`
	UserIDGT           *string  `json:"userIDGT,omitempty"`
	UserIDGTE          *string  `json:"userIDGTE,omitempty"`
	UserIDLT           *string  `json:"userIDLT,omitempty"`
	UserIDLTE          *string  `json:"userIDLTE,omitempty"`
	UserIDContains     *string  `json:"userIDContains,omitempty"`
	UserIDHasPrefix    *string  `json:"userIDHasPrefix,omitempty"`
	UserIDHasSuffix    *string  `json:"userIDHasSuffix,omitempty"`
	UserIDEqualFold    *string  `json:"userIDEqualFold,omitempty"`
	UserIDContainsFold *string  `json:"userIDContainsFold,omitempty"`

	// "role" field predicates.
	Role             *string  `json:"role,omitempty"`
	RoleNEQ          *string  `json:"roleNEQ,omitempty"`
	RoleIn           []string `json:"roleIn,omitempty"`
	RoleNotIn        []string `json:"roleNotIn,omitempty"`
	RoleGT           *string  `json:"roleGT,omitempty"`
	RoleGTE          *string  `json:"roleGTE,omitempty"`
	RoleLT           *string  `json:"roleLT,omitempty"`
	RoleLTE          *string  `json:"roleLTE,omitempty"`
	RoleContains     *string  `json:"roleContains,omitempty"`
	RoleHasPrefix    *string  `json:"roleHasPrefix,omitempty"`
	RoleHasSuffix    *string  `json:"roleHasSuffix,omitempty"`
	RoleIsNil        bool     `json:"roleIsNil,omitempty"`
	RoleNotNil       bool     `json:"roleNotNil,omitempty"`
	RoleEqualFold    *string  `json:"roleEqualFold,omitempty"`
	RoleContainsFold *string  `json:"roleContainsFold,omitempty"`

	// "user" edge predicates.
	HasUser     *bool             `json:"hasUser,omitempty"`
	HasUserWith []*UserWhereInput `json:"hasUserWith,omitempty"`

	// "workspace" edge predicates.
	HasWorkspace     *bool                  `json:"hasWorkspace,omitempty"`
	HasWorkspaceWith []*WorkspaceWhereInput `json:"hasWorkspaceWith,omitempty"`
}

// AddPredicates adds custom predicates to the where input to be used during the filtering phase.
func (i *WorkspaceUserWhereInput) AddPredicates(predicates ...predicate.WorkspaceUser) {
	i.Predicates = append(i.Predicates, predicates...)
}

// Filter applies the WorkspaceUserWhereInput filter on the WorkspaceUserQuery builder.
func (i *WorkspaceUserWhereInput) Filter(q *WorkspaceUserQuery) (*WorkspaceUserQuery, error) {
	if i == nil {
		return q, nil
	}
	p, err := i.P()
	if err != nil {
		if err == ErrEmptyWorkspaceUserWhereInput {
			return q, nil
		}
		return nil, err
	}
	return q.Where(p), nil
}

// ErrEmptyWorkspaceUserWhereInput is returned in case the WorkspaceUserWhereInput is empty.
var ErrEmptyWorkspaceUserWhereInput = errors.New("ent: empty predicate WorkspaceUserWhereInput")

// P returns a predicate for filtering workspaceusers.
// An error is returned if the input is empty or invalid.
func (i *WorkspaceUserWhereInput) P() (predicate.WorkspaceUser, error) {
	var predicates []predicate.WorkspaceUser
	if i.Not != nil {
		p, err := i.Not.P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'not'", err)
		}
		predicates = append(predicates, workspaceuser.Not(p))
	}
	switch n := len(i.Or); {
	case n == 1:
		p, err := i.Or[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'or'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		or := make([]predicate.WorkspaceUser, 0, n)
		for _, w := range i.Or {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'or'", err)
			}
			or = append(or, p)
		}
		predicates = append(predicates, workspaceuser.Or(or...))
	}
	switch n := len(i.And); {
	case n == 1:
		p, err := i.And[0].P()
		if err != nil {
			return nil, fmt.Errorf("%w: field 'and'", err)
		}
		predicates = append(predicates, p)
	case n > 1:
		and := make([]predicate.WorkspaceUser, 0, n)
		for _, w := range i.And {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'and'", err)
			}
			and = append(and, p)
		}
		predicates = append(predicates, workspaceuser.And(and...))
	}
	predicates = append(predicates, i.Predicates...)
	if i.ID != nil {
		predicates = append(predicates, workspaceuser.IDEQ(*i.ID))
	}
	if i.IDNEQ != nil {
		predicates = append(predicates, workspaceuser.IDNEQ(*i.IDNEQ))
	}
	if len(i.IDIn) > 0 {
		predicates = append(predicates, workspaceuser.IDIn(i.IDIn...))
	}
	if len(i.IDNotIn) > 0 {
		predicates = append(predicates, workspaceuser.IDNotIn(i.IDNotIn...))
	}
	if i.IDGT != nil {
		predicates = append(predicates, workspaceuser.IDGT(*i.IDGT))
	}
	if i.IDGTE != nil {
		predicates = append(predicates, workspaceuser.IDGTE(*i.IDGTE))
	}
	if i.IDLT != nil {
		predicates = append(predicates, workspaceuser.IDLT(*i.IDLT))
	}
	if i.IDLTE != nil {
		predicates = append(predicates, workspaceuser.IDLTE(*i.IDLTE))
	}
	if i.IDEqualFold != nil {
		predicates = append(predicates, workspaceuser.IDEqualFold(*i.IDEqualFold))
	}
	if i.IDContainsFold != nil {
		predicates = append(predicates, workspaceuser.IDContainsFold(*i.IDContainsFold))
	}
	if i.CreatedAt != nil {
		predicates = append(predicates, workspaceuser.CreatedAtEQ(*i.CreatedAt))
	}
	if i.CreatedAtNEQ != nil {
		predicates = append(predicates, workspaceuser.CreatedAtNEQ(*i.CreatedAtNEQ))
	}
	if len(i.CreatedAtIn) > 0 {
		predicates = append(predicates, workspaceuser.CreatedAtIn(i.CreatedAtIn...))
	}
	if len(i.CreatedAtNotIn) > 0 {
		predicates = append(predicates, workspaceuser.CreatedAtNotIn(i.CreatedAtNotIn...))
	}
	if i.CreatedAtGT != nil {
		predicates = append(predicates, workspaceuser.CreatedAtGT(*i.CreatedAtGT))
	}
	if i.CreatedAtGTE != nil {
		predicates = append(predicates, workspaceuser.CreatedAtGTE(*i.CreatedAtGTE))
	}
	if i.CreatedAtLT != nil {
		predicates = append(predicates, workspaceuser.CreatedAtLT(*i.CreatedAtLT))
	}
	if i.CreatedAtLTE != nil {
		predicates = append(predicates, workspaceuser.CreatedAtLTE(*i.CreatedAtLTE))
	}
	if i.CreatedAtIsNil {
		predicates = append(predicates, workspaceuser.CreatedAtIsNil())
	}
	if i.CreatedAtNotNil {
		predicates = append(predicates, workspaceuser.CreatedAtNotNil())
	}
	if i.UpdatedAt != nil {
		predicates = append(predicates, workspaceuser.UpdatedAtEQ(*i.UpdatedAt))
	}
	if i.UpdatedAtNEQ != nil {
		predicates = append(predicates, workspaceuser.UpdatedAtNEQ(*i.UpdatedAtNEQ))
	}
	if len(i.UpdatedAtIn) > 0 {
		predicates = append(predicates, workspaceuser.UpdatedAtIn(i.UpdatedAtIn...))
	}
	if len(i.UpdatedAtNotIn) > 0 {
		predicates = append(predicates, workspaceuser.UpdatedAtNotIn(i.UpdatedAtNotIn...))
	}
	if i.UpdatedAtGT != nil {
		predicates = append(predicates, workspaceuser.UpdatedAtGT(*i.UpdatedAtGT))
	}
	if i.UpdatedAtGTE != nil {
		predicates = append(predicates, workspaceuser.UpdatedAtGTE(*i.UpdatedAtGTE))
	}
	if i.UpdatedAtLT != nil {
		predicates = append(predicates, workspaceuser.UpdatedAtLT(*i.UpdatedAtLT))
	}
	if i.UpdatedAtLTE != nil {
		predicates = append(predicates, workspaceuser.UpdatedAtLTE(*i.UpdatedAtLTE))
	}
	if i.UpdatedAtIsNil {
		predicates = append(predicates, workspaceuser.UpdatedAtIsNil())
	}
	if i.UpdatedAtNotNil {
		predicates = append(predicates, workspaceuser.UpdatedAtNotNil())
	}
	if i.WorkspaceID != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDEQ(*i.WorkspaceID))
	}
	if i.WorkspaceIDNEQ != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDNEQ(*i.WorkspaceIDNEQ))
	}
	if len(i.WorkspaceIDIn) > 0 {
		predicates = append(predicates, workspaceuser.WorkspaceIDIn(i.WorkspaceIDIn...))
	}
	if len(i.WorkspaceIDNotIn) > 0 {
		predicates = append(predicates, workspaceuser.WorkspaceIDNotIn(i.WorkspaceIDNotIn...))
	}
	if i.WorkspaceIDGT != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDGT(*i.WorkspaceIDGT))
	}
	if i.WorkspaceIDGTE != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDGTE(*i.WorkspaceIDGTE))
	}
	if i.WorkspaceIDLT != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDLT(*i.WorkspaceIDLT))
	}
	if i.WorkspaceIDLTE != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDLTE(*i.WorkspaceIDLTE))
	}
	if i.WorkspaceIDContains != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDContains(*i.WorkspaceIDContains))
	}
	if i.WorkspaceIDHasPrefix != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDHasPrefix(*i.WorkspaceIDHasPrefix))
	}
	if i.WorkspaceIDHasSuffix != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDHasSuffix(*i.WorkspaceIDHasSuffix))
	}
	if i.WorkspaceIDEqualFold != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDEqualFold(*i.WorkspaceIDEqualFold))
	}
	if i.WorkspaceIDContainsFold != nil {
		predicates = append(predicates, workspaceuser.WorkspaceIDContainsFold(*i.WorkspaceIDContainsFold))
	}
	if i.UserID != nil {
		predicates = append(predicates, workspaceuser.UserIDEQ(*i.UserID))
	}
	if i.UserIDNEQ != nil {
		predicates = append(predicates, workspaceuser.UserIDNEQ(*i.UserIDNEQ))
	}
	if len(i.UserIDIn) > 0 {
		predicates = append(predicates, workspaceuser.UserIDIn(i.UserIDIn...))
	}
	if len(i.UserIDNotIn) > 0 {
		predicates = append(predicates, workspaceuser.UserIDNotIn(i.UserIDNotIn...))
	}
	if i.UserIDGT != nil {
		predicates = append(predicates, workspaceuser.UserIDGT(*i.UserIDGT))
	}
	if i.UserIDGTE != nil {
		predicates = append(predicates, workspaceuser.UserIDGTE(*i.UserIDGTE))
	}
	if i.UserIDLT != nil {
		predicates = append(predicates, workspaceuser.UserIDLT(*i.UserIDLT))
	}
	if i.UserIDLTE != nil {
		predicates = append(predicates, workspaceuser.UserIDLTE(*i.UserIDLTE))
	}
	if i.UserIDContains != nil {
		predicates = append(predicates, workspaceuser.UserIDContains(*i.UserIDContains))
	}
	if i.UserIDHasPrefix != nil {
		predicates = append(predicates, workspaceuser.UserIDHasPrefix(*i.UserIDHasPrefix))
	}
	if i.UserIDHasSuffix != nil {
		predicates = append(predicates, workspaceuser.UserIDHasSuffix(*i.UserIDHasSuffix))
	}
	if i.UserIDEqualFold != nil {
		predicates = append(predicates, workspaceuser.UserIDEqualFold(*i.UserIDEqualFold))
	}
	if i.UserIDContainsFold != nil {
		predicates = append(predicates, workspaceuser.UserIDContainsFold(*i.UserIDContainsFold))
	}
	if i.Role != nil {
		predicates = append(predicates, workspaceuser.RoleEQ(*i.Role))
	}
	if i.RoleNEQ != nil {
		predicates = append(predicates, workspaceuser.RoleNEQ(*i.RoleNEQ))
	}
	if len(i.RoleIn) > 0 {
		predicates = append(predicates, workspaceuser.RoleIn(i.RoleIn...))
	}
	if len(i.RoleNotIn) > 0 {
		predicates = append(predicates, workspaceuser.RoleNotIn(i.RoleNotIn...))
	}
	if i.RoleGT != nil {
		predicates = append(predicates, workspaceuser.RoleGT(*i.RoleGT))
	}
	if i.RoleGTE != nil {
		predicates = append(predicates, workspaceuser.RoleGTE(*i.RoleGTE))
	}
	if i.RoleLT != nil {
		predicates = append(predicates, workspaceuser.RoleLT(*i.RoleLT))
	}
	if i.RoleLTE != nil {
		predicates = append(predicates, workspaceuser.RoleLTE(*i.RoleLTE))
	}
	if i.RoleContains != nil {
		predicates = append(predicates, workspaceuser.RoleContains(*i.RoleContains))
	}
	if i.RoleHasPrefix != nil {
		predicates = append(predicates, workspaceuser.RoleHasPrefix(*i.RoleHasPrefix))
	}
	if i.RoleHasSuffix != nil {
		predicates = append(predicates, workspaceuser.RoleHasSuffix(*i.RoleHasSuffix))
	}
	if i.RoleIsNil {
		predicates = append(predicates, workspaceuser.RoleIsNil())
	}
	if i.RoleNotNil {
		predicates = append(predicates, workspaceuser.RoleNotNil())
	}
	if i.RoleEqualFold != nil {
		predicates = append(predicates, workspaceuser.RoleEqualFold(*i.RoleEqualFold))
	}
	if i.RoleContainsFold != nil {
		predicates = append(predicates, workspaceuser.RoleContainsFold(*i.RoleContainsFold))
	}

	if i.HasUser != nil {
		p := workspaceuser.HasUser()
		if !*i.HasUser {
			p = workspaceuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasUserWith) > 0 {
		with := make([]predicate.User, 0, len(i.HasUserWith))
		for _, w := range i.HasUserWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasUserWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspaceuser.HasUserWith(with...))
	}
	if i.HasWorkspace != nil {
		p := workspaceuser.HasWorkspace()
		if !*i.HasWorkspace {
			p = workspaceuser.Not(p)
		}
		predicates = append(predicates, p)
	}
	if len(i.HasWorkspaceWith) > 0 {
		with := make([]predicate.Workspace, 0, len(i.HasWorkspaceWith))
		for _, w := range i.HasWorkspaceWith {
			p, err := w.P()
			if err != nil {
				return nil, fmt.Errorf("%w: field 'HasWorkspaceWith'", err)
			}
			with = append(with, p)
		}
		predicates = append(predicates, workspaceuser.HasWorkspaceWith(with...))
	}
	switch len(predicates) {
	case 0:
		return nil, ErrEmptyWorkspaceUserWhereInput
	case 1:
		return predicates[0], nil
	default:
		return workspaceuser.And(predicates...), nil
	}
}
