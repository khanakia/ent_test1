// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"database/sql/driver"
	"fmt"
	"saas/gen/ent/mediable"
	"saas/gen/ent/predicate"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
)

var mediaUrlResolver func(ctx context.Context, media *Media) (string, error)

func SetMediaURLResolver(fn func(ctx context.Context, media *Media) (string, error)) {
	mediaUrlResolver = fn
}

type SaveMediaProp struct {
	Tag            string
	Order          int
	AppID          string
	MediableType   string
	MediableID     string
	AddMediaIDs    []string
	RemoveMediaIDs []string
	Cleared        bool
	SelectMediaIDs []string
}

func SaveMedia(client *Client, props *SaveMediaProp) {
	ctx := context.Background()

	if props.Cleared {
		client.Mediable.Delete().Where(mediable.AppID(props.AppID), mediable.MediableType(props.MediableType), mediable.MediableID(props.MediableID)).Exec(ctx)
	}

	if props.RemoveMediaIDs != nil {
		client.Mediable.Delete().Where(mediable.AppID(props.AppID), mediable.MediableType(props.MediableType), mediable.MediableID(props.MediableID), mediable.MediaIDIn(props.RemoveMediaIDs...)).Exec(ctx)
	}

	if props.AddMediaIDs != nil {
		for i, mediaID := range props.AddMediaIDs {
			client.Mediable.Create().
				SetAppID(props.AppID).
				SetTag(props.Tag).
				SetSortOrder(i).
				SetMediableType(props.MediableType).
				SetMediableID(props.MediableID).
				SetMediaID(mediaID).
				Save(ctx)
		}
	}

	if props.SelectMediaIDs != nil {
		for i, id := range props.SelectMediaIDs {
			client.Mediable.Update().
				Where(mediable.AppID(props.AppID), mediable.MediableType(props.MediableType), mediable.MediableID(props.MediableID), mediable.MediaID(id)).
				SetSortOrder(i).
				Save(ctx)
		}
	}
}

func PostClientMediaHook() func(next ent.Mutator) ent.Mutator {
	return func(next ent.Mutator) ent.Mutator {
		return ent.MutateFunc(func(ctx context.Context, m ent.Mutation) (ent.Value, error) {
			fmt.Printf("Type11: %s, Operation: %s, ConcreteType: %T\n", m.Type(), m.Op(), m)

			if s, ok := m.(*PostMutation); ok {
				{
					id, _ := s.ID()

					saveMediaProp := SaveMediaProp{
						Tag:            "featured",
						Order:          0,
						AppID:          "a2",
						MediableType:   "posts",
						MediableID:     id,
						AddMediaIDs:    s.FeaturedMediaIDs(),
						RemoveMediaIDs: s.RemovedFeaturedMediaIDs(),
						Cleared:        s.FeaturedMediasCleared(),
						SelectMediaIDs: s.SelectedFeaturedMediaIDs(),
					}

					SaveMedia(s.Client(), &saveMediaProp)

				}
				{
					id, _ := s.ID()

					saveMediaProp := SaveMediaProp{
						Tag:            "icon",
						Order:          0,
						AppID:          "a2",
						MediableType:   "posts",
						MediableID:     id,
						AddMediaIDs:    s.IconMediaIDs(),
						RemoveMediaIDs: s.RemovedIconMediaIDs(),
						Cleared:        s.IconMediasCleared(),
						SelectMediaIDs: s.SelectedIconMediaIDs(),
					}

					SaveMedia(s.Client(), &saveMediaProp)

				}
			}
			return next.Mutate(ctx, m)
		})
	}
}

func (m *PostMutation) AddFeaturedMediaIDs(ids ...string) {
	if m.featured_medias == nil {
		m.featured_medias = make(map[string]struct{})
	}
	for i := range ids {
		m.featured_medias[ids[i]] = struct{}{}
	}
}

func (m *PostMutation) ClearFeaturedMedias() {
	m.clearedfeatured_medias = true
}

func (m *PostMutation) FeaturedMediasCleared() bool {
	return m.clearedfeatured_medias
}

func (m *PostMutation) RemoveFeaturedMediaIDs(ids ...string) {
	if m.removedfeatured_medias == nil {
		m.removedfeatured_medias = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.featured_medias, ids[i])
		m.removedfeatured_medias[ids[i]] = struct{}{}
	}
}

func (m *PostMutation) SelectFeaturedMediaIDs(ids ...string) {
	if m.selectedfeatured_medias == nil {
		m.selectedfeatured_medias = []string{}
	}
	for i := range ids {
		m.selectedfeatured_medias = append(m.selectedfeatured_medias, ids[i])
	}
}

func (m *PostMutation) SelectedFeaturedMediaIDs() (ids []string) {
	return m.selectedfeatured_medias
}

func (m *PostMutation) RemovedFeaturedMediaIDs() (ids []string) {
	for id := range m.removedfeatured_medias {
		ids = append(ids, id)
	}
	return
}

func (m *PostMutation) FeaturedMediaIDs() (ids []string) {
	for id := range m.featured_medias {
		ids = append(ids, id)
	}
	return
}

func (m *PostMutation) ResetFeaturedMedias() {
	m.featured_medias = nil
	m.clearedfeatured_medias = false
	m.removedfeatured_medias = nil
	m.selectedfeatured_medias = nil
}

func (m *PostMutation) AddIconMediaIDs(ids ...string) {
	if m.icon_medias == nil {
		m.icon_medias = make(map[string]struct{})
	}
	for i := range ids {
		m.icon_medias[ids[i]] = struct{}{}
	}
}

func (m *PostMutation) ClearIconMedias() {
	m.clearedicon_medias = true
}

func (m *PostMutation) IconMediasCleared() bool {
	return m.clearedicon_medias
}

func (m *PostMutation) RemoveIconMediaIDs(ids ...string) {
	if m.removedicon_medias == nil {
		m.removedicon_medias = make(map[string]struct{})
	}
	for i := range ids {
		delete(m.icon_medias, ids[i])
		m.removedicon_medias[ids[i]] = struct{}{}
	}
}

func (m *PostMutation) SelectIconMediaIDs(ids ...string) {
	if m.selectedicon_medias == nil {
		m.selectedicon_medias = []string{}
	}
	for i := range ids {
		m.selectedicon_medias = append(m.selectedicon_medias, ids[i])
	}
}

func (m *PostMutation) SelectedIconMediaIDs() (ids []string) {
	return m.selectedicon_medias
}

func (m *PostMutation) RemovedIconMediaIDs() (ids []string) {
	for id := range m.removedicon_medias {
		ids = append(ids, id)
	}
	return
}

func (m *PostMutation) IconMediaIDs() (ids []string) {
	for id := range m.icon_medias {
		ids = append(ids, id)
	}
	return
}

func (m *PostMutation) ResetIconMedias() {
	m.icon_medias = nil
	m.clearedicon_medias = false
	m.removedicon_medias = nil
	m.selectedicon_medias = nil
}
func (uq *MediaQuery) loadUrls(ctx context.Context, nodes []*Media) error {
	for _, n := range nodes {
		/* n.URL = "http://localhost/" + n.Name */
		if mediaUrlResolver != nil {
			url, _ := mediaUrlResolver(ctx, n)
			n.URL = url
		}
	}
	return nil
}
func (uq *PostQuery) WithMediables(opts ...func(*MediableQuery)) *PostQuery {
	query := (&MediableClient{config: uq.config}).Query()
	for _, opt := range opts {
		opt(query)
	}
	uq.withMediables = query
	return uq
}

func (uq *PostQuery) loadMediables(ctx context.Context, query *MediableQuery, nodes []*Post, init func(*Post), assign func(*Post, *Mediable)) error {
	fks := make([]driver.Value, 0, len(nodes))
	nodeids := make(map[string]*Post)
	for i := range nodes {
		fks = append(fks, nodes[i].ID)
		nodeids[nodes[i].ID] = nodes[i]
		if init != nil {
			init(nodes[i])
		}
	}
	if len(query.ctx.Fields) > 0 {
		query.ctx.AppendFieldOnce(mediable.FieldMediableID)
	}

	query.Where(mediable.MediableType("posts"))
	query.Order(Asc(mediable.FieldSortOrder))

	query.WithMedia().Where(predicate.Mediable(func(s *sql.Selector) {
		s.Where(sql.InValues(s.C(mediable.FieldMediableID), fks...))
	}))
	neighbors, err := query.All(ctx)
	if err != nil {
		return err
	}
	for _, n := range neighbors {
		fk := n.MediableID
		node, ok := nodeids[fk]
		if !ok {
			return fmt.Errorf(`unexpected referenced foreign-key "mediable_id" returned %v for node %v`, fk, n.ID)
		}
		assign(node, n)
	}
	return nil
}
