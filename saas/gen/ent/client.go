// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"saas/gen/ent/migrate"

	"saas/gen/ent/adminuser"
	"saas/gen/ent/app"
	"saas/gen/ent/kache"
	"saas/gen/ent/keyvalue"
	"saas/gen/ent/mailconn"
	"saas/gen/ent/media"
	"saas/gen/ent/oauthconnection"
	"saas/gen/ent/plan"
	"saas/gen/ent/post"
	"saas/gen/ent/postcategory"
	"saas/gen/ent/poststatus"
	"saas/gen/ent/posttag"
	"saas/gen/ent/posttype"
	"saas/gen/ent/posttypeform"
	"saas/gen/ent/session"
	"saas/gen/ent/temp"
	"saas/gen/ent/templ"
	"saas/gen/ent/todo"
	"saas/gen/ent/user"
	"saas/gen/ent/workspace"
	"saas/gen/ent/workspaceinvite"
	"saas/gen/ent/workspaceuser"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"

	stdsql "database/sql"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// AdminUser is the client for interacting with the AdminUser builders.
	AdminUser *AdminUserClient
	// App is the client for interacting with the App builders.
	App *AppClient
	// Kache is the client for interacting with the Kache builders.
	Kache *KacheClient
	// Keyvalue is the client for interacting with the Keyvalue builders.
	Keyvalue *KeyvalueClient
	// MailConn is the client for interacting with the MailConn builders.
	MailConn *MailConnClient
	// Media is the client for interacting with the Media builders.
	Media *MediaClient
	// OauthConnection is the client for interacting with the OauthConnection builders.
	OauthConnection *OauthConnectionClient
	// Plan is the client for interacting with the Plan builders.
	Plan *PlanClient
	// Post is the client for interacting with the Post builders.
	Post *PostClient
	// PostCategory is the client for interacting with the PostCategory builders.
	PostCategory *PostCategoryClient
	// PostStatus is the client for interacting with the PostStatus builders.
	PostStatus *PostStatusClient
	// PostTag is the client for interacting with the PostTag builders.
	PostTag *PostTagClient
	// PostType is the client for interacting with the PostType builders.
	PostType *PostTypeClient
	// PostTypeForm is the client for interacting with the PostTypeForm builders.
	PostTypeForm *PostTypeFormClient
	// Session is the client for interacting with the Session builders.
	Session *SessionClient
	// Temp is the client for interacting with the Temp builders.
	Temp *TempClient
	// Templ is the client for interacting with the Templ builders.
	Templ *TemplClient
	// Todo is the client for interacting with the Todo builders.
	Todo *TodoClient
	// User is the client for interacting with the User builders.
	User *UserClient
	// Workspace is the client for interacting with the Workspace builders.
	Workspace *WorkspaceClient
	// WorkspaceInvite is the client for interacting with the WorkspaceInvite builders.
	WorkspaceInvite *WorkspaceInviteClient
	// WorkspaceUser is the client for interacting with the WorkspaceUser builders.
	WorkspaceUser *WorkspaceUserClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.AdminUser = NewAdminUserClient(c.config)
	c.App = NewAppClient(c.config)
	c.Kache = NewKacheClient(c.config)
	c.Keyvalue = NewKeyvalueClient(c.config)
	c.MailConn = NewMailConnClient(c.config)
	c.Media = NewMediaClient(c.config)
	c.OauthConnection = NewOauthConnectionClient(c.config)
	c.Plan = NewPlanClient(c.config)
	c.Post = NewPostClient(c.config)
	c.PostCategory = NewPostCategoryClient(c.config)
	c.PostStatus = NewPostStatusClient(c.config)
	c.PostTag = NewPostTagClient(c.config)
	c.PostType = NewPostTypeClient(c.config)
	c.PostTypeForm = NewPostTypeFormClient(c.config)
	c.Session = NewSessionClient(c.config)
	c.Temp = NewTempClient(c.config)
	c.Templ = NewTemplClient(c.config)
	c.Todo = NewTodoClient(c.config)
	c.User = NewUserClient(c.config)
	c.Workspace = NewWorkspaceClient(c.config)
	c.WorkspaceInvite = NewWorkspaceInviteClient(c.config)
	c.WorkspaceUser = NewWorkspaceUserClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AdminUser:       NewAdminUserClient(cfg),
		App:             NewAppClient(cfg),
		Kache:           NewKacheClient(cfg),
		Keyvalue:        NewKeyvalueClient(cfg),
		MailConn:        NewMailConnClient(cfg),
		Media:           NewMediaClient(cfg),
		OauthConnection: NewOauthConnectionClient(cfg),
		Plan:            NewPlanClient(cfg),
		Post:            NewPostClient(cfg),
		PostCategory:    NewPostCategoryClient(cfg),
		PostStatus:      NewPostStatusClient(cfg),
		PostTag:         NewPostTagClient(cfg),
		PostType:        NewPostTypeClient(cfg),
		PostTypeForm:    NewPostTypeFormClient(cfg),
		Session:         NewSessionClient(cfg),
		Temp:            NewTempClient(cfg),
		Templ:           NewTemplClient(cfg),
		Todo:            NewTodoClient(cfg),
		User:            NewUserClient(cfg),
		Workspace:       NewWorkspaceClient(cfg),
		WorkspaceInvite: NewWorkspaceInviteClient(cfg),
		WorkspaceUser:   NewWorkspaceUserClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:             ctx,
		config:          cfg,
		AdminUser:       NewAdminUserClient(cfg),
		App:             NewAppClient(cfg),
		Kache:           NewKacheClient(cfg),
		Keyvalue:        NewKeyvalueClient(cfg),
		MailConn:        NewMailConnClient(cfg),
		Media:           NewMediaClient(cfg),
		OauthConnection: NewOauthConnectionClient(cfg),
		Plan:            NewPlanClient(cfg),
		Post:            NewPostClient(cfg),
		PostCategory:    NewPostCategoryClient(cfg),
		PostStatus:      NewPostStatusClient(cfg),
		PostTag:         NewPostTagClient(cfg),
		PostType:        NewPostTypeClient(cfg),
		PostTypeForm:    NewPostTypeFormClient(cfg),
		Session:         NewSessionClient(cfg),
		Temp:            NewTempClient(cfg),
		Templ:           NewTemplClient(cfg),
		Todo:            NewTodoClient(cfg),
		User:            NewUserClient(cfg),
		Workspace:       NewWorkspaceClient(cfg),
		WorkspaceInvite: NewWorkspaceInviteClient(cfg),
		WorkspaceUser:   NewWorkspaceUserClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		AdminUser.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.AdminUser, c.App, c.Kache, c.Keyvalue, c.MailConn, c.Media, c.OauthConnection,
		c.Plan, c.Post, c.PostCategory, c.PostStatus, c.PostTag, c.PostType,
		c.PostTypeForm, c.Session, c.Temp, c.Templ, c.Todo, c.User, c.Workspace,
		c.WorkspaceInvite, c.WorkspaceUser,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.AdminUser, c.App, c.Kache, c.Keyvalue, c.MailConn, c.Media, c.OauthConnection,
		c.Plan, c.Post, c.PostCategory, c.PostStatus, c.PostTag, c.PostType,
		c.PostTypeForm, c.Session, c.Temp, c.Templ, c.Todo, c.User, c.Workspace,
		c.WorkspaceInvite, c.WorkspaceUser,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *AdminUserMutation:
		return c.AdminUser.mutate(ctx, m)
	case *AppMutation:
		return c.App.mutate(ctx, m)
	case *KacheMutation:
		return c.Kache.mutate(ctx, m)
	case *KeyvalueMutation:
		return c.Keyvalue.mutate(ctx, m)
	case *MailConnMutation:
		return c.MailConn.mutate(ctx, m)
	case *MediaMutation:
		return c.Media.mutate(ctx, m)
	case *OauthConnectionMutation:
		return c.OauthConnection.mutate(ctx, m)
	case *PlanMutation:
		return c.Plan.mutate(ctx, m)
	case *PostMutation:
		return c.Post.mutate(ctx, m)
	case *PostCategoryMutation:
		return c.PostCategory.mutate(ctx, m)
	case *PostStatusMutation:
		return c.PostStatus.mutate(ctx, m)
	case *PostTagMutation:
		return c.PostTag.mutate(ctx, m)
	case *PostTypeMutation:
		return c.PostType.mutate(ctx, m)
	case *PostTypeFormMutation:
		return c.PostTypeForm.mutate(ctx, m)
	case *SessionMutation:
		return c.Session.mutate(ctx, m)
	case *TempMutation:
		return c.Temp.mutate(ctx, m)
	case *TemplMutation:
		return c.Templ.mutate(ctx, m)
	case *TodoMutation:
		return c.Todo.mutate(ctx, m)
	case *UserMutation:
		return c.User.mutate(ctx, m)
	case *WorkspaceMutation:
		return c.Workspace.mutate(ctx, m)
	case *WorkspaceInviteMutation:
		return c.WorkspaceInvite.mutate(ctx, m)
	case *WorkspaceUserMutation:
		return c.WorkspaceUser.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// AdminUserClient is a client for the AdminUser schema.
type AdminUserClient struct {
	config
}

// NewAdminUserClient returns a client for the AdminUser from the given config.
func NewAdminUserClient(c config) *AdminUserClient {
	return &AdminUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `adminuser.Hooks(f(g(h())))`.
func (c *AdminUserClient) Use(hooks ...Hook) {
	c.hooks.AdminUser = append(c.hooks.AdminUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `adminuser.Intercept(f(g(h())))`.
func (c *AdminUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.AdminUser = append(c.inters.AdminUser, interceptors...)
}

// Create returns a builder for creating a AdminUser entity.
func (c *AdminUserClient) Create() *AdminUserCreate {
	mutation := newAdminUserMutation(c.config, OpCreate)
	return &AdminUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of AdminUser entities.
func (c *AdminUserClient) CreateBulk(builders ...*AdminUserCreate) *AdminUserCreateBulk {
	return &AdminUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AdminUserClient) MapCreateBulk(slice any, setFunc func(*AdminUserCreate, int)) *AdminUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AdminUserCreateBulk{err: fmt.Errorf("calling to AdminUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AdminUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AdminUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for AdminUser.
func (c *AdminUserClient) Update() *AdminUserUpdate {
	mutation := newAdminUserMutation(c.config, OpUpdate)
	return &AdminUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AdminUserClient) UpdateOne(au *AdminUser) *AdminUserUpdateOne {
	mutation := newAdminUserMutation(c.config, OpUpdateOne, withAdminUser(au))
	return &AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AdminUserClient) UpdateOneID(id string) *AdminUserUpdateOne {
	mutation := newAdminUserMutation(c.config, OpUpdateOne, withAdminUserID(id))
	return &AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for AdminUser.
func (c *AdminUserClient) Delete() *AdminUserDelete {
	mutation := newAdminUserMutation(c.config, OpDelete)
	return &AdminUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AdminUserClient) DeleteOne(au *AdminUser) *AdminUserDeleteOne {
	return c.DeleteOneID(au.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AdminUserClient) DeleteOneID(id string) *AdminUserDeleteOne {
	builder := c.Delete().Where(adminuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AdminUserDeleteOne{builder}
}

// Query returns a query builder for AdminUser.
func (c *AdminUserClient) Query() *AdminUserQuery {
	return &AdminUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeAdminUser},
		inters: c.Interceptors(),
	}
}

// Get returns a AdminUser entity by its id.
func (c *AdminUserClient) Get(ctx context.Context, id string) (*AdminUser, error) {
	return c.Query().Where(adminuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AdminUserClient) GetX(ctx context.Context, id string) *AdminUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *AdminUserClient) Hooks() []Hook {
	return c.hooks.AdminUser
}

// Interceptors returns the client interceptors.
func (c *AdminUserClient) Interceptors() []Interceptor {
	return c.inters.AdminUser
}

func (c *AdminUserClient) mutate(ctx context.Context, m *AdminUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AdminUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AdminUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AdminUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AdminUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown AdminUser mutation op: %q", m.Op())
	}
}

// AppClient is a client for the App schema.
type AppClient struct {
	config
}

// NewAppClient returns a client for the App from the given config.
func NewAppClient(c config) *AppClient {
	return &AppClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `app.Hooks(f(g(h())))`.
func (c *AppClient) Use(hooks ...Hook) {
	c.hooks.App = append(c.hooks.App, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `app.Intercept(f(g(h())))`.
func (c *AppClient) Intercept(interceptors ...Interceptor) {
	c.inters.App = append(c.inters.App, interceptors...)
}

// Create returns a builder for creating a App entity.
func (c *AppClient) Create() *AppCreate {
	mutation := newAppMutation(c.config, OpCreate)
	return &AppCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of App entities.
func (c *AppClient) CreateBulk(builders ...*AppCreate) *AppCreateBulk {
	return &AppCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *AppClient) MapCreateBulk(slice any, setFunc func(*AppCreate, int)) *AppCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &AppCreateBulk{err: fmt.Errorf("calling to AppClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*AppCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &AppCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for App.
func (c *AppClient) Update() *AppUpdate {
	mutation := newAppMutation(c.config, OpUpdate)
	return &AppUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *AppClient) UpdateOne(a *App) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withApp(a))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *AppClient) UpdateOneID(id string) *AppUpdateOne {
	mutation := newAppMutation(c.config, OpUpdateOne, withAppID(id))
	return &AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for App.
func (c *AppClient) Delete() *AppDelete {
	mutation := newAppMutation(c.config, OpDelete)
	return &AppDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *AppClient) DeleteOne(a *App) *AppDeleteOne {
	return c.DeleteOneID(a.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *AppClient) DeleteOneID(id string) *AppDeleteOne {
	builder := c.Delete().Where(app.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &AppDeleteOne{builder}
}

// Query returns a query builder for App.
func (c *AppClient) Query() *AppQuery {
	return &AppQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeApp},
		inters: c.Interceptors(),
	}
}

// Get returns a App entity by its id.
func (c *AppClient) Get(ctx context.Context, id string) (*App, error) {
	return c.Query().Where(app.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *AppClient) GetX(ctx context.Context, id string) *App {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryDefaultMailConn queries the default_mail_conn edge of a App.
func (c *AppClient) QueryDefaultMailConn(a *App) *MailConnQuery {
	query := (&MailConnClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(mailconn.Table, mailconn.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, app.DefaultMailConnTable, app.DefaultMailConnColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryMailLayoutTempl queries the mail_layout_templ edge of a App.
func (c *AppClient) QueryMailLayoutTempl(a *App) *TemplQuery {
	query := (&TemplClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(templ.Table, templ.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, app.MailLayoutTemplTable, app.MailLayoutTemplColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWsapceInviteTempl queries the wsapce_invite_templ edge of a App.
func (c *AppClient) QueryWsapceInviteTempl(a *App) *TemplQuery {
	query := (&TemplClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(templ.Table, templ.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, app.WsapceInviteTemplTable, app.WsapceInviteTemplColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWsapceSuccessTempl queries the wsapce_success_templ edge of a App.
func (c *AppClient) QueryWsapceSuccessTempl(a *App) *TemplQuery {
	query := (&TemplClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(templ.Table, templ.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, app.WsapceSuccessTemplTable, app.WsapceSuccessTemplColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthFpTempl queries the auth_fp_templ edge of a App.
func (c *AppClient) QueryAuthFpTempl(a *App) *TemplQuery {
	query := (&TemplClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(templ.Table, templ.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, app.AuthFpTemplTable, app.AuthFpTemplColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthWelcomeEmailTempl queries the auth_welcome_email_templ edge of a App.
func (c *AppClient) QueryAuthWelcomeEmailTempl(a *App) *TemplQuery {
	query := (&TemplClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(templ.Table, templ.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, app.AuthWelcomeEmailTemplTable, app.AuthWelcomeEmailTemplColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryAuthVerificationTempl queries the auth_verification_templ edge of a App.
func (c *AppClient) QueryAuthVerificationTempl(a *App) *TemplQuery {
	query := (&TemplClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := a.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(app.Table, app.FieldID, id),
			sqlgraph.To(templ.Table, templ.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, app.AuthVerificationTemplTable, app.AuthVerificationTemplColumn),
		)
		fromV = sqlgraph.Neighbors(a.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *AppClient) Hooks() []Hook {
	return c.hooks.App
}

// Interceptors returns the client interceptors.
func (c *AppClient) Interceptors() []Interceptor {
	return c.inters.App
}

func (c *AppClient) mutate(ctx context.Context, m *AppMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&AppCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&AppUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&AppUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&AppDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown App mutation op: %q", m.Op())
	}
}

// KacheClient is a client for the Kache schema.
type KacheClient struct {
	config
}

// NewKacheClient returns a client for the Kache from the given config.
func NewKacheClient(c config) *KacheClient {
	return &KacheClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `kache.Hooks(f(g(h())))`.
func (c *KacheClient) Use(hooks ...Hook) {
	c.hooks.Kache = append(c.hooks.Kache, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `kache.Intercept(f(g(h())))`.
func (c *KacheClient) Intercept(interceptors ...Interceptor) {
	c.inters.Kache = append(c.inters.Kache, interceptors...)
}

// Create returns a builder for creating a Kache entity.
func (c *KacheClient) Create() *KacheCreate {
	mutation := newKacheMutation(c.config, OpCreate)
	return &KacheCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Kache entities.
func (c *KacheClient) CreateBulk(builders ...*KacheCreate) *KacheCreateBulk {
	return &KacheCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KacheClient) MapCreateBulk(slice any, setFunc func(*KacheCreate, int)) *KacheCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KacheCreateBulk{err: fmt.Errorf("calling to KacheClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KacheCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KacheCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Kache.
func (c *KacheClient) Update() *KacheUpdate {
	mutation := newKacheMutation(c.config, OpUpdate)
	return &KacheUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KacheClient) UpdateOne(k *Kache) *KacheUpdateOne {
	mutation := newKacheMutation(c.config, OpUpdateOne, withKache(k))
	return &KacheUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KacheClient) UpdateOneID(id string) *KacheUpdateOne {
	mutation := newKacheMutation(c.config, OpUpdateOne, withKacheID(id))
	return &KacheUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Kache.
func (c *KacheClient) Delete() *KacheDelete {
	mutation := newKacheMutation(c.config, OpDelete)
	return &KacheDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KacheClient) DeleteOne(k *Kache) *KacheDeleteOne {
	return c.DeleteOneID(k.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KacheClient) DeleteOneID(id string) *KacheDeleteOne {
	builder := c.Delete().Where(kache.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KacheDeleteOne{builder}
}

// Query returns a query builder for Kache.
func (c *KacheClient) Query() *KacheQuery {
	return &KacheQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKache},
		inters: c.Interceptors(),
	}
}

// Get returns a Kache entity by its id.
func (c *KacheClient) Get(ctx context.Context, id string) (*Kache, error) {
	return c.Query().Where(kache.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KacheClient) GetX(ctx context.Context, id string) *Kache {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *KacheClient) Hooks() []Hook {
	return c.hooks.Kache
}

// Interceptors returns the client interceptors.
func (c *KacheClient) Interceptors() []Interceptor {
	return c.inters.Kache
}

func (c *KacheClient) mutate(ctx context.Context, m *KacheMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KacheCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KacheUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KacheUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KacheDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Kache mutation op: %q", m.Op())
	}
}

// KeyvalueClient is a client for the Keyvalue schema.
type KeyvalueClient struct {
	config
}

// NewKeyvalueClient returns a client for the Keyvalue from the given config.
func NewKeyvalueClient(c config) *KeyvalueClient {
	return &KeyvalueClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `keyvalue.Hooks(f(g(h())))`.
func (c *KeyvalueClient) Use(hooks ...Hook) {
	c.hooks.Keyvalue = append(c.hooks.Keyvalue, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `keyvalue.Intercept(f(g(h())))`.
func (c *KeyvalueClient) Intercept(interceptors ...Interceptor) {
	c.inters.Keyvalue = append(c.inters.Keyvalue, interceptors...)
}

// Create returns a builder for creating a Keyvalue entity.
func (c *KeyvalueClient) Create() *KeyvalueCreate {
	mutation := newKeyvalueMutation(c.config, OpCreate)
	return &KeyvalueCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Keyvalue entities.
func (c *KeyvalueClient) CreateBulk(builders ...*KeyvalueCreate) *KeyvalueCreateBulk {
	return &KeyvalueCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *KeyvalueClient) MapCreateBulk(slice any, setFunc func(*KeyvalueCreate, int)) *KeyvalueCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &KeyvalueCreateBulk{err: fmt.Errorf("calling to KeyvalueClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*KeyvalueCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &KeyvalueCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Keyvalue.
func (c *KeyvalueClient) Update() *KeyvalueUpdate {
	mutation := newKeyvalueMutation(c.config, OpUpdate)
	return &KeyvalueUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *KeyvalueClient) UpdateOne(k *Keyvalue) *KeyvalueUpdateOne {
	mutation := newKeyvalueMutation(c.config, OpUpdateOne, withKeyvalue(k))
	return &KeyvalueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *KeyvalueClient) UpdateOneID(id string) *KeyvalueUpdateOne {
	mutation := newKeyvalueMutation(c.config, OpUpdateOne, withKeyvalueID(id))
	return &KeyvalueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Keyvalue.
func (c *KeyvalueClient) Delete() *KeyvalueDelete {
	mutation := newKeyvalueMutation(c.config, OpDelete)
	return &KeyvalueDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *KeyvalueClient) DeleteOne(k *Keyvalue) *KeyvalueDeleteOne {
	return c.DeleteOneID(k.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *KeyvalueClient) DeleteOneID(id string) *KeyvalueDeleteOne {
	builder := c.Delete().Where(keyvalue.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &KeyvalueDeleteOne{builder}
}

// Query returns a query builder for Keyvalue.
func (c *KeyvalueClient) Query() *KeyvalueQuery {
	return &KeyvalueQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeKeyvalue},
		inters: c.Interceptors(),
	}
}

// Get returns a Keyvalue entity by its id.
func (c *KeyvalueClient) Get(ctx context.Context, id string) (*Keyvalue, error) {
	return c.Query().Where(keyvalue.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *KeyvalueClient) GetX(ctx context.Context, id string) *Keyvalue {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *KeyvalueClient) Hooks() []Hook {
	return c.hooks.Keyvalue
}

// Interceptors returns the client interceptors.
func (c *KeyvalueClient) Interceptors() []Interceptor {
	return c.inters.Keyvalue
}

func (c *KeyvalueClient) mutate(ctx context.Context, m *KeyvalueMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&KeyvalueCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&KeyvalueUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&KeyvalueUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&KeyvalueDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Keyvalue mutation op: %q", m.Op())
	}
}

// MailConnClient is a client for the MailConn schema.
type MailConnClient struct {
	config
}

// NewMailConnClient returns a client for the MailConn from the given config.
func NewMailConnClient(c config) *MailConnClient {
	return &MailConnClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `mailconn.Hooks(f(g(h())))`.
func (c *MailConnClient) Use(hooks ...Hook) {
	c.hooks.MailConn = append(c.hooks.MailConn, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `mailconn.Intercept(f(g(h())))`.
func (c *MailConnClient) Intercept(interceptors ...Interceptor) {
	c.inters.MailConn = append(c.inters.MailConn, interceptors...)
}

// Create returns a builder for creating a MailConn entity.
func (c *MailConnClient) Create() *MailConnCreate {
	mutation := newMailConnMutation(c.config, OpCreate)
	return &MailConnCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of MailConn entities.
func (c *MailConnClient) CreateBulk(builders ...*MailConnCreate) *MailConnCreateBulk {
	return &MailConnCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MailConnClient) MapCreateBulk(slice any, setFunc func(*MailConnCreate, int)) *MailConnCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MailConnCreateBulk{err: fmt.Errorf("calling to MailConnClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MailConnCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MailConnCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for MailConn.
func (c *MailConnClient) Update() *MailConnUpdate {
	mutation := newMailConnMutation(c.config, OpUpdate)
	return &MailConnUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MailConnClient) UpdateOne(mc *MailConn) *MailConnUpdateOne {
	mutation := newMailConnMutation(c.config, OpUpdateOne, withMailConn(mc))
	return &MailConnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MailConnClient) UpdateOneID(id string) *MailConnUpdateOne {
	mutation := newMailConnMutation(c.config, OpUpdateOne, withMailConnID(id))
	return &MailConnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for MailConn.
func (c *MailConnClient) Delete() *MailConnDelete {
	mutation := newMailConnMutation(c.config, OpDelete)
	return &MailConnDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MailConnClient) DeleteOne(mc *MailConn) *MailConnDeleteOne {
	return c.DeleteOneID(mc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MailConnClient) DeleteOneID(id string) *MailConnDeleteOne {
	builder := c.Delete().Where(mailconn.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MailConnDeleteOne{builder}
}

// Query returns a query builder for MailConn.
func (c *MailConnClient) Query() *MailConnQuery {
	return &MailConnQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMailConn},
		inters: c.Interceptors(),
	}
}

// Get returns a MailConn entity by its id.
func (c *MailConnClient) Get(ctx context.Context, id string) (*MailConn, error) {
	return c.Query().Where(mailconn.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MailConnClient) GetX(ctx context.Context, id string) *MailConn {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MailConnClient) Hooks() []Hook {
	return c.hooks.MailConn
}

// Interceptors returns the client interceptors.
func (c *MailConnClient) Interceptors() []Interceptor {
	return c.inters.MailConn
}

func (c *MailConnClient) mutate(ctx context.Context, m *MailConnMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MailConnCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MailConnUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MailConnUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MailConnDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown MailConn mutation op: %q", m.Op())
	}
}

// MediaClient is a client for the Media schema.
type MediaClient struct {
	config
}

// NewMediaClient returns a client for the Media from the given config.
func NewMediaClient(c config) *MediaClient {
	return &MediaClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `media.Hooks(f(g(h())))`.
func (c *MediaClient) Use(hooks ...Hook) {
	c.hooks.Media = append(c.hooks.Media, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `media.Intercept(f(g(h())))`.
func (c *MediaClient) Intercept(interceptors ...Interceptor) {
	c.inters.Media = append(c.inters.Media, interceptors...)
}

// Create returns a builder for creating a Media entity.
func (c *MediaClient) Create() *MediaCreate {
	mutation := newMediaMutation(c.config, OpCreate)
	return &MediaCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Media entities.
func (c *MediaClient) CreateBulk(builders ...*MediaCreate) *MediaCreateBulk {
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *MediaClient) MapCreateBulk(slice any, setFunc func(*MediaCreate, int)) *MediaCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &MediaCreateBulk{err: fmt.Errorf("calling to MediaClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*MediaCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &MediaCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Media.
func (c *MediaClient) Update() *MediaUpdate {
	mutation := newMediaMutation(c.config, OpUpdate)
	return &MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *MediaClient) UpdateOne(m *Media) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMedia(m))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *MediaClient) UpdateOneID(id string) *MediaUpdateOne {
	mutation := newMediaMutation(c.config, OpUpdateOne, withMediaID(id))
	return &MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Media.
func (c *MediaClient) Delete() *MediaDelete {
	mutation := newMediaMutation(c.config, OpDelete)
	return &MediaDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *MediaClient) DeleteOne(m *Media) *MediaDeleteOne {
	return c.DeleteOneID(m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *MediaClient) DeleteOneID(id string) *MediaDeleteOne {
	builder := c.Delete().Where(media.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &MediaDeleteOne{builder}
}

// Query returns a query builder for Media.
func (c *MediaClient) Query() *MediaQuery {
	return &MediaQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeMedia},
		inters: c.Interceptors(),
	}
}

// Get returns a Media entity by its id.
func (c *MediaClient) Get(ctx context.Context, id string) (*Media, error) {
	return c.Query().Where(media.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *MediaClient) GetX(ctx context.Context, id string) *Media {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *MediaClient) Hooks() []Hook {
	return c.hooks.Media
}

// Interceptors returns the client interceptors.
func (c *MediaClient) Interceptors() []Interceptor {
	return c.inters.Media
}

func (c *MediaClient) mutate(ctx context.Context, m *MediaMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&MediaCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&MediaUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&MediaUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&MediaDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Media mutation op: %q", m.Op())
	}
}

// OauthConnectionClient is a client for the OauthConnection schema.
type OauthConnectionClient struct {
	config
}

// NewOauthConnectionClient returns a client for the OauthConnection from the given config.
func NewOauthConnectionClient(c config) *OauthConnectionClient {
	return &OauthConnectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `oauthconnection.Hooks(f(g(h())))`.
func (c *OauthConnectionClient) Use(hooks ...Hook) {
	c.hooks.OauthConnection = append(c.hooks.OauthConnection, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `oauthconnection.Intercept(f(g(h())))`.
func (c *OauthConnectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.OauthConnection = append(c.inters.OauthConnection, interceptors...)
}

// Create returns a builder for creating a OauthConnection entity.
func (c *OauthConnectionClient) Create() *OauthConnectionCreate {
	mutation := newOauthConnectionMutation(c.config, OpCreate)
	return &OauthConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of OauthConnection entities.
func (c *OauthConnectionClient) CreateBulk(builders ...*OauthConnectionCreate) *OauthConnectionCreateBulk {
	return &OauthConnectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *OauthConnectionClient) MapCreateBulk(slice any, setFunc func(*OauthConnectionCreate, int)) *OauthConnectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &OauthConnectionCreateBulk{err: fmt.Errorf("calling to OauthConnectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*OauthConnectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &OauthConnectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for OauthConnection.
func (c *OauthConnectionClient) Update() *OauthConnectionUpdate {
	mutation := newOauthConnectionMutation(c.config, OpUpdate)
	return &OauthConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *OauthConnectionClient) UpdateOne(oc *OauthConnection) *OauthConnectionUpdateOne {
	mutation := newOauthConnectionMutation(c.config, OpUpdateOne, withOauthConnection(oc))
	return &OauthConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *OauthConnectionClient) UpdateOneID(id string) *OauthConnectionUpdateOne {
	mutation := newOauthConnectionMutation(c.config, OpUpdateOne, withOauthConnectionID(id))
	return &OauthConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for OauthConnection.
func (c *OauthConnectionClient) Delete() *OauthConnectionDelete {
	mutation := newOauthConnectionMutation(c.config, OpDelete)
	return &OauthConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *OauthConnectionClient) DeleteOne(oc *OauthConnection) *OauthConnectionDeleteOne {
	return c.DeleteOneID(oc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *OauthConnectionClient) DeleteOneID(id string) *OauthConnectionDeleteOne {
	builder := c.Delete().Where(oauthconnection.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &OauthConnectionDeleteOne{builder}
}

// Query returns a query builder for OauthConnection.
func (c *OauthConnectionClient) Query() *OauthConnectionQuery {
	return &OauthConnectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeOauthConnection},
		inters: c.Interceptors(),
	}
}

// Get returns a OauthConnection entity by its id.
func (c *OauthConnectionClient) Get(ctx context.Context, id string) (*OauthConnection, error) {
	return c.Query().Where(oauthconnection.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *OauthConnectionClient) GetX(ctx context.Context, id string) *OauthConnection {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *OauthConnectionClient) Hooks() []Hook {
	return c.hooks.OauthConnection
}

// Interceptors returns the client interceptors.
func (c *OauthConnectionClient) Interceptors() []Interceptor {
	return c.inters.OauthConnection
}

func (c *OauthConnectionClient) mutate(ctx context.Context, m *OauthConnectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&OauthConnectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&OauthConnectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&OauthConnectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&OauthConnectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown OauthConnection mutation op: %q", m.Op())
	}
}

// PlanClient is a client for the Plan schema.
type PlanClient struct {
	config
}

// NewPlanClient returns a client for the Plan from the given config.
func NewPlanClient(c config) *PlanClient {
	return &PlanClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `plan.Hooks(f(g(h())))`.
func (c *PlanClient) Use(hooks ...Hook) {
	c.hooks.Plan = append(c.hooks.Plan, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `plan.Intercept(f(g(h())))`.
func (c *PlanClient) Intercept(interceptors ...Interceptor) {
	c.inters.Plan = append(c.inters.Plan, interceptors...)
}

// Create returns a builder for creating a Plan entity.
func (c *PlanClient) Create() *PlanCreate {
	mutation := newPlanMutation(c.config, OpCreate)
	return &PlanCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Plan entities.
func (c *PlanClient) CreateBulk(builders ...*PlanCreate) *PlanCreateBulk {
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PlanClient) MapCreateBulk(slice any, setFunc func(*PlanCreate, int)) *PlanCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PlanCreateBulk{err: fmt.Errorf("calling to PlanClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PlanCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PlanCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Plan.
func (c *PlanClient) Update() *PlanUpdate {
	mutation := newPlanMutation(c.config, OpUpdate)
	return &PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PlanClient) UpdateOne(pl *Plan) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlan(pl))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PlanClient) UpdateOneID(id string) *PlanUpdateOne {
	mutation := newPlanMutation(c.config, OpUpdateOne, withPlanID(id))
	return &PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Plan.
func (c *PlanClient) Delete() *PlanDelete {
	mutation := newPlanMutation(c.config, OpDelete)
	return &PlanDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PlanClient) DeleteOne(pl *Plan) *PlanDeleteOne {
	return c.DeleteOneID(pl.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PlanClient) DeleteOneID(id string) *PlanDeleteOne {
	builder := c.Delete().Where(plan.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PlanDeleteOne{builder}
}

// Query returns a query builder for Plan.
func (c *PlanClient) Query() *PlanQuery {
	return &PlanQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePlan},
		inters: c.Interceptors(),
	}
}

// Get returns a Plan entity by its id.
func (c *PlanClient) Get(ctx context.Context, id string) (*Plan, error) {
	return c.Query().Where(plan.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PlanClient) GetX(ctx context.Context, id string) *Plan {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *PlanClient) Hooks() []Hook {
	return c.hooks.Plan
}

// Interceptors returns the client interceptors.
func (c *PlanClient) Interceptors() []Interceptor {
	return c.inters.Plan
}

func (c *PlanClient) mutate(ctx context.Context, m *PlanMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PlanCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PlanUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PlanUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PlanDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Plan mutation op: %q", m.Op())
	}
}

// PostClient is a client for the Post schema.
type PostClient struct {
	config
}

// NewPostClient returns a client for the Post from the given config.
func NewPostClient(c config) *PostClient {
	return &PostClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `post.Hooks(f(g(h())))`.
func (c *PostClient) Use(hooks ...Hook) {
	c.hooks.Post = append(c.hooks.Post, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `post.Intercept(f(g(h())))`.
func (c *PostClient) Intercept(interceptors ...Interceptor) {
	c.inters.Post = append(c.inters.Post, interceptors...)
}

// Create returns a builder for creating a Post entity.
func (c *PostClient) Create() *PostCreate {
	mutation := newPostMutation(c.config, OpCreate)
	return &PostCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Post entities.
func (c *PostClient) CreateBulk(builders ...*PostCreate) *PostCreateBulk {
	return &PostCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostClient) MapCreateBulk(slice any, setFunc func(*PostCreate, int)) *PostCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostCreateBulk{err: fmt.Errorf("calling to PostClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Post.
func (c *PostClient) Update() *PostUpdate {
	mutation := newPostMutation(c.config, OpUpdate)
	return &PostUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostClient) UpdateOne(po *Post) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPost(po))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostClient) UpdateOneID(id string) *PostUpdateOne {
	mutation := newPostMutation(c.config, OpUpdateOne, withPostID(id))
	return &PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Post.
func (c *PostClient) Delete() *PostDelete {
	mutation := newPostMutation(c.config, OpDelete)
	return &PostDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostClient) DeleteOne(po *Post) *PostDeleteOne {
	return c.DeleteOneID(po.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostClient) DeleteOneID(id string) *PostDeleteOne {
	builder := c.Delete().Where(post.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostDeleteOne{builder}
}

// Query returns a query builder for Post.
func (c *PostClient) Query() *PostQuery {
	return &PostQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePost},
		inters: c.Interceptors(),
	}
}

// Get returns a Post entity by its id.
func (c *PostClient) Get(ctx context.Context, id string) (*Post, error) {
	return c.Query().Where(post.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostClient) GetX(ctx context.Context, id string) *Post {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPostStatus queries the post_status edge of a Post.
func (c *PostClient) QueryPostStatus(po *Post) *PostStatusQuery {
	query := (&PostStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(poststatus.Table, poststatus.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.PostStatusTable, post.PostStatusColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostType queries the post_type edge of a Post.
func (c *PostClient) QueryPostType(po *Post) *PostTypeQuery {
	query := (&PostTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(posttype.Table, posttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.PostTypeTable, post.PostTypeColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPrimaryCategory queries the primary_category edge of a Post.
func (c *PostClient) QueryPrimaryCategory(po *Post) *PostCategoryQuery {
	query := (&PostCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(postcategory.Table, postcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, post.PrimaryCategoryTable, post.PrimaryCategoryColumn),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostTags queries the post_tags edge of a Post.
func (c *PostClient) QueryPostTags(po *Post) *PostTagQuery {
	query := (&PostTagClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := po.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(post.Table, post.FieldID, id),
			sqlgraph.To(posttag.Table, posttag.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, post.PostTagsTable, post.PostTagsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(po.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostClient) Hooks() []Hook {
	hooks := c.hooks.Post
	return append(hooks[:len(hooks):len(hooks)], post.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PostClient) Interceptors() []Interceptor {
	return c.inters.Post
}

func (c *PostClient) mutate(ctx context.Context, m *PostMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Post mutation op: %q", m.Op())
	}
}

// PostCategoryClient is a client for the PostCategory schema.
type PostCategoryClient struct {
	config
}

// NewPostCategoryClient returns a client for the PostCategory from the given config.
func NewPostCategoryClient(c config) *PostCategoryClient {
	return &PostCategoryClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `postcategory.Hooks(f(g(h())))`.
func (c *PostCategoryClient) Use(hooks ...Hook) {
	c.hooks.PostCategory = append(c.hooks.PostCategory, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `postcategory.Intercept(f(g(h())))`.
func (c *PostCategoryClient) Intercept(interceptors ...Interceptor) {
	c.inters.PostCategory = append(c.inters.PostCategory, interceptors...)
}

// Create returns a builder for creating a PostCategory entity.
func (c *PostCategoryClient) Create() *PostCategoryCreate {
	mutation := newPostCategoryMutation(c.config, OpCreate)
	return &PostCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PostCategory entities.
func (c *PostCategoryClient) CreateBulk(builders ...*PostCategoryCreate) *PostCategoryCreateBulk {
	return &PostCategoryCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostCategoryClient) MapCreateBulk(slice any, setFunc func(*PostCategoryCreate, int)) *PostCategoryCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostCategoryCreateBulk{err: fmt.Errorf("calling to PostCategoryClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostCategoryCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostCategoryCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PostCategory.
func (c *PostCategoryClient) Update() *PostCategoryUpdate {
	mutation := newPostCategoryMutation(c.config, OpUpdate)
	return &PostCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostCategoryClient) UpdateOne(pc *PostCategory) *PostCategoryUpdateOne {
	mutation := newPostCategoryMutation(c.config, OpUpdateOne, withPostCategory(pc))
	return &PostCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostCategoryClient) UpdateOneID(id string) *PostCategoryUpdateOne {
	mutation := newPostCategoryMutation(c.config, OpUpdateOne, withPostCategoryID(id))
	return &PostCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PostCategory.
func (c *PostCategoryClient) Delete() *PostCategoryDelete {
	mutation := newPostCategoryMutation(c.config, OpDelete)
	return &PostCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostCategoryClient) DeleteOne(pc *PostCategory) *PostCategoryDeleteOne {
	return c.DeleteOneID(pc.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostCategoryClient) DeleteOneID(id string) *PostCategoryDeleteOne {
	builder := c.Delete().Where(postcategory.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostCategoryDeleteOne{builder}
}

// Query returns a query builder for PostCategory.
func (c *PostCategoryClient) Query() *PostCategoryQuery {
	return &PostCategoryQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePostCategory},
		inters: c.Interceptors(),
	}
}

// Get returns a PostCategory entity by its id.
func (c *PostCategoryClient) Get(ctx context.Context, id string) (*PostCategory, error) {
	return c.Query().Where(postcategory.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostCategoryClient) GetX(ctx context.Context, id string) *PostCategory {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosts queries the posts edge of a PostCategory.
func (c *PostCategoryClient) QueryPosts(pc *PostCategory) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(postcategory.Table, postcategory.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, postcategory.PostsTable, postcategory.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(pc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a PostCategory.
func (c *PostCategoryClient) QueryParent(pc *PostCategory) *PostCategoryQuery {
	query := (&PostCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(postcategory.Table, postcategory.FieldID, id),
			sqlgraph.To(postcategory.Table, postcategory.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, postcategory.ParentTable, postcategory.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(pc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a PostCategory.
func (c *PostCategoryClient) QueryChildren(pc *PostCategory) *PostCategoryQuery {
	query := (&PostCategoryClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pc.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(postcategory.Table, postcategory.FieldID, id),
			sqlgraph.To(postcategory.Table, postcategory.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, postcategory.ChildrenTable, postcategory.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(pc.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostCategoryClient) Hooks() []Hook {
	hooks := c.hooks.PostCategory
	return append(hooks[:len(hooks):len(hooks)], postcategory.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PostCategoryClient) Interceptors() []Interceptor {
	return c.inters.PostCategory
}

func (c *PostCategoryClient) mutate(ctx context.Context, m *PostCategoryMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostCategoryCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostCategoryUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostCategoryUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostCategoryDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PostCategory mutation op: %q", m.Op())
	}
}

// PostStatusClient is a client for the PostStatus schema.
type PostStatusClient struct {
	config
}

// NewPostStatusClient returns a client for the PostStatus from the given config.
func NewPostStatusClient(c config) *PostStatusClient {
	return &PostStatusClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `poststatus.Hooks(f(g(h())))`.
func (c *PostStatusClient) Use(hooks ...Hook) {
	c.hooks.PostStatus = append(c.hooks.PostStatus, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `poststatus.Intercept(f(g(h())))`.
func (c *PostStatusClient) Intercept(interceptors ...Interceptor) {
	c.inters.PostStatus = append(c.inters.PostStatus, interceptors...)
}

// Create returns a builder for creating a PostStatus entity.
func (c *PostStatusClient) Create() *PostStatusCreate {
	mutation := newPostStatusMutation(c.config, OpCreate)
	return &PostStatusCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PostStatus entities.
func (c *PostStatusClient) CreateBulk(builders ...*PostStatusCreate) *PostStatusCreateBulk {
	return &PostStatusCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostStatusClient) MapCreateBulk(slice any, setFunc func(*PostStatusCreate, int)) *PostStatusCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostStatusCreateBulk{err: fmt.Errorf("calling to PostStatusClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostStatusCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostStatusCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PostStatus.
func (c *PostStatusClient) Update() *PostStatusUpdate {
	mutation := newPostStatusMutation(c.config, OpUpdate)
	return &PostStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostStatusClient) UpdateOne(ps *PostStatus) *PostStatusUpdateOne {
	mutation := newPostStatusMutation(c.config, OpUpdateOne, withPostStatus(ps))
	return &PostStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostStatusClient) UpdateOneID(id string) *PostStatusUpdateOne {
	mutation := newPostStatusMutation(c.config, OpUpdateOne, withPostStatusID(id))
	return &PostStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PostStatus.
func (c *PostStatusClient) Delete() *PostStatusDelete {
	mutation := newPostStatusMutation(c.config, OpDelete)
	return &PostStatusDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostStatusClient) DeleteOne(ps *PostStatus) *PostStatusDeleteOne {
	return c.DeleteOneID(ps.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostStatusClient) DeleteOneID(id string) *PostStatusDeleteOne {
	builder := c.Delete().Where(poststatus.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostStatusDeleteOne{builder}
}

// Query returns a query builder for PostStatus.
func (c *PostStatusClient) Query() *PostStatusQuery {
	return &PostStatusQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePostStatus},
		inters: c.Interceptors(),
	}
}

// Get returns a PostStatus entity by its id.
func (c *PostStatusClient) Get(ctx context.Context, id string) (*PostStatus, error) {
	return c.Query().Where(poststatus.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostStatusClient) GetX(ctx context.Context, id string) *PostStatus {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPostType queries the post_type edge of a PostStatus.
func (c *PostStatusClient) QueryPostType(ps *PostStatus) *PostTypeQuery {
	query := (&PostTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(poststatus.Table, poststatus.FieldID, id),
			sqlgraph.To(posttype.Table, posttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, poststatus.PostTypeTable, poststatus.PostTypeColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPosts queries the posts edge of a PostStatus.
func (c *PostStatusClient) QueryPosts(ps *PostStatus) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ps.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(poststatus.Table, poststatus.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, poststatus.PostsTable, poststatus.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(ps.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostStatusClient) Hooks() []Hook {
	hooks := c.hooks.PostStatus
	return append(hooks[:len(hooks):len(hooks)], poststatus.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PostStatusClient) Interceptors() []Interceptor {
	return c.inters.PostStatus
}

func (c *PostStatusClient) mutate(ctx context.Context, m *PostStatusMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostStatusCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostStatusUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostStatusUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostStatusDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PostStatus mutation op: %q", m.Op())
	}
}

// PostTagClient is a client for the PostTag schema.
type PostTagClient struct {
	config
}

// NewPostTagClient returns a client for the PostTag from the given config.
func NewPostTagClient(c config) *PostTagClient {
	return &PostTagClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `posttag.Hooks(f(g(h())))`.
func (c *PostTagClient) Use(hooks ...Hook) {
	c.hooks.PostTag = append(c.hooks.PostTag, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `posttag.Intercept(f(g(h())))`.
func (c *PostTagClient) Intercept(interceptors ...Interceptor) {
	c.inters.PostTag = append(c.inters.PostTag, interceptors...)
}

// Create returns a builder for creating a PostTag entity.
func (c *PostTagClient) Create() *PostTagCreate {
	mutation := newPostTagMutation(c.config, OpCreate)
	return &PostTagCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PostTag entities.
func (c *PostTagClient) CreateBulk(builders ...*PostTagCreate) *PostTagCreateBulk {
	return &PostTagCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostTagClient) MapCreateBulk(slice any, setFunc func(*PostTagCreate, int)) *PostTagCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostTagCreateBulk{err: fmt.Errorf("calling to PostTagClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostTagCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostTagCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PostTag.
func (c *PostTagClient) Update() *PostTagUpdate {
	mutation := newPostTagMutation(c.config, OpUpdate)
	return &PostTagUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostTagClient) UpdateOne(pt *PostTag) *PostTagUpdateOne {
	mutation := newPostTagMutation(c.config, OpUpdateOne, withPostTag(pt))
	return &PostTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostTagClient) UpdateOneID(id string) *PostTagUpdateOne {
	mutation := newPostTagMutation(c.config, OpUpdateOne, withPostTagID(id))
	return &PostTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PostTag.
func (c *PostTagClient) Delete() *PostTagDelete {
	mutation := newPostTagMutation(c.config, OpDelete)
	return &PostTagDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostTagClient) DeleteOne(pt *PostTag) *PostTagDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostTagClient) DeleteOneID(id string) *PostTagDeleteOne {
	builder := c.Delete().Where(posttag.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostTagDeleteOne{builder}
}

// Query returns a query builder for PostTag.
func (c *PostTagClient) Query() *PostTagQuery {
	return &PostTagQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePostTag},
		inters: c.Interceptors(),
	}
}

// Get returns a PostTag entity by its id.
func (c *PostTagClient) Get(ctx context.Context, id string) (*PostTag, error) {
	return c.Query().Where(posttag.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostTagClient) GetX(ctx context.Context, id string) *PostTag {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosts queries the posts edge of a PostTag.
func (c *PostTagClient) QueryPosts(pt *PostTag) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(posttag.Table, posttag.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, posttag.PostsTable, posttag.PostsPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostTagClient) Hooks() []Hook {
	hooks := c.hooks.PostTag
	return append(hooks[:len(hooks):len(hooks)], posttag.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PostTagClient) Interceptors() []Interceptor {
	return c.inters.PostTag
}

func (c *PostTagClient) mutate(ctx context.Context, m *PostTagMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostTagCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostTagUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostTagUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostTagDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PostTag mutation op: %q", m.Op())
	}
}

// PostTypeClient is a client for the PostType schema.
type PostTypeClient struct {
	config
}

// NewPostTypeClient returns a client for the PostType from the given config.
func NewPostTypeClient(c config) *PostTypeClient {
	return &PostTypeClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `posttype.Hooks(f(g(h())))`.
func (c *PostTypeClient) Use(hooks ...Hook) {
	c.hooks.PostType = append(c.hooks.PostType, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `posttype.Intercept(f(g(h())))`.
func (c *PostTypeClient) Intercept(interceptors ...Interceptor) {
	c.inters.PostType = append(c.inters.PostType, interceptors...)
}

// Create returns a builder for creating a PostType entity.
func (c *PostTypeClient) Create() *PostTypeCreate {
	mutation := newPostTypeMutation(c.config, OpCreate)
	return &PostTypeCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PostType entities.
func (c *PostTypeClient) CreateBulk(builders ...*PostTypeCreate) *PostTypeCreateBulk {
	return &PostTypeCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostTypeClient) MapCreateBulk(slice any, setFunc func(*PostTypeCreate, int)) *PostTypeCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostTypeCreateBulk{err: fmt.Errorf("calling to PostTypeClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostTypeCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostTypeCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PostType.
func (c *PostTypeClient) Update() *PostTypeUpdate {
	mutation := newPostTypeMutation(c.config, OpUpdate)
	return &PostTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostTypeClient) UpdateOne(pt *PostType) *PostTypeUpdateOne {
	mutation := newPostTypeMutation(c.config, OpUpdateOne, withPostType(pt))
	return &PostTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostTypeClient) UpdateOneID(id string) *PostTypeUpdateOne {
	mutation := newPostTypeMutation(c.config, OpUpdateOne, withPostTypeID(id))
	return &PostTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PostType.
func (c *PostTypeClient) Delete() *PostTypeDelete {
	mutation := newPostTypeMutation(c.config, OpDelete)
	return &PostTypeDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostTypeClient) DeleteOne(pt *PostType) *PostTypeDeleteOne {
	return c.DeleteOneID(pt.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostTypeClient) DeleteOneID(id string) *PostTypeDeleteOne {
	builder := c.Delete().Where(posttype.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostTypeDeleteOne{builder}
}

// Query returns a query builder for PostType.
func (c *PostTypeClient) Query() *PostTypeQuery {
	return &PostTypeQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePostType},
		inters: c.Interceptors(),
	}
}

// Get returns a PostType entity by its id.
func (c *PostTypeClient) Get(ctx context.Context, id string) (*PostType, error) {
	return c.Query().Where(posttype.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostTypeClient) GetX(ctx context.Context, id string) *PostType {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPosts queries the posts edge of a PostType.
func (c *PostTypeClient) QueryPosts(pt *PostType) *PostQuery {
	query := (&PostClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(posttype.Table, posttype.FieldID, id),
			sqlgraph.To(post.Table, post.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, posttype.PostsTable, posttype.PostsColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostStatuses queries the post_statuses edge of a PostType.
func (c *PostTypeClient) QueryPostStatuses(pt *PostType) *PostStatusQuery {
	query := (&PostStatusClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(posttype.Table, posttype.FieldID, id),
			sqlgraph.To(poststatus.Table, poststatus.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, posttype.PostStatusesTable, posttype.PostStatusesColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryPostTypeForms queries the post_type_forms edge of a PostType.
func (c *PostTypeClient) QueryPostTypeForms(pt *PostType) *PostTypeFormQuery {
	query := (&PostTypeFormClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := pt.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(posttype.Table, posttype.FieldID, id),
			sqlgraph.To(posttypeform.Table, posttypeform.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, posttype.PostTypeFormsTable, posttype.PostTypeFormsColumn),
		)
		fromV = sqlgraph.Neighbors(pt.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostTypeClient) Hooks() []Hook {
	hooks := c.hooks.PostType
	return append(hooks[:len(hooks):len(hooks)], posttype.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *PostTypeClient) Interceptors() []Interceptor {
	return c.inters.PostType
}

func (c *PostTypeClient) mutate(ctx context.Context, m *PostTypeMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostTypeCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostTypeUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostTypeUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostTypeDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PostType mutation op: %q", m.Op())
	}
}

// PostTypeFormClient is a client for the PostTypeForm schema.
type PostTypeFormClient struct {
	config
}

// NewPostTypeFormClient returns a client for the PostTypeForm from the given config.
func NewPostTypeFormClient(c config) *PostTypeFormClient {
	return &PostTypeFormClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `posttypeform.Hooks(f(g(h())))`.
func (c *PostTypeFormClient) Use(hooks ...Hook) {
	c.hooks.PostTypeForm = append(c.hooks.PostTypeForm, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `posttypeform.Intercept(f(g(h())))`.
func (c *PostTypeFormClient) Intercept(interceptors ...Interceptor) {
	c.inters.PostTypeForm = append(c.inters.PostTypeForm, interceptors...)
}

// Create returns a builder for creating a PostTypeForm entity.
func (c *PostTypeFormClient) Create() *PostTypeFormCreate {
	mutation := newPostTypeFormMutation(c.config, OpCreate)
	return &PostTypeFormCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of PostTypeForm entities.
func (c *PostTypeFormClient) CreateBulk(builders ...*PostTypeFormCreate) *PostTypeFormCreateBulk {
	return &PostTypeFormCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *PostTypeFormClient) MapCreateBulk(slice any, setFunc func(*PostTypeFormCreate, int)) *PostTypeFormCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &PostTypeFormCreateBulk{err: fmt.Errorf("calling to PostTypeFormClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*PostTypeFormCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &PostTypeFormCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for PostTypeForm.
func (c *PostTypeFormClient) Update() *PostTypeFormUpdate {
	mutation := newPostTypeFormMutation(c.config, OpUpdate)
	return &PostTypeFormUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *PostTypeFormClient) UpdateOne(ptf *PostTypeForm) *PostTypeFormUpdateOne {
	mutation := newPostTypeFormMutation(c.config, OpUpdateOne, withPostTypeForm(ptf))
	return &PostTypeFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *PostTypeFormClient) UpdateOneID(id string) *PostTypeFormUpdateOne {
	mutation := newPostTypeFormMutation(c.config, OpUpdateOne, withPostTypeFormID(id))
	return &PostTypeFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for PostTypeForm.
func (c *PostTypeFormClient) Delete() *PostTypeFormDelete {
	mutation := newPostTypeFormMutation(c.config, OpDelete)
	return &PostTypeFormDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *PostTypeFormClient) DeleteOne(ptf *PostTypeForm) *PostTypeFormDeleteOne {
	return c.DeleteOneID(ptf.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *PostTypeFormClient) DeleteOneID(id string) *PostTypeFormDeleteOne {
	builder := c.Delete().Where(posttypeform.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &PostTypeFormDeleteOne{builder}
}

// Query returns a query builder for PostTypeForm.
func (c *PostTypeFormClient) Query() *PostTypeFormQuery {
	return &PostTypeFormQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypePostTypeForm},
		inters: c.Interceptors(),
	}
}

// Get returns a PostTypeForm entity by its id.
func (c *PostTypeFormClient) Get(ctx context.Context, id string) (*PostTypeForm, error) {
	return c.Query().Where(posttypeform.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *PostTypeFormClient) GetX(ctx context.Context, id string) *PostTypeForm {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryPostType queries the post_type edge of a PostTypeForm.
func (c *PostTypeFormClient) QueryPostType(ptf *PostTypeForm) *PostTypeQuery {
	query := (&PostTypeClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := ptf.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(posttypeform.Table, posttypeform.FieldID, id),
			sqlgraph.To(posttype.Table, posttype.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, posttypeform.PostTypeTable, posttypeform.PostTypeColumn),
		)
		fromV = sqlgraph.Neighbors(ptf.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *PostTypeFormClient) Hooks() []Hook {
	return c.hooks.PostTypeForm
}

// Interceptors returns the client interceptors.
func (c *PostTypeFormClient) Interceptors() []Interceptor {
	return c.inters.PostTypeForm
}

func (c *PostTypeFormClient) mutate(ctx context.Context, m *PostTypeFormMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&PostTypeFormCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&PostTypeFormUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&PostTypeFormUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&PostTypeFormDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown PostTypeForm mutation op: %q", m.Op())
	}
}

// SessionClient is a client for the Session schema.
type SessionClient struct {
	config
}

// NewSessionClient returns a client for the Session from the given config.
func NewSessionClient(c config) *SessionClient {
	return &SessionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `session.Hooks(f(g(h())))`.
func (c *SessionClient) Use(hooks ...Hook) {
	c.hooks.Session = append(c.hooks.Session, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `session.Intercept(f(g(h())))`.
func (c *SessionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Session = append(c.inters.Session, interceptors...)
}

// Create returns a builder for creating a Session entity.
func (c *SessionClient) Create() *SessionCreate {
	mutation := newSessionMutation(c.config, OpCreate)
	return &SessionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Session entities.
func (c *SessionClient) CreateBulk(builders ...*SessionCreate) *SessionCreateBulk {
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SessionClient) MapCreateBulk(slice any, setFunc func(*SessionCreate, int)) *SessionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SessionCreateBulk{err: fmt.Errorf("calling to SessionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SessionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SessionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Session.
func (c *SessionClient) Update() *SessionUpdate {
	mutation := newSessionMutation(c.config, OpUpdate)
	return &SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SessionClient) UpdateOne(s *Session) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSession(s))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SessionClient) UpdateOneID(id string) *SessionUpdateOne {
	mutation := newSessionMutation(c.config, OpUpdateOne, withSessionID(id))
	return &SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Session.
func (c *SessionClient) Delete() *SessionDelete {
	mutation := newSessionMutation(c.config, OpDelete)
	return &SessionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SessionClient) DeleteOne(s *Session) *SessionDeleteOne {
	return c.DeleteOneID(s.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SessionClient) DeleteOneID(id string) *SessionDeleteOne {
	builder := c.Delete().Where(session.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SessionDeleteOne{builder}
}

// Query returns a query builder for Session.
func (c *SessionClient) Query() *SessionQuery {
	return &SessionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSession},
		inters: c.Interceptors(),
	}
}

// Get returns a Session entity by its id.
func (c *SessionClient) Get(ctx context.Context, id string) (*Session, error) {
	return c.Query().Where(session.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SessionClient) GetX(ctx context.Context, id string) *Session {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a Session.
func (c *SessionClient) QueryUser(s *Session) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := s.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(session.Table, session.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, session.UserTable, session.UserColumn),
		)
		fromV = sqlgraph.Neighbors(s.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SessionClient) Hooks() []Hook {
	return c.hooks.Session
}

// Interceptors returns the client interceptors.
func (c *SessionClient) Interceptors() []Interceptor {
	return c.inters.Session
}

func (c *SessionClient) mutate(ctx context.Context, m *SessionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SessionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SessionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SessionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SessionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Session mutation op: %q", m.Op())
	}
}

// TempClient is a client for the Temp schema.
type TempClient struct {
	config
}

// NewTempClient returns a client for the Temp from the given config.
func NewTempClient(c config) *TempClient {
	return &TempClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `temp.Hooks(f(g(h())))`.
func (c *TempClient) Use(hooks ...Hook) {
	c.hooks.Temp = append(c.hooks.Temp, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `temp.Intercept(f(g(h())))`.
func (c *TempClient) Intercept(interceptors ...Interceptor) {
	c.inters.Temp = append(c.inters.Temp, interceptors...)
}

// Create returns a builder for creating a Temp entity.
func (c *TempClient) Create() *TempCreate {
	mutation := newTempMutation(c.config, OpCreate)
	return &TempCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Temp entities.
func (c *TempClient) CreateBulk(builders ...*TempCreate) *TempCreateBulk {
	return &TempCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TempClient) MapCreateBulk(slice any, setFunc func(*TempCreate, int)) *TempCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TempCreateBulk{err: fmt.Errorf("calling to TempClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TempCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TempCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Temp.
func (c *TempClient) Update() *TempUpdate {
	mutation := newTempMutation(c.config, OpUpdate)
	return &TempUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TempClient) UpdateOne(t *Temp) *TempUpdateOne {
	mutation := newTempMutation(c.config, OpUpdateOne, withTemp(t))
	return &TempUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TempClient) UpdateOneID(id string) *TempUpdateOne {
	mutation := newTempMutation(c.config, OpUpdateOne, withTempID(id))
	return &TempUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Temp.
func (c *TempClient) Delete() *TempDelete {
	mutation := newTempMutation(c.config, OpDelete)
	return &TempDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TempClient) DeleteOne(t *Temp) *TempDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TempClient) DeleteOneID(id string) *TempDeleteOne {
	builder := c.Delete().Where(temp.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TempDeleteOne{builder}
}

// Query returns a query builder for Temp.
func (c *TempClient) Query() *TempQuery {
	return &TempQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTemp},
		inters: c.Interceptors(),
	}
}

// Get returns a Temp entity by its id.
func (c *TempClient) Get(ctx context.Context, id string) (*Temp, error) {
	return c.Query().Where(temp.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TempClient) GetX(ctx context.Context, id string) *Temp {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TempClient) Hooks() []Hook {
	return c.hooks.Temp
}

// Interceptors returns the client interceptors.
func (c *TempClient) Interceptors() []Interceptor {
	return c.inters.Temp
}

func (c *TempClient) mutate(ctx context.Context, m *TempMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TempCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TempUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TempUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TempDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Temp mutation op: %q", m.Op())
	}
}

// TemplClient is a client for the Templ schema.
type TemplClient struct {
	config
}

// NewTemplClient returns a client for the Templ from the given config.
func NewTemplClient(c config) *TemplClient {
	return &TemplClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `templ.Hooks(f(g(h())))`.
func (c *TemplClient) Use(hooks ...Hook) {
	c.hooks.Templ = append(c.hooks.Templ, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `templ.Intercept(f(g(h())))`.
func (c *TemplClient) Intercept(interceptors ...Interceptor) {
	c.inters.Templ = append(c.inters.Templ, interceptors...)
}

// Create returns a builder for creating a Templ entity.
func (c *TemplClient) Create() *TemplCreate {
	mutation := newTemplMutation(c.config, OpCreate)
	return &TemplCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Templ entities.
func (c *TemplClient) CreateBulk(builders ...*TemplCreate) *TemplCreateBulk {
	return &TemplCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TemplClient) MapCreateBulk(slice any, setFunc func(*TemplCreate, int)) *TemplCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TemplCreateBulk{err: fmt.Errorf("calling to TemplClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TemplCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TemplCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Templ.
func (c *TemplClient) Update() *TemplUpdate {
	mutation := newTemplMutation(c.config, OpUpdate)
	return &TemplUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TemplClient) UpdateOne(t *Templ) *TemplUpdateOne {
	mutation := newTemplMutation(c.config, OpUpdateOne, withTempl(t))
	return &TemplUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TemplClient) UpdateOneID(id string) *TemplUpdateOne {
	mutation := newTemplMutation(c.config, OpUpdateOne, withTemplID(id))
	return &TemplUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Templ.
func (c *TemplClient) Delete() *TemplDelete {
	mutation := newTemplMutation(c.config, OpDelete)
	return &TemplDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TemplClient) DeleteOne(t *Templ) *TemplDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TemplClient) DeleteOneID(id string) *TemplDeleteOne {
	builder := c.Delete().Where(templ.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TemplDeleteOne{builder}
}

// Query returns a query builder for Templ.
func (c *TemplClient) Query() *TemplQuery {
	return &TemplQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTempl},
		inters: c.Interceptors(),
	}
}

// Get returns a Templ entity by its id.
func (c *TemplClient) Get(ctx context.Context, id string) (*Templ, error) {
	return c.Query().Where(templ.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TemplClient) GetX(ctx context.Context, id string) *Templ {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// Hooks returns the client hooks.
func (c *TemplClient) Hooks() []Hook {
	return c.hooks.Templ
}

// Interceptors returns the client interceptors.
func (c *TemplClient) Interceptors() []Interceptor {
	return c.inters.Templ
}

func (c *TemplClient) mutate(ctx context.Context, m *TemplMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TemplCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TemplUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TemplUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TemplDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Templ mutation op: %q", m.Op())
	}
}

// TodoClient is a client for the Todo schema.
type TodoClient struct {
	config
}

// NewTodoClient returns a client for the Todo from the given config.
func NewTodoClient(c config) *TodoClient {
	return &TodoClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `todo.Hooks(f(g(h())))`.
func (c *TodoClient) Use(hooks ...Hook) {
	c.hooks.Todo = append(c.hooks.Todo, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `todo.Intercept(f(g(h())))`.
func (c *TodoClient) Intercept(interceptors ...Interceptor) {
	c.inters.Todo = append(c.inters.Todo, interceptors...)
}

// Create returns a builder for creating a Todo entity.
func (c *TodoClient) Create() *TodoCreate {
	mutation := newTodoMutation(c.config, OpCreate)
	return &TodoCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Todo entities.
func (c *TodoClient) CreateBulk(builders ...*TodoCreate) *TodoCreateBulk {
	return &TodoCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TodoClient) MapCreateBulk(slice any, setFunc func(*TodoCreate, int)) *TodoCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TodoCreateBulk{err: fmt.Errorf("calling to TodoClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TodoCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TodoCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Todo.
func (c *TodoClient) Update() *TodoUpdate {
	mutation := newTodoMutation(c.config, OpUpdate)
	return &TodoUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TodoClient) UpdateOne(t *Todo) *TodoUpdateOne {
	mutation := newTodoMutation(c.config, OpUpdateOne, withTodo(t))
	return &TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TodoClient) UpdateOneID(id string) *TodoUpdateOne {
	mutation := newTodoMutation(c.config, OpUpdateOne, withTodoID(id))
	return &TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Todo.
func (c *TodoClient) Delete() *TodoDelete {
	mutation := newTodoMutation(c.config, OpDelete)
	return &TodoDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TodoClient) DeleteOne(t *Todo) *TodoDeleteOne {
	return c.DeleteOneID(t.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TodoClient) DeleteOneID(id string) *TodoDeleteOne {
	builder := c.Delete().Where(todo.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TodoDeleteOne{builder}
}

// Query returns a query builder for Todo.
func (c *TodoClient) Query() *TodoQuery {
	return &TodoQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTodo},
		inters: c.Interceptors(),
	}
}

// Get returns a Todo entity by its id.
func (c *TodoClient) Get(ctx context.Context, id string) (*Todo, error) {
	return c.Query().Where(todo.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TodoClient) GetX(ctx context.Context, id string) *Todo {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryChildren queries the children edge of a Todo.
func (c *TodoClient) QueryChildren(t *Todo) *TodoQuery {
	query := (&TodoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(todo.Table, todo.FieldID, id),
			sqlgraph.To(todo.Table, todo.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, todo.ChildrenTable, todo.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Todo.
func (c *TodoClient) QueryParent(t *Todo) *TodoQuery {
	query := (&TodoClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := t.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(todo.Table, todo.FieldID, id),
			sqlgraph.To(todo.Table, todo.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, todo.ParentTable, todo.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(t.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TodoClient) Hooks() []Hook {
	return c.hooks.Todo
}

// Interceptors returns the client interceptors.
func (c *TodoClient) Interceptors() []Interceptor {
	return c.inters.Todo
}

func (c *TodoClient) mutate(ctx context.Context, m *TodoMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TodoCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TodoUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TodoUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TodoDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Todo mutation op: %q", m.Op())
	}
}

// UserClient is a client for the User schema.
type UserClient struct {
	config
}

// NewUserClient returns a client for the User from the given config.
func NewUserClient(c config) *UserClient {
	return &UserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `user.Hooks(f(g(h())))`.
func (c *UserClient) Use(hooks ...Hook) {
	c.hooks.User = append(c.hooks.User, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `user.Intercept(f(g(h())))`.
func (c *UserClient) Intercept(interceptors ...Interceptor) {
	c.inters.User = append(c.inters.User, interceptors...)
}

// Create returns a builder for creating a User entity.
func (c *UserClient) Create() *UserCreate {
	mutation := newUserMutation(c.config, OpCreate)
	return &UserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of User entities.
func (c *UserClient) CreateBulk(builders ...*UserCreate) *UserCreateBulk {
	return &UserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UserClient) MapCreateBulk(slice any, setFunc func(*UserCreate, int)) *UserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UserCreateBulk{err: fmt.Errorf("calling to UserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for User.
func (c *UserClient) Update() *UserUpdate {
	mutation := newUserMutation(c.config, OpUpdate)
	return &UserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UserClient) UpdateOne(u *User) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUser(u))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UserClient) UpdateOneID(id string) *UserUpdateOne {
	mutation := newUserMutation(c.config, OpUpdateOne, withUserID(id))
	return &UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for User.
func (c *UserClient) Delete() *UserDelete {
	mutation := newUserMutation(c.config, OpDelete)
	return &UserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UserClient) DeleteOne(u *User) *UserDeleteOne {
	return c.DeleteOneID(u.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UserClient) DeleteOneID(id string) *UserDeleteOne {
	builder := c.Delete().Where(user.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UserDeleteOne{builder}
}

// Query returns a query builder for User.
func (c *UserClient) Query() *UserQuery {
	return &UserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUser},
		inters: c.Interceptors(),
	}
}

// Get returns a User entity by its id.
func (c *UserClient) Get(ctx context.Context, id string) (*User, error) {
	return c.Query().Where(user.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UserClient) GetX(ctx context.Context, id string) *User {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySessions queries the sessions edge of a User.
func (c *UserClient) QuerySessions(u *User) *SessionQuery {
	query := (&SessionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(session.Table, session.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, user.SessionsTable, user.SessionsColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkspaces queries the workspaces edge of a User.
func (c *UserClient) QueryWorkspaces(u *User) *WorkspaceQuery {
	query := (&WorkspaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(workspace.Table, workspace.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, true, user.WorkspacesTable, user.WorkspacesPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkspaceUsers queries the workspace_users edge of a User.
func (c *UserClient) QueryWorkspaceUsers(u *User) *WorkspaceUserQuery {
	query := (&WorkspaceUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := u.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(user.Table, user.FieldID, id),
			sqlgraph.To(workspaceuser.Table, workspaceuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, user.WorkspaceUsersTable, user.WorkspaceUsersColumn),
		)
		fromV = sqlgraph.Neighbors(u.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UserClient) Hooks() []Hook {
	return c.hooks.User
}

// Interceptors returns the client interceptors.
func (c *UserClient) Interceptors() []Interceptor {
	return c.inters.User
}

func (c *UserClient) mutate(ctx context.Context, m *UserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown User mutation op: %q", m.Op())
	}
}

// WorkspaceClient is a client for the Workspace schema.
type WorkspaceClient struct {
	config
}

// NewWorkspaceClient returns a client for the Workspace from the given config.
func NewWorkspaceClient(c config) *WorkspaceClient {
	return &WorkspaceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workspace.Hooks(f(g(h())))`.
func (c *WorkspaceClient) Use(hooks ...Hook) {
	c.hooks.Workspace = append(c.hooks.Workspace, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workspace.Intercept(f(g(h())))`.
func (c *WorkspaceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Workspace = append(c.inters.Workspace, interceptors...)
}

// Create returns a builder for creating a Workspace entity.
func (c *WorkspaceClient) Create() *WorkspaceCreate {
	mutation := newWorkspaceMutation(c.config, OpCreate)
	return &WorkspaceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Workspace entities.
func (c *WorkspaceClient) CreateBulk(builders ...*WorkspaceCreate) *WorkspaceCreateBulk {
	return &WorkspaceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkspaceClient) MapCreateBulk(slice any, setFunc func(*WorkspaceCreate, int)) *WorkspaceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkspaceCreateBulk{err: fmt.Errorf("calling to WorkspaceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkspaceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkspaceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Workspace.
func (c *WorkspaceClient) Update() *WorkspaceUpdate {
	mutation := newWorkspaceMutation(c.config, OpUpdate)
	return &WorkspaceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkspaceClient) UpdateOne(w *Workspace) *WorkspaceUpdateOne {
	mutation := newWorkspaceMutation(c.config, OpUpdateOne, withWorkspace(w))
	return &WorkspaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkspaceClient) UpdateOneID(id string) *WorkspaceUpdateOne {
	mutation := newWorkspaceMutation(c.config, OpUpdateOne, withWorkspaceID(id))
	return &WorkspaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Workspace.
func (c *WorkspaceClient) Delete() *WorkspaceDelete {
	mutation := newWorkspaceMutation(c.config, OpDelete)
	return &WorkspaceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkspaceClient) DeleteOne(w *Workspace) *WorkspaceDeleteOne {
	return c.DeleteOneID(w.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkspaceClient) DeleteOneID(id string) *WorkspaceDeleteOne {
	builder := c.Delete().Where(workspace.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkspaceDeleteOne{builder}
}

// Query returns a query builder for Workspace.
func (c *WorkspaceClient) Query() *WorkspaceQuery {
	return &WorkspaceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkspace},
		inters: c.Interceptors(),
	}
}

// Get returns a Workspace entity by its id.
func (c *WorkspaceClient) Get(ctx context.Context, id string) (*Workspace, error) {
	return c.Query().Where(workspace.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkspaceClient) GetX(ctx context.Context, id string) *Workspace {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUsers queries the users edge of a Workspace.
func (c *WorkspaceClient) QueryUsers(w *Workspace) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspace.Table, workspace.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2M, false, workspace.UsersTable, workspace.UsersPrimaryKey...),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkspaceInvites queries the workspace_invites edge of a Workspace.
func (c *WorkspaceClient) QueryWorkspaceInvites(w *Workspace) *WorkspaceInviteQuery {
	query := (&WorkspaceInviteClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspace.Table, workspace.FieldID, id),
			sqlgraph.To(workspaceinvite.Table, workspaceinvite.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, workspace.WorkspaceInvitesTable, workspace.WorkspaceInvitesColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkspaceUsers queries the workspace_users edge of a Workspace.
func (c *WorkspaceClient) QueryWorkspaceUsers(w *Workspace) *WorkspaceUserQuery {
	query := (&WorkspaceUserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := w.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspace.Table, workspace.FieldID, id),
			sqlgraph.To(workspaceuser.Table, workspaceuser.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, true, workspace.WorkspaceUsersTable, workspace.WorkspaceUsersColumn),
		)
		fromV = sqlgraph.Neighbors(w.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkspaceClient) Hooks() []Hook {
	return c.hooks.Workspace
}

// Interceptors returns the client interceptors.
func (c *WorkspaceClient) Interceptors() []Interceptor {
	return c.inters.Workspace
}

func (c *WorkspaceClient) mutate(ctx context.Context, m *WorkspaceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkspaceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkspaceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkspaceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkspaceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Workspace mutation op: %q", m.Op())
	}
}

// WorkspaceInviteClient is a client for the WorkspaceInvite schema.
type WorkspaceInviteClient struct {
	config
}

// NewWorkspaceInviteClient returns a client for the WorkspaceInvite from the given config.
func NewWorkspaceInviteClient(c config) *WorkspaceInviteClient {
	return &WorkspaceInviteClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workspaceinvite.Hooks(f(g(h())))`.
func (c *WorkspaceInviteClient) Use(hooks ...Hook) {
	c.hooks.WorkspaceInvite = append(c.hooks.WorkspaceInvite, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workspaceinvite.Intercept(f(g(h())))`.
func (c *WorkspaceInviteClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkspaceInvite = append(c.inters.WorkspaceInvite, interceptors...)
}

// Create returns a builder for creating a WorkspaceInvite entity.
func (c *WorkspaceInviteClient) Create() *WorkspaceInviteCreate {
	mutation := newWorkspaceInviteMutation(c.config, OpCreate)
	return &WorkspaceInviteCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkspaceInvite entities.
func (c *WorkspaceInviteClient) CreateBulk(builders ...*WorkspaceInviteCreate) *WorkspaceInviteCreateBulk {
	return &WorkspaceInviteCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkspaceInviteClient) MapCreateBulk(slice any, setFunc func(*WorkspaceInviteCreate, int)) *WorkspaceInviteCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkspaceInviteCreateBulk{err: fmt.Errorf("calling to WorkspaceInviteClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkspaceInviteCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkspaceInviteCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkspaceInvite.
func (c *WorkspaceInviteClient) Update() *WorkspaceInviteUpdate {
	mutation := newWorkspaceInviteMutation(c.config, OpUpdate)
	return &WorkspaceInviteUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkspaceInviteClient) UpdateOne(wi *WorkspaceInvite) *WorkspaceInviteUpdateOne {
	mutation := newWorkspaceInviteMutation(c.config, OpUpdateOne, withWorkspaceInvite(wi))
	return &WorkspaceInviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkspaceInviteClient) UpdateOneID(id string) *WorkspaceInviteUpdateOne {
	mutation := newWorkspaceInviteMutation(c.config, OpUpdateOne, withWorkspaceInviteID(id))
	return &WorkspaceInviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkspaceInvite.
func (c *WorkspaceInviteClient) Delete() *WorkspaceInviteDelete {
	mutation := newWorkspaceInviteMutation(c.config, OpDelete)
	return &WorkspaceInviteDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkspaceInviteClient) DeleteOne(wi *WorkspaceInvite) *WorkspaceInviteDeleteOne {
	return c.DeleteOneID(wi.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkspaceInviteClient) DeleteOneID(id string) *WorkspaceInviteDeleteOne {
	builder := c.Delete().Where(workspaceinvite.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkspaceInviteDeleteOne{builder}
}

// Query returns a query builder for WorkspaceInvite.
func (c *WorkspaceInviteClient) Query() *WorkspaceInviteQuery {
	return &WorkspaceInviteQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkspaceInvite},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkspaceInvite entity by its id.
func (c *WorkspaceInviteClient) Get(ctx context.Context, id string) (*WorkspaceInvite, error) {
	return c.Query().Where(workspaceinvite.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkspaceInviteClient) GetX(ctx context.Context, id string) *WorkspaceInvite {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryWorkspace queries the workspace edge of a WorkspaceInvite.
func (c *WorkspaceInviteClient) QueryWorkspace(wi *WorkspaceInvite) *WorkspaceQuery {
	query := (&WorkspaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wi.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspaceinvite.Table, workspaceinvite.FieldID, id),
			sqlgraph.To(workspace.Table, workspace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, workspaceinvite.WorkspaceTable, workspaceinvite.WorkspaceColumn),
		)
		fromV = sqlgraph.Neighbors(wi.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkspaceInviteClient) Hooks() []Hook {
	return c.hooks.WorkspaceInvite
}

// Interceptors returns the client interceptors.
func (c *WorkspaceInviteClient) Interceptors() []Interceptor {
	return c.inters.WorkspaceInvite
}

func (c *WorkspaceInviteClient) mutate(ctx context.Context, m *WorkspaceInviteMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkspaceInviteCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkspaceInviteUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkspaceInviteUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkspaceInviteDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkspaceInvite mutation op: %q", m.Op())
	}
}

// WorkspaceUserClient is a client for the WorkspaceUser schema.
type WorkspaceUserClient struct {
	config
}

// NewWorkspaceUserClient returns a client for the WorkspaceUser from the given config.
func NewWorkspaceUserClient(c config) *WorkspaceUserClient {
	return &WorkspaceUserClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `workspaceuser.Hooks(f(g(h())))`.
func (c *WorkspaceUserClient) Use(hooks ...Hook) {
	c.hooks.WorkspaceUser = append(c.hooks.WorkspaceUser, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `workspaceuser.Intercept(f(g(h())))`.
func (c *WorkspaceUserClient) Intercept(interceptors ...Interceptor) {
	c.inters.WorkspaceUser = append(c.inters.WorkspaceUser, interceptors...)
}

// Create returns a builder for creating a WorkspaceUser entity.
func (c *WorkspaceUserClient) Create() *WorkspaceUserCreate {
	mutation := newWorkspaceUserMutation(c.config, OpCreate)
	return &WorkspaceUserCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of WorkspaceUser entities.
func (c *WorkspaceUserClient) CreateBulk(builders ...*WorkspaceUserCreate) *WorkspaceUserCreateBulk {
	return &WorkspaceUserCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *WorkspaceUserClient) MapCreateBulk(slice any, setFunc func(*WorkspaceUserCreate, int)) *WorkspaceUserCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &WorkspaceUserCreateBulk{err: fmt.Errorf("calling to WorkspaceUserClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*WorkspaceUserCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &WorkspaceUserCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for WorkspaceUser.
func (c *WorkspaceUserClient) Update() *WorkspaceUserUpdate {
	mutation := newWorkspaceUserMutation(c.config, OpUpdate)
	return &WorkspaceUserUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *WorkspaceUserClient) UpdateOne(wu *WorkspaceUser) *WorkspaceUserUpdateOne {
	mutation := newWorkspaceUserMutation(c.config, OpUpdateOne, withWorkspaceUser(wu))
	return &WorkspaceUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *WorkspaceUserClient) UpdateOneID(id string) *WorkspaceUserUpdateOne {
	mutation := newWorkspaceUserMutation(c.config, OpUpdateOne, withWorkspaceUserID(id))
	return &WorkspaceUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for WorkspaceUser.
func (c *WorkspaceUserClient) Delete() *WorkspaceUserDelete {
	mutation := newWorkspaceUserMutation(c.config, OpDelete)
	return &WorkspaceUserDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *WorkspaceUserClient) DeleteOne(wu *WorkspaceUser) *WorkspaceUserDeleteOne {
	return c.DeleteOneID(wu.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *WorkspaceUserClient) DeleteOneID(id string) *WorkspaceUserDeleteOne {
	builder := c.Delete().Where(workspaceuser.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &WorkspaceUserDeleteOne{builder}
}

// Query returns a query builder for WorkspaceUser.
func (c *WorkspaceUserClient) Query() *WorkspaceUserQuery {
	return &WorkspaceUserQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeWorkspaceUser},
		inters: c.Interceptors(),
	}
}

// Get returns a WorkspaceUser entity by its id.
func (c *WorkspaceUserClient) Get(ctx context.Context, id string) (*WorkspaceUser, error) {
	return c.Query().Where(workspaceuser.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *WorkspaceUserClient) GetX(ctx context.Context, id string) *WorkspaceUser {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUser queries the user edge of a WorkspaceUser.
func (c *WorkspaceUserClient) QueryUser(wu *WorkspaceUser) *UserQuery {
	query := (&UserClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspaceuser.Table, workspaceuser.FieldID, id),
			sqlgraph.To(user.Table, user.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, workspaceuser.UserTable, workspaceuser.UserColumn),
		)
		fromV = sqlgraph.Neighbors(wu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryWorkspace queries the workspace edge of a WorkspaceUser.
func (c *WorkspaceUserClient) QueryWorkspace(wu *WorkspaceUser) *WorkspaceQuery {
	query := (&WorkspaceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := wu.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(workspaceuser.Table, workspaceuser.FieldID, id),
			sqlgraph.To(workspace.Table, workspace.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, false, workspaceuser.WorkspaceTable, workspaceuser.WorkspaceColumn),
		)
		fromV = sqlgraph.Neighbors(wu.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *WorkspaceUserClient) Hooks() []Hook {
	return c.hooks.WorkspaceUser
}

// Interceptors returns the client interceptors.
func (c *WorkspaceUserClient) Interceptors() []Interceptor {
	return c.inters.WorkspaceUser
}

func (c *WorkspaceUserClient) mutate(ctx context.Context, m *WorkspaceUserMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&WorkspaceUserCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&WorkspaceUserUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&WorkspaceUserUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&WorkspaceUserDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown WorkspaceUser mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		AdminUser, App, Kache, Keyvalue, MailConn, Media, OauthConnection, Plan, Post,
		PostCategory, PostStatus, PostTag, PostType, PostTypeForm, Session, Temp,
		Templ, Todo, User, Workspace, WorkspaceInvite, WorkspaceUser []ent.Hook
	}
	inters struct {
		AdminUser, App, Kache, Keyvalue, MailConn, Media, OauthConnection, Plan, Post,
		PostCategory, PostStatus, PostTag, PostType, PostTypeForm, Session, Temp,
		Templ, Todo, User, Workspace, WorkspaceInvite, WorkspaceUser []ent.Interceptor
	}
)

// ExecContext allows calling the underlying ExecContext method of the driver if it is supported by it.
// See, database/sql#DB.ExecContext for more information.
func (c *config) ExecContext(ctx context.Context, query string, args ...any) (stdsql.Result, error) {
	ex, ok := c.driver.(interface {
		ExecContext(context.Context, string, ...any) (stdsql.Result, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.ExecContext is not supported")
	}
	return ex.ExecContext(ctx, query, args...)
}

// QueryContext allows calling the underlying QueryContext method of the driver if it is supported by it.
// See, database/sql#DB.QueryContext for more information.
func (c *config) QueryContext(ctx context.Context, query string, args ...any) (*stdsql.Rows, error) {
	q, ok := c.driver.(interface {
		QueryContext(context.Context, string, ...any) (*stdsql.Rows, error)
	})
	if !ok {
		return nil, fmt.Errorf("Driver.QueryContext is not supported")
	}
	return q.QueryContext(ctx, query, args...)
}
