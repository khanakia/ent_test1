// Code generated by github.com/99designs/gqlgen, DO NOT EDIT.

package generated

import (
	"bytes"
	"context"
	"errors"
	"saas/gen/ent"
	"sync/atomic"

	"github.com/99designs/gqlgen/graphql"
	"github.com/99designs/gqlgen/graphql/introspection"
	gqlparser "github.com/vektah/gqlparser/v2"
	"github.com/vektah/gqlparser/v2/ast"
)

// NewExecutableSchema creates an ExecutableSchema from the ResolverRoot interface.
func NewExecutableSchema(cfg Config) graphql.ExecutableSchema {
	return &executableSchema{
		schema:     cfg.Schema,
		resolvers:  cfg.Resolvers,
		directives: cfg.Directives,
		complexity: cfg.Complexity,
	}
}

type Config struct {
	Schema     *ast.Schema
	Resolvers  ResolverRoot
	Directives DirectiveRoot
	Complexity ComplexityRoot
}

type ResolverRoot interface {
	Mutation() MutationResolver
	Query() QueryResolver
}

type DirectiveRoot struct {
	CanAdmin func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
	CanApp   func(ctx context.Context, obj interface{}, next graphql.Resolver) (res interface{}, err error)
}

type ComplexityRoot struct {
	Media struct {
		AggregateType   func(childComplexity int) int
		Alt             func(childComplexity int) int
		AppID           func(childComplexity int) int
		Checksum        func(childComplexity int) int
		Description     func(childComplexity int) int
		Directory       func(childComplexity int) int
		Disk            func(childComplexity int) int
		Extension       func(childComplexity int) int
		ID              func(childComplexity int) int
		IsVariant       func(childComplexity int) int
		Mediables       func(childComplexity int) int
		MimeType        func(childComplexity int) int
		Name            func(childComplexity int) int
		OriginalMediaID func(childComplexity int) int
		OriginalName    func(childComplexity int) int
		Size            func(childComplexity int) int
		Status          func(childComplexity int) int
		UID             func(childComplexity int) int
		URL             func(childComplexity int) int
		VariantName     func(childComplexity int) int
		WorkspaceID     func(childComplexity int) int
	}

	Mediable struct {
		AppID        func(childComplexity int) int
		ID           func(childComplexity int) int
		Media        func(childComplexity int) int
		MediaID      func(childComplexity int) int
		MediableID   func(childComplexity int) int
		MediableType func(childComplexity int) int
		Order        func(childComplexity int) int
		Tag          func(childComplexity int) int
	}

	Mutation struct {
		CreatePost func(childComplexity int, input ent.CreatePostInput) int
		Ping       func(childComplexity int) int
		UpdatePost func(childComplexity int, id string, input ent.UpdatePostInput) int
	}

	PageInfo struct {
		EndCursor       func(childComplexity int) int
		HasNextPage     func(childComplexity int) int
		HasPreviousPage func(childComplexity int) int
		StartCursor     func(childComplexity int) int
	}

	Post struct {
		ID        func(childComplexity int) int
		Mediables func(childComplexity int) int
		Name      func(childComplexity int) int
		Slug      func(childComplexity int) int
	}

	Query struct {
		Node  func(childComplexity int, id string) int
		Nodes func(childComplexity int, ids []string) int
		Ping  func(childComplexity int) int
		Posts func(childComplexity int) int
	}

	Student struct {
		Name func(childComplexity int) int
	}
}

type executableSchema struct {
	schema     *ast.Schema
	resolvers  ResolverRoot
	directives DirectiveRoot
	complexity ComplexityRoot
}

func (e *executableSchema) Schema() *ast.Schema {
	if e.schema != nil {
		return e.schema
	}
	return parsedSchema
}

func (e *executableSchema) Complexity(typeName, field string, childComplexity int, rawArgs map[string]interface{}) (int, bool) {
	ec := executionContext{nil, e, 0, 0, nil}
	_ = ec
	switch typeName + "." + field {

	case "Media.aggregateType":
		if e.complexity.Media.AggregateType == nil {
			break
		}

		return e.complexity.Media.AggregateType(childComplexity), true

	case "Media.alt":
		if e.complexity.Media.Alt == nil {
			break
		}

		return e.complexity.Media.Alt(childComplexity), true

	case "Media.appID":
		if e.complexity.Media.AppID == nil {
			break
		}

		return e.complexity.Media.AppID(childComplexity), true

	case "Media.checksum":
		if e.complexity.Media.Checksum == nil {
			break
		}

		return e.complexity.Media.Checksum(childComplexity), true

	case "Media.description":
		if e.complexity.Media.Description == nil {
			break
		}

		return e.complexity.Media.Description(childComplexity), true

	case "Media.directory":
		if e.complexity.Media.Directory == nil {
			break
		}

		return e.complexity.Media.Directory(childComplexity), true

	case "Media.disk":
		if e.complexity.Media.Disk == nil {
			break
		}

		return e.complexity.Media.Disk(childComplexity), true

	case "Media.extension":
		if e.complexity.Media.Extension == nil {
			break
		}

		return e.complexity.Media.Extension(childComplexity), true

	case "Media.id":
		if e.complexity.Media.ID == nil {
			break
		}

		return e.complexity.Media.ID(childComplexity), true

	case "Media.isVariant":
		if e.complexity.Media.IsVariant == nil {
			break
		}

		return e.complexity.Media.IsVariant(childComplexity), true

	case "Media.mediables":
		if e.complexity.Media.Mediables == nil {
			break
		}

		return e.complexity.Media.Mediables(childComplexity), true

	case "Media.mimeType":
		if e.complexity.Media.MimeType == nil {
			break
		}

		return e.complexity.Media.MimeType(childComplexity), true

	case "Media.name":
		if e.complexity.Media.Name == nil {
			break
		}

		return e.complexity.Media.Name(childComplexity), true

	case "Media.originalMediaID":
		if e.complexity.Media.OriginalMediaID == nil {
			break
		}

		return e.complexity.Media.OriginalMediaID(childComplexity), true

	case "Media.originalName":
		if e.complexity.Media.OriginalName == nil {
			break
		}

		return e.complexity.Media.OriginalName(childComplexity), true

	case "Media.size":
		if e.complexity.Media.Size == nil {
			break
		}

		return e.complexity.Media.Size(childComplexity), true

	case "Media.status":
		if e.complexity.Media.Status == nil {
			break
		}

		return e.complexity.Media.Status(childComplexity), true

	case "Media.uid":
		if e.complexity.Media.UID == nil {
			break
		}

		return e.complexity.Media.UID(childComplexity), true

	case "Media.URL":
		if e.complexity.Media.URL == nil {
			break
		}

		return e.complexity.Media.URL(childComplexity), true

	case "Media.variantName":
		if e.complexity.Media.VariantName == nil {
			break
		}

		return e.complexity.Media.VariantName(childComplexity), true

	case "Media.workspaceID":
		if e.complexity.Media.WorkspaceID == nil {
			break
		}

		return e.complexity.Media.WorkspaceID(childComplexity), true

	case "Mediable.appID":
		if e.complexity.Mediable.AppID == nil {
			break
		}

		return e.complexity.Mediable.AppID(childComplexity), true

	case "Mediable.id":
		if e.complexity.Mediable.ID == nil {
			break
		}

		return e.complexity.Mediable.ID(childComplexity), true

	case "Mediable.media":
		if e.complexity.Mediable.Media == nil {
			break
		}

		return e.complexity.Mediable.Media(childComplexity), true

	case "Mediable.mediaID":
		if e.complexity.Mediable.MediaID == nil {
			break
		}

		return e.complexity.Mediable.MediaID(childComplexity), true

	case "Mediable.mediableID":
		if e.complexity.Mediable.MediableID == nil {
			break
		}

		return e.complexity.Mediable.MediableID(childComplexity), true

	case "Mediable.mediableType":
		if e.complexity.Mediable.MediableType == nil {
			break
		}

		return e.complexity.Mediable.MediableType(childComplexity), true

	case "Mediable.order":
		if e.complexity.Mediable.Order == nil {
			break
		}

		return e.complexity.Mediable.Order(childComplexity), true

	case "Mediable.tag":
		if e.complexity.Mediable.Tag == nil {
			break
		}

		return e.complexity.Mediable.Tag(childComplexity), true

	case "Mutation.createPost":
		if e.complexity.Mutation.CreatePost == nil {
			break
		}

		args, err := ec.field_Mutation_createPost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.CreatePost(childComplexity, args["input"].(ent.CreatePostInput)), true

	case "Mutation.ping":
		if e.complexity.Mutation.Ping == nil {
			break
		}

		return e.complexity.Mutation.Ping(childComplexity), true

	case "Mutation.updatePost":
		if e.complexity.Mutation.UpdatePost == nil {
			break
		}

		args, err := ec.field_Mutation_updatePost_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Mutation.UpdatePost(childComplexity, args["id"].(string), args["input"].(ent.UpdatePostInput)), true

	case "PageInfo.endCursor":
		if e.complexity.PageInfo.EndCursor == nil {
			break
		}

		return e.complexity.PageInfo.EndCursor(childComplexity), true

	case "PageInfo.hasNextPage":
		if e.complexity.PageInfo.HasNextPage == nil {
			break
		}

		return e.complexity.PageInfo.HasNextPage(childComplexity), true

	case "PageInfo.hasPreviousPage":
		if e.complexity.PageInfo.HasPreviousPage == nil {
			break
		}

		return e.complexity.PageInfo.HasPreviousPage(childComplexity), true

	case "PageInfo.startCursor":
		if e.complexity.PageInfo.StartCursor == nil {
			break
		}

		return e.complexity.PageInfo.StartCursor(childComplexity), true

	case "Post.id":
		if e.complexity.Post.ID == nil {
			break
		}

		return e.complexity.Post.ID(childComplexity), true

	case "Post.mediables":
		if e.complexity.Post.Mediables == nil {
			break
		}

		return e.complexity.Post.Mediables(childComplexity), true

	case "Post.name":
		if e.complexity.Post.Name == nil {
			break
		}

		return e.complexity.Post.Name(childComplexity), true

	case "Post.slug":
		if e.complexity.Post.Slug == nil {
			break
		}

		return e.complexity.Post.Slug(childComplexity), true

	case "Query.node":
		if e.complexity.Query.Node == nil {
			break
		}

		args, err := ec.field_Query_node_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Node(childComplexity, args["id"].(string)), true

	case "Query.nodes":
		if e.complexity.Query.Nodes == nil {
			break
		}

		args, err := ec.field_Query_nodes_args(context.TODO(), rawArgs)
		if err != nil {
			return 0, false
		}

		return e.complexity.Query.Nodes(childComplexity, args["ids"].([]string)), true

	case "Query.ping":
		if e.complexity.Query.Ping == nil {
			break
		}

		return e.complexity.Query.Ping(childComplexity), true

	case "Query.posts":
		if e.complexity.Query.Posts == nil {
			break
		}

		return e.complexity.Query.Posts(childComplexity), true

	case "Student.name":
		if e.complexity.Student.Name == nil {
			break
		}

		return e.complexity.Student.Name(childComplexity), true

	}
	return 0, false
}

func (e *executableSchema) Exec(ctx context.Context) graphql.ResponseHandler {
	opCtx := graphql.GetOperationContext(ctx)
	ec := executionContext{opCtx, e, 0, 0, make(chan graphql.DeferredResult)}
	inputUnmarshalMap := graphql.BuildUnmarshalerMap(
		ec.unmarshalInputCreatePostInput,
		ec.unmarshalInputUpdatePostInput,
	)
	first := true

	switch opCtx.Operation.Operation {
	case ast.Query:
		return func(ctx context.Context) *graphql.Response {
			var response graphql.Response
			var data graphql.Marshaler
			if first {
				first = false
				ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
				data = ec._Query(ctx, opCtx.Operation.SelectionSet)
			} else {
				if atomic.LoadInt32(&ec.pendingDeferred) > 0 {
					result := <-ec.deferredResults
					atomic.AddInt32(&ec.pendingDeferred, -1)
					data = result.Result
					response.Path = result.Path
					response.Label = result.Label
					response.Errors = result.Errors
				} else {
					return nil
				}
			}
			var buf bytes.Buffer
			data.MarshalGQL(&buf)
			response.Data = buf.Bytes()
			if atomic.LoadInt32(&ec.deferred) > 0 {
				hasNext := atomic.LoadInt32(&ec.pendingDeferred) > 0
				response.HasNext = &hasNext
			}

			return &response
		}
	case ast.Mutation:
		return func(ctx context.Context) *graphql.Response {
			if !first {
				return nil
			}
			first = false
			ctx = graphql.WithUnmarshalerMap(ctx, inputUnmarshalMap)
			data := ec._Mutation(ctx, opCtx.Operation.SelectionSet)
			var buf bytes.Buffer
			data.MarshalGQL(&buf)

			return &graphql.Response{
				Data: buf.Bytes(),
			}
		}

	default:
		return graphql.OneShot(graphql.ErrorResponse(ctx, "unsupported GraphQL operation"))
	}
}

type executionContext struct {
	*graphql.OperationContext
	*executableSchema
	deferred        int32
	pendingDeferred int32
	deferredResults chan graphql.DeferredResult
}

func (ec *executionContext) processDeferredGroup(dg graphql.DeferredGroup) {
	atomic.AddInt32(&ec.pendingDeferred, 1)
	go func() {
		ctx := graphql.WithFreshResponseContext(dg.Context)
		dg.FieldSet.Dispatch(ctx)
		ds := graphql.DeferredResult{
			Path:   dg.Path,
			Label:  dg.Label,
			Result: dg.FieldSet,
			Errors: graphql.GetErrors(ctx),
		}
		// null fields should bubble up
		if dg.FieldSet.Invalids > 0 {
			ds.Result = graphql.Null
		}
		ec.deferredResults <- ds
	}()
}

func (ec *executionContext) introspectSchema() (*introspection.Schema, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapSchema(ec.Schema()), nil
}

func (ec *executionContext) introspectType(name string) (*introspection.Type, error) {
	if ec.DisableIntrospection {
		return nil, errors.New("introspection disabled")
	}
	return introspection.WrapTypeFromDef(ec.Schema(), ec.Schema().Types[name]), nil
}

var sources = []*ast.Source{
	{Name: "../cms.graphql", Input: `type Mutation {
  createPost(input: CreatePostInput!): Post!
  updatePost(id: ID!, input: UpdatePostInput!): Post!
}

# extend input CreatePostInput {
#   featuredIDs: [String]
# }

extend type Media {
  URL: String
}
`, BuiltIn: false},
	{Name: "../ent.graphql", Input: `directive @goField(forceResolver: Boolean, name: String, omittable: Boolean) on FIELD_DEFINITION | INPUT_FIELD_DEFINITION
directive @goModel(model: String, models: [String!], forceGenerate: Boolean) on OBJECT | INPUT_OBJECT | SCALAR | ENUM | INTERFACE | UNION
"""
CreatePostInput is used for create Post object.
Input was generated by ent.
"""
input CreatePostInput {
  name: String
  slug: String
  featuredMediaIDs: [ID!]
  iconMediaIDs: [ID!]
}
"""
Define a Relay Cursor type:
https://relay.dev/graphql/connections.htm#sec-Cursor
"""
scalar Cursor
type Media implements Node {
  id: ID!
  appID: String
  disk: String
  directory: String
  name: String
  originalName: String
  extension: String
  mimeType: String
  aggregateType: String
  size: Uint
  description: String
  isVariant: Boolean
  variantName: String
  originalMediaID: String
  checksum: String
  workspaceID: String!
  alt: String
  uid: String
  status: Boolean
  mediables: [Mediable!]
}
type Mediable implements Node {
  id: ID!
  appID: String
  mediaID: ID
  mediableID: String
  mediableType: String
  tag: String
  order: Int
  media: Media
}
"""
An object with an ID.
Follows the [Relay Global Object Identification Specification](https://relay.dev/graphql/objectidentification.htm)
"""
interface Node @goModel(model: "saas/gen/ent.Noder") {
  """
  The id of the object.
  """
  id: ID!
}
"""
Possible directions in which to order a list of items when provided an ` + "`" + `orderBy` + "`" + ` argument.
"""
enum OrderDirection {
  """
  Specifies an ascending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  ASC
  """
  Specifies a descending order for a given ` + "`" + `orderBy` + "`" + ` argument.
  """
  DESC
}
"""
Information about pagination in a connection.
https://relay.dev/graphql/connections.htm#sec-undefined.PageInfo
"""
type PageInfo {
  """
  When paginating forwards, are there more items?
  """
  hasNextPage: Boolean!
  """
  When paginating backwards, are there more items?
  """
  hasPreviousPage: Boolean!
  """
  When paginating backwards, the cursor to continue.
  """
  startCursor: Cursor
  """
  When paginating forwards, the cursor to continue.
  """
  endCursor: Cursor
}
type Post implements Node {
  id: ID!
  name: String
  slug: String
  mediables: [Mediable!]
}
type Query {
  """
  Fetches an object given its ID.
  """
  node(
    """
    ID of the object.
    """
    id: ID!
  ): Node
  """
  Lookup nodes by a list of IDs.
  """
  nodes(
    """
    The list of node IDs.
    """
    ids: [ID!]!
  ): [Node]!
  posts: [Post!]!
}
"""
UpdatePostInput is used for update Post object.
Input was generated by ent.
"""
input UpdatePostInput {
  name: String
  clearName: Boolean
  slug: String
  clearSlug: Boolean
  addFeaturedMediaIDs: [ID!]
  removeFeaturedMediaIDs: [ID!]
  clearFeaturedMedias: Boolean
  addIconMediaIDs: [ID!]
  removeIconMediaIDs: [ID!]
  clearIconMedias: Boolean
}
`, BuiltIn: false},
	{Name: "../schema.graphql", Input: `directive @canAdmin on FIELD_DEFINITION
directive @canApp on FIELD_DEFINITION
# directive @appGql on FIELD_DEFINITION

scalar Time
scalar Uint
scalar Uint64
scalar Map
scalar JSON
scalar JsonSlice

type Student {
  name: String!
}

extend type Query {
  ping: String!
}

extend type Mutation {
  ping: String!
}
`, BuiltIn: false},
}
var parsedSchema = gqlparser.MustLoadSchema(sources...)
